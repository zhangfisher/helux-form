!(function(){"use strict";var _d=Object.defineProperty,Ad=Object.defineProperties;var Dd=Object.getOwnPropertyDescriptors;var Nt=Object.getOwnPropertySymbols;var ac=Object.prototype.hasOwnProperty,ic=Object.prototype.propertyIsEnumerable;var cc=(x,k,P)=>k in x?_d(x,k,{enumerable:!0,configurable:!0,writable:!0,value:P}):x[k]=P,F=(x,k)=>{for(var P in k||(k={}))ac.call(k,P)&&cc(x,P,k[P]);if(Nt)for(var P of Nt(k))ic.call(k,P)&&cc(x,P,k[P]);return x},Y=(x,k)=>Ad(x,Dd(k));var uc=(x,k)=>{var P={};for(var C in x)ac.call(x,C)&&k.indexOf(C)<0&&(P[C]=x[C]);if(x!=null&&Nt)for(var C of Nt(x))k.indexOf(C)<0&&ic.call(x,C)&&(P[C]=x[C]);return P};var lc=(x,k,P)=>new Promise((C,J)=>{var De=G=>{try{Ke(P.next(G))}catch(Z){J(Z)}},tt=G=>{try{Ke(P.throw(G))}catch(Z){J(Z)}},Ke=G=>G.done?C(G.value):Promise.resolve(G.value).then(De,tt);Ke((P=P.apply(x,k)).next())});(self.webpackChunkspeedform_docs=self.webpackChunkspeedform_docs||[]).push([[485],{76485:function(x,k,P){P.r(k),P.d(k,{$:function(){return Yf},EVENT_NAME:function(){return md},LIMU_VER:function(){return vd},RECORD_LOADING:function(){return gd},VER:function(){return Ed},action:function(){return Nf},addMiddleware:function(){return yd},addPlugin:function(){return hd},atom:function(){return lf},atomx:function(){return ff},block:function(){return Uf},createShared:function(){return uf},defineDeriveFnItem:function(){return gf},defineDeriveTask:function(){return mf},derive:function(){return yf},deriveDict:function(){return hf},dynamicBlock:function(){return Bf},emit:function(){return Zf},flush:function(){return td},getActionLoading:function(){return ud},getAtom:function(){return pd},getDeriveLoading:function(){return ld},getMutateLoading:function(){return id},getRawState:function(){return fd},getSnap:function(){return dd},init:function(){return Qf},isAtom:function(){return nd},isDerivedAtom:function(){return rd},isDiff:function(){return cd},model:function(){return zf},modelFactory:function(){return Jf},mutate:function(){return Gf},mutateDict:function(){return Hf},on:function(){return qf},produce:function(){return ad},reactiveDesc:function(){return ed},runDerive:function(){return Ef},runDeriveTask:function(){return vf},runMutate:function(){return $f},runMutateTask:function(){return jf},shallowCompare:function(){return sd},share:function(){return df},sharex:function(){return pf},signal:function(){return Vf},storeSrv:function(){return od},sync:function(){return Wf},syncer:function(){return Xf},useActionLoading:function(){return Ff},useAtom:function(){return _f},useAtomX:function(){return Af},useDerived:function(){return Kf},useEffect:function(){return wf},useGlobalForceUpdate:function(){return Lf},useGlobalId:function(){return Rf},useLayoutEffect:function(){return Of},useLocalForceUpdate:function(){return kf},useMutable:function(){return If},useMutateLoading:function(){return Cf},useObject:function(){return xf},useOnEvent:function(){return bf},useReactive:function(){return Df},useService:function(){return Mf},useStable:function(){return Pf},useWatch:function(){return Tf},watch:function(){return Sf}});function C(e,t){e.includes(t)||e.push(t)}function J(e,t){const n=e.indexOf(t);n>=0&&e.splice(n,1)}function De(e){return Array.from(new Set(e))}function tt(e,t){let n=!1;for(const r of e)if(t.includes(r)){n=!0;break}return n}function Ke(e,t){let n="";const r=e.length;for(let o=0;o<r;o++){const s=e[o];if(t.startsWith(s)){n=s;break}}return n}function G(e,t){if(!e)return[];const n=e(t);return Array.isArray(n)?n:[n]}var Z=function(){if(typeof globalThis!="undefined")return globalThis;if(typeof global!="undefined")return global;if(typeof window!="undefined")return window;if(this!==void 0)return this;throw new Error("no globalThis")}(),ir=!1;function w(...e){}var fc=w;function dc(...e){return e}function Te(...e){return[]}function Kd(...e){}var pc=Object.prototype.toString,yc="[object Map]";function Td(){return!(typeof window!="undefined"&&window.document)}function Vt(e){return pc.call(e)===yc}function ur(e){return e===Number.MAX_SAFE_INTEGER}function ie(){return!(!ir&&Z.name!=="previewFrame"&&!Z.BrowserFS)}function j(e){return e&&typeof e=="object"&&!Array.isArray(e)}function lr(e){return e&&typeof e=="object"}function O(e){return typeof e=="function"}function Rd(e){return ir?Object.prototype.toString.call(e)==="[object AsyncFunction]":!0}function Ut(e){return typeof e=="symbol"}function Bt(e){if(!e)return!1;const t=typeof e;return(t==="object"||t==="function")&&O(e.then)}function Md(e){try{return e.test,!1}catch(t){return!0}}function we(){return typeof Proxy=="function"}function ue(e,t){var u;const{throwErr:n=!1,prefixLabel:r="",suffixLabel:o=", see details in console.",logErr:s=!0,alertErr:a}=t||{};let c=e,i=!1;if(e instanceof Error&&(i=!0,c=e.message),(a!=null?a:ie())&&e&&((u=Z.alert)==null||u.call(Z,`${r}${c}${o}`)),s&&console.error(e),n)throw i?e:new Error(String(e))}function Re(e,t=0){t===0?(console.error(e),ie()&&console.trace(e)):t===1?console.error(e):console.warn(e)}function Oe(e){return ur(e)?1:e+1}var hc=!!Reflect,mc=Object.prototype.hasOwnProperty;function gc(e,t){return hc?Reflect.has(e,t):mc.call(e,t)}function Pe(e,t,n){let r=e[t];return r||(r=e[t]=n),r}function nt(e,t,n){let r=e.get(t);return r||(e.set(t,n),r=n),r}function fr(e,t){let n="";for(const r in e)if(t.startsWith(r)){n=r;break}return n}function dr(e,t){const n=e.get(t);if(n!==void 0)return n;const r=e.get(Number(t)||t);return r!==void 0?r:void 0}function le(e,t){let n,r=e;return t.forEach(o=>{n=Vt(r)?dr(r,o):r[o],r=n}),n}function pr(e,t,n){let r=e;const o=t.length-1;t.forEach((s,a)=>{const c=Vt(r);if(a===o)return void(c?r.set(s,n):r[s]=n);r=c?dr(r,s):r[s]})}function Ec(){return Re("changing shared state is invalid"),!0}function bd(e){return e}function Yt(e,t){return`${t}/${e}`}function Gt(e){return e&&we()}var vc=Object.defineProperty,Ht={};((e,t)=>{for(var n in t)vc(e,n,{get:t[n],enumerable:!0})})(Ht,{useEffect:()=>Dc,useEffectLogic:()=>jt,useForceUpdate:()=>yr,useLayoutEffect:()=>Ac,useObject:()=>Tc,useObjectLogic:()=>mr,useStable:()=>hr});var Sc=0,rt=new Map,$t=0;function _c(e,t){const n=()=>{const r=t();return()=>{rt.delete(e),r&&r()}};if(function(r){$t||($t=r)}(e),function(r){const o=rt.get(r);o?o.count+=1:rt.set(r,{count:1})}(e),$t%2!=0)return n();{const r=function(o){return rt.get(o)}(e);if(r&&r.count>1)return n()}}function jt(e,t,n){const{useState:r,useLayoutEffect:o,useEffect:s}=e.react,{isLayout:a,deps:c}=n,[i]=r(()=>++Sc);(a?o:s)(()=>_c(i,t),c)}function Ac(e,t,n){jt(e,t,{isLayout:!0,deps:n})}function Dc(e,t,n){jt(e,t,{deps:n})}function yr(e){const[,t]=e.react.useState({});return()=>t({})}function Kc(e){const{data:t}=e.current;O(t)?e.current.wrap=(...n)=>e.current.data(...n):j(t)?e.current.wrap=function(n,r){if(!we()){const s={};return Object.keys(n).forEach(a=>{const c=n[a];O(c)?s[a]=(...i)=>r.current.data[a](...i):Object.defineProperty(s,a,{get:()=>r.current.data[a],set(i){r.current.data[a]=i}})}),s}const o={};return new Proxy(n,{get(s,a){const c=s[a];return O(c)?Pe(o,a,(...i)=>r.current.data[a](...i)):c}})}(t,e):e.current.wrap=t}function hr(e,t){const{useRef:n,useMemo:r}=e.react,o=n({data:t,wrap:{},inited:!1});return o.current.data=r(()=>t,[t]),o.current.inited||(Kc(o),o.current.inited=!0),o.current.wrap}function mr(e,t,n,r){const{useState:o,useRef:s,useEffect:a}=e.react,[c]=o(t),i=yr(e),u=s({state:null,unmount:!1,shouldCopy:!0}),f=hr(e,{setState(l){const d=u.current;if(d.unmount)return;let y;const{state:E}=d;n?(y=n(l,d.state||c),r&&y?(d.state=y,d.shouldCopy=!1):d.shouldCopy=!0):(y=(O(l)?l(E):l)||{},d.shouldCopy=!0),Object.assign(c,y||{}),i()},getLatestState(){const l=u.current;return l.shouldCopy&&(l.state=F({},c),l.shouldCopy=!1),l.state}});return a(()=>{const l=u.current;return l.unmount=!1,()=>{l.unmount=!0}},[u]),[c,f.setState,f]}function Tc(e,t){return mr(e,t)}function Rc(e){const t={},n={react:e},r=Ht;return Object.keys(Ht).forEach(o=>{t[o]=r[o].bind(null,n)}),t}const Id=3,Mc="3.11.10",ot=Symbol("M"),gr=Symbol("V"),Er=Symbol("IMMUT_BASE"),W="Map",z="Set",X="Array",bc="Object",Ic=[Symbol.iterator,Symbol.toStringTag],Cc={Map:W,Set:z,Array:X},Wt="[object Object]",st="[object Map]",ct="[object Set]",Xt="[object Array]",zt="[object Function]",Fc={[st]:W,[ct]:z,[Xt]:X,[Wt]:bc},wc=["push","pop","shift","splice","unshift","reverse","copyWithin","delete","fill"],Oc=["set","clear","delete"],Pc=["add","clear","delete"],xc=["splice","sort","unshift","shift"],kc=["concat","copyWithin","entries","every","fill","filter","find","findIndex","flat","flatMap","forEach","includes","indexOf","join","keys","lastIndexOf","map","pop","push","reduce","reduceRight","reverse","shift","unshift","slice","some","sort","splice","values","valueOf"],Lc=["clear","delete","entries","forEach","get","has","keys","set","values"],Nc=["add","clear","delete","entries","forEach","has","keys","values"],vr={[W]:Lc,[z]:Nc,[X]:kc},Vc={[W]:["clear","set","delete"],[z]:["clear","add","delete"],[X]:["pop","push","shift","unshift","splice","sort","copyWithin"]},Uc={[W]:["forEach","get"],[z]:["forEach"],[X]:["forEach","map"]},xe={value:0,usablePrefix:1},Sr={autoFreeze:!1,fastModeRange:"array"},Bc=Object.prototype.toString,Yc=!!Reflect,Gc=Object.prototype.hasOwnProperty;function _r(e,t){return Yc?Reflect.has(e,t):Gc.call(e,t)}function Hc(e,t,n,r){const o=(s,a,c)=>{pe(s)||(r(s,a,c),Array.isArray(s)&&s.forEach((i,u)=>{o(i,s,u)}),at(s)&&s.forEach((i,u)=>{o(i,s,u)}),ke(s)&&Object.keys(s).forEach(i=>{o(s[i],s,i)}))};o(e,t,n)}function fe(e){return Bc.call(e)}function Me(...e){return e}function ke(e){return fe(e)===Wt}function at(e){return fe(e)===st}function Jt(e){return fe(e)===ct}function de(e){return fe(e)===zt}function Ar(e){var t=fe(e);return Fc[t]}function pe(e){const t=fe(e);return![Wt,Xt,st,ct,zt].includes(t)}function Dr(e){return e.constructor.name==="AsyncFunction"||typeof e.then=="function"}function Kr(e){return typeof Promise!="undefined"&&e instanceof Promise}function Zt(e){var t=typeof e;return t==="number"?!0:t==="string"?/^[0-9]*$/.test(e):!1}function $c(e){return typeof e=="symbol"}const jc={[Xt]:Array.prototype,[st]:Map.prototype,[ct]:Set.prototype,[zt]:Function.prototype};function Wc(e){const t=fe(e),n=jc[t]||Object.prototype,r=Object.create(null);return Object.setPrototypeOf(r,n),Object.setPrototypeOf(e,r),e}const qt=new Map;function Le(e){e.rootMeta.modified=!0;const t=n=>{n&&!n.modified&&(n.modified=!0,t(n.parentMeta))};t(e)}function Qt(e,t,n){if(n.apiCtx.debug){const{fast:r}=n;r?e[ot]=t:(Wc(e),e.__proto__[ot]=t)}return e}function Xc(e,t,n){const r=[t],o=ee(e,n);if(o&&o.level>0){const{keyPath:s}=o;return[...s,t]}return r}function zc(e,t,n){const{ver:r,parentMeta:o=null,immutBase:s,compareVer:a,apiCtx:c,hasOnOperate:i}=n,u=Ar(t);let f=[],l=0,d=null;o&&(d=o.copy,l=Zc(d,c),f=Xc(d,e,c));const y={rootMeta:null,parentMeta:o,parent:d,selfType:u,self:t,copy:null,key:e,keyPath:f,level:l,proxyVal:null,proxyItems:null,modified:!1,scopes:[],isImmutBase:s,isDel:!1,isFast:!1,isArrOrderChanged:!1,newNodeStats:{},newNodeMap:new Map,newNodes:[],ver:r,compareVer:a,revoke:Me,hasOnOperate:i,execOnOperate:Me};return l===0?y.rootMeta=y:y.rootMeta=o.rootMeta,y}function Tr(e){const t=en(e);return t?!t.isImmutBase:!1}function Jc(){xe.value>=Number.MAX_SAFE_INTEGER?(xe.value=1,xe.usablePrefix+=1):xe.value+=1;const{value:e,usablePrefix:t}=xe;return`${t}_${e}`}function Zc(e,t){const n=ye(e,t);return n?n.level+1:1}function ee(e,t){return t.metaMap.get(e)}function ye(e,t){let n=t||Mr(e);return(n==null?void 0:n.metaMap.get(e))||null}function Rr(e){return e&&e[gr]||""}function Mr(e){const t=Rr(e);return qt.get(t)||null}function en(e){const t=Mr(e);return t&&t.metaMap.get(e)||null}function br(e,t){const n=en(e),r=en(t);if(!n&&!r)return!Object.is(e,t);const{self:o,modified:s,compareVer:a,ver:c,level:i}=n||{self:e,modified:!1,compareVer:!1,ver:"0",level:0},{self:u,modified:f,compareVer:l,ver:d,level:y}=r||{self:t,modified:!1,compareVer:!1,ver:"0",level:0};return o!==u||(a||l)&&(i===0||y===0)&&c!==d?!0:s||f}function qc(e,t,n=!0){const r=n?br:Object.is;return!((a,c)=>{for(let i in a)if(!(i in c))return!0;for(let i in c)if(r(a[i],c[i]))return!0;return!1})(e,t)}function Cd(e){const t=n=>{if(isPrimitive(n))return n;let r=n;if(Array.isArray(n)&&(r=n.slice(),r.forEach((o,s)=>{r[s]=t(o)})),isSet(n)){const o=Array.from(n);o.forEach((s,a)=>{o[a]=t(s)}),r=new Set(o)}return isMap(n)&&(r=new Map(n),r.forEach((o,s)=>{r.set(s,t(o))})),isObject(n)&&(r={},Object.keys(n).forEach(o=>{r[o]=t(n[o])})),r};return t(e)}function Qc(e,t){const{parentType:n,fastModeRange:r}=t;if(Array.isArray(e))return{copy:e.slice(),fast:!1};const o=r==="array"&&n===X||r==="all";let s=e;return e&&ke(e)&&(s=Object.assign({},e)),at(e)&&(s=new Map(e)),Jt(e)&&(s=new Set(e)),{copy:s,fast:o}}function ea(e,t,n){const{apiCtx:r,immutBase:o}=n;if(o)return{copy:e,fast:!1};const{copy:s,fast:a}=Qc(e,n);return Qt(s,t,{apiCtx:r,fast:a}),{copy:s,fast:a}}function ta(e,t,n){const{copy:r,isArrOrderChanged:o}=e,{targetNode:s,key:a}=n;if(o){const c=r.findIndex(i=>i===t.copy);c>=0&&(r[c]=s);return}r[a]=s}function na(e,t){return ke(e)?Rr(e)===t:!0}function ra(e,t){const{debug:n}=t,r=new Map;t.newNodeMap.forEach(o=>{const{node:s,parent:a,key:c}=o,i=r.get(s);if(i){a[c]=i;return}const u=o;Hc(s,a,c,(f,l,d)=>{const y=ye(f,t);if(y){const{modified:E,copy:p,self:g}=y,v=E?p:g;l[d]=v}}),u.target=a[c],r.set(s,u.target)}),e.scopes.forEach(o=>{const{modified:s,copy:a,parentMeta:c,key:i,self:u,revoke:f,proxyVal:l,isDel:d,isFast:y}=o;if(!a||(n&&(y?delete a[ot]:delete a.__proto__[ot]),!c))return f();const E=s?a:u,p=c.copy,g=c.selfType;if(g===W)return p.set(i,E),f();if(g===z)return p.delete(l),p.add(E),f();if(g===X)return ta(c,o,{targetNode:E,key:i}),f();if(d!==!0)return p[i]=E,f()}),e.scopes.length=0}function oa(e,t){const{self:n,copy:r,modified:o}=e;let s=n;return r&&o&&(s=e.copy),ra(e,t),s}function Ir(e){e.rootMeta.scopes.push(e)}function Cr(e,t,n){const{traps:r,parentType:o,fastModeRange:s,immutBase:a,apiCtx:c}=n,i=zc(e,t,n),{copy:u,fast:f}=ea(t,i,{immutBase:a,parentType:o,fastModeRange:s,apiCtx:c});if(i.copy=u,i.isFast=f,a){const l=new Proxy(u,r);i.proxyVal=l,i.revoke=Me}else{const l=Proxy.revocable(u,r);i.proxyVal=l.proxy,i.revoke=l.revoke}return c.metaMap.set(u,i),c.metaMap.set(i.proxyVal,i),i}function sa(e,t){return e===X?!0:(Uc[e]||[]).includes(t)}function ca(e,t){const{key:n,parentMeta:r,parent:o,parentType:s,fastModeRange:a,readOnly:c,apiCtx:i}=t;let u=e;if(c&&r&&!de(e)){const{copy:l,self:d}=r,y=d[n];if(u!==y){const E=i.metaMap.get(u);E&&(i.metaMap.delete(u),i.metaMap.delete(E.proxyVal)),l[n]=y,u=y}}const f=(l,d)=>{const y=d||"";if(pe(l)||!l)return l;if(!r)throw new Error("[[ createMeta ]]: meta should not be null");if(!de(l)){if(r.newNodeStats[y])return l;let p=ee(l,i);return p||(p=Cr(y,l,t),Ir(p),r.selfType===W?o.set(y,p.copy):o[y]=p.copy),p.proxyVal}if(!sa(s,y)||r.proxyItems)return l;let E=[];if(s===z){const p=new Set;o.forEach(g=>p.add(f(g))),wr(p,r,{dataType:z,apiCtx:i}),E=Qt(p,r,{fast:a,apiCtx:i}),r.copy=E}else if(s===W){const p=new Map;o.forEach((g,v)=>p.set(v,f(g,v))),wr(p,r,{dataType:W,apiCtx:i}),E=Qt(p,r,{fast:a,apiCtx:i}),r.copy=E}else s===X&&y!=="sort"&&(r.copy=r.copy||o.slice(),E=r.proxyVal);return r.proxyItems=E,l};return f(u,n)}function Fr(e,t){if(!ke(e))return e;const n=ee(e,t);return n?n.copy:e}function wr(e,t,n){const{dataType:r,apiCtx:o}=n,s=e.delete.bind(e),a=e.clear.bind(e);if(e.delete=function(...i){return Le(t),s(...i)},e.clear=function(...i){return Le(t),a(...i)},r===z){const c=e.add.bind(e);e.add=function(...u){return Le(t),c(...u)}}if(r===W){const c=e.set.bind(e),i=e.get.bind(e);e.set=function(...f){if(Le(t),t.hasOnOperate){const l=f[1];t.rootMeta.execOnOperate("set",f[0],{mayProxyVal:l,value:l,parentMeta:t})}return c(...f)},e.get=function(...f){const l=i(...f);if(t.hasOnOperate){const d=ye(l,o),y=d?d.copy||d.self:l;t.rootMeta.execOnOperate("get",f[0],{mayProxyVal:l,value:y,parentMeta:t,isChanged:!1})}return l}}}function aa(e){const{calledBy:t,parentMeta:n,op:r,parentType:o}=e;(["deleteProperty","set"].includes(t)||t==="get"&&(o===z&&Pc.includes(r)||o===X&&wc.includes(r)||o===W&&Oc.includes(r)))&&Le(n)}function Or(e,t){const n=e.keyPath.slice();return n.push(t),n.join("|")}function tn(e,t){const{op:n,key:r,value:o,calledBy:s,parentType:a,parentMeta:c,apiCtx:i}=t,u=Fr(o,i);if(!c){e[r]=u;return}const{self:f,copy:l}=c;aa({calledBy:s,parentMeta:c,op:n,key:r,parentType:a});const d=vr[a]||[];if(de(o)&&d.includes(n))return n==="slice"?f.slice:(xc.includes(n)&&(c.isArrOrderChanged=!0),l?a===z||a===W?l[n].bind(l):l[n]:f[n].bind(f));if(!l)return u;const y=l[r],E=()=>{const g=ye(y,i);g&&(g.isDel=!0)},p=()=>{const g=ye(o,i);g&&g.isDel&&(g.isDel=!1,g.key=r,g.keyPath=c.keyPath.concat([r]),g.level=c.level+1,g.parent=c.copy,g.parentMeta=c)};if(s==="deleteProperty"){const g=ye(o,i);g?g.isDel=!0:E();const v=l[r];pe(v)||i.newNodeMap.delete(Or(c,r)),delete l[r];return}pe(u)||(c.newNodeStats[r]=!0,i.newNodeMap.set(Or(c,r),{parent:l,node:u,key:r,target:null})),l[r]=u,E(),p()}function nn(e){if(pe(e))return e;if(Array.isArray(e)&&e.length>0)return e.forEach(nn),Object.freeze(e);if(Jt(e)){const n=e;n.add=()=>n,n.delete=()=>!1,n.clear=Me;for(const r of n.values())Object.freeze(r);return Object.freeze(e)}if(at(e)){const n=e;n.set=()=>n,n.delete=()=>!1,n.clear=Me;for(const r of n.values())Object.freeze(r);return Object.freeze(e)}return Object.getOwnPropertyNames(e).forEach(n=>{const r=e[n];nn(r)}),Object.freeze(e)}const ia=["length","constructor","asymmetricMatch","nodeType","size"],Pr={};ia.forEach(e=>Pr[e]=1);const ua={[X]:1,[z]:1,[W]:1},rn=new Map;function xr(e){var t,n,r,o,s;const a=e||{},c=a.onOperate,i=!!c,u=a.customKeys||[],f=a.fastModeRange||Sr.fastModeRange,l=(t=a[Er])!==null&&t!==void 0?t:!1,d=(n=a.readOnly)!==null&&n!==void 0?n:!1,y=a.disableWarn,E=(r=a.compareVer)!==null&&r!==void 0?r:!1,p=(o=a.debug)!==null&&o!==void 0?o:!1,g=(s=a.autoFreeze)!==null&&s!==void 0?s:Sr.autoFreeze,v=Jc(),_={metaMap:new Map,newNodeMap:new Map,debug:p,metaVer:v};qt.set(v,_);const K=()=>(y||console.warn("can not mutate state at readOnly mode!"),!0),M=(A,R,T)=>{const{mayProxyVal:h,parentMeta:D,value:S,isCustom:m=!1}=T;let I=!1;if(!c)return{isChanged:I,mayProxyVal:h};const B=D||{},{selfType:V="",keyPath:kt=[],copy:qe,self:Qe,modified:Lt,proxyVal:Ae}=B||{};let et=!1;T.isChanged!==void 0?I=T.isChanged:(vr[V]||[]).includes(R)?(et=!0,I=(Vc[V]||[]).includes(R)):A!=="get"&&(I=D?(Lt?qe:Qe)[R]!==S:!0);let ae=null,ar=!1;return c({immutBase:l,parent:Qe,parentType:V,parentProxy:Ae,op:A,replaceValue:sc=>{ar=!0,ae=sc},getReplaced:()=>({isReplaced:ar,replacedValue:ae}),isBuiltInFnKey:et,isChanged:I,isCustom:m,key:R,keyPath:kt,fullKeyPath:kt.concat(R),value:S,proxyValue:h}),{mayProxyVal:ar?ae:h,isChanged:I}},b=(()=>{let A=!0;const R={get:(T,h)=>{if(gr===h)return v;const D=T[h];if(Ic.includes(h))return de(D)?D.bind(T):D;if(h==="__proto__"||h==="toJSON"&&!_r(T,h))return D;let S=D;const m=ee(T,_);if(u.includes(h))return M("get",h,{parentMeta:m,mayProxyVal:S,value:D,isChanged:!1,isCustom:!0}).mayProxyVal;const I=m==null?void 0:m.selfType;return ua[I]&&Pr[h]?m.copy[h]:(S=ca(D,{key:h,compareVer:E,parentMeta:m,parentType:I,ver:v,traps:R,parent:T,fastModeRange:f,immutBase:l,readOnly:d,apiCtx:_,hasOnOperate:i}),I===X&&Zt(h)?M("get",h,{parentMeta:m,mayProxyVal:S,value:D}).mayProxyVal:Cc[I]?(S=tn(T,{op:h,key:h,value:D,metaVer:v,calledBy:"get",parentType:I,parentMeta:m,apiCtx:_}),M("get",h,{parentMeta:m,mayProxyVal:S,value:D}).mayProxyVal):M("get",h,{parentMeta:m,mayProxyVal:S,value:D}).mayProxyVal)},set:(T,h,D)=>{let S=D;const m=ee(T,_);if(Tr(D))if(na(D,v)){if(S=Fr(D,_),S===T[h])return!0}else A=!1;if(d)return M("set",h,{parentMeta:m,isChanged:!1,value:S}),K();if(m&&m.selfType===X){if(m.copy&&m.__callSet&&Zt(h))return M("set",h,{parentMeta:m,value:S}),m.copy[h]=S,!0;m.__callSet=!0}let I=!1;return c?I=M("set",h,{parentMeta:m,value:S}).isChanged:I=(m.modified?m.copy:m.self)[h]!==D,I&&tn(T,{parentMeta:m,key:h,value:S,metaVer:v,calledBy:"set",apiCtx:_}),!0},deleteProperty:(T,h)=>{const D=ee(T,_),S=T[h];return d?(M("del",h,{parentMeta:D,isChanged:!1,value:S}),K()):(M("del",h,{parentMeta:D,isChanged:!0,value:S}),tn(T,{parentMeta:D,op:"del",key:h,value:"",metaVer:v,calledBy:"deleteProperty",apiCtx:_}),!0)},apply:function(T,h,D){return T.apply(h,D)}};return{createDraft:T=>{if(pe(T))throw new Error("base state can not be primitive");let h=T;const D=ee(T,_);if(D){if(l&&D.isImmutBase)return D.proxyVal;h=D.self}const S=Cr("",h,{ver:v,traps:R,immutBase:l,readOnly:d,compareVer:E,apiCtx:_,hasOnOperate:i});return Ir(S),S.execOnOperate=M,rn.set(S.proxyVal,b.finishDraft),S.proxyVal},finishDraft:T=>{const h=ee(T,_);if(!h)throw new Error("rootMeta should not be null!");if(h.level!==0)throw new Error("can not finish sub draft node!");if(h.isImmutBase)return T;let D=oa(h,_);return g&&A&&(D=nn(D)),qt.delete(v),D}}})();return b}function Fd(e){const t=getDraftMeta(e);return t?t.self:e}function wd(e){const t=getDraftMeta(e);return t?deepCopy(t.copy||t.self):e}const kr={has:_r,noop:Me,isObject:ke,isMap:at,isSet:Jt,isFn:de,isPrimitive:pe,isPromiseFn:Dr,isPromiseResult:Kr,isSymbol:$c,canBeNum:Zt,isDraft:Tr,isDiff:br,shallowCompare:qc,getDraftMeta:ye,getDataType:Ar},Lr=Mc;function on(e,t){return xr(t).createDraft(e)}function sn(e){const t=rn.get(e);if(!t)throw new Error("Not a Limu root draft or draft has been finished!");return rn.delete(e),t(e)}function Nr(e){if(!de(e))throw new Error("produce callback is not a function")}function la(e,t){if(Dr(e)||Kr(t))throw new Error("produce callback can not be a promise function or result")}function Vr(e,t,n){Nr(t);const r=on(e,n),o=t(r);return la(t,o),sn(r)}function fa(e,t,n){if(!t||!de(t)){const r=e,o=t;return Nr(e),s=>Vr(s,r,o)}return Vr(e,t,n)}const da=fa,kd=null;function Ld(e){return deepCopyFn(e)}function it(e,t){return xr(Object.assign(Object.assign({},t||{}),{readOnly:!0,[Er]:!0})).createDraft(e)}function Nd(e){conf.autoFreeze=e}function Vd(){return conf.autoFreeze}const Ud=null,Bd=null;var pa=Object.defineProperty,ya=(e,t)=>{for(var n in t)pa(e,n,{get:t[n],enumerable:!0})},Ur={};ya(Ur,{$:()=>ql,EVENT_NAME:()=>cn,LIMU_VER:()=>ha,RECORD_LOADING:()=>an,VER:()=>Br,action:()=>ys,addMiddleware:()=>xa,addPlugin:()=>Va,atom:()=>Cl,atomx:()=>Fl,block:()=>Xl,createShared:()=>Zl,currentDraftRoot:()=>yi,defineDeriveFnItem:()=>Zu,defineDeriveTask:()=>Ju,derive:()=>Es,deriveDict:()=>zu,dynamicBlock:()=>tc,emit:()=>Ga,flush:()=>Nn,getActionLoading:()=>fl,getAtom:()=>zr,getDeriveLoading:()=>Mu,getMutateLoading:()=>ul,getRawState:()=>Ja,getSnap:()=>Za,init:()=>Pa,isAtom:()=>Ue,isDerivedAtom:()=>he,isDiff:()=>Jl,mutate:()=>Ds,mutateDict:()=>qn,on:()=>Ha,produce:()=>da,reactiveDesc:()=>xo,runDerive:()=>Du,runDeriveTask:()=>Ku,runMutate:()=>_s,runMutateTask:()=>As,shallowCompare:()=>zl,share:()=>or,sharex:()=>Il,signal:()=>nc,storeSrv:()=>ml,sync:()=>wl,syncer:()=>Ol,useActionLoading:()=>dl,useAtom:()=>Ks,useAtomX:()=>Ts,useDerived:()=>er,useGlobalForceUpdate:()=>Is,useGlobalId:()=>il,useLocalForceUpdate:()=>Os,useMutable:()=>Ps,useMutateLoading:()=>ll,useOnEvent:()=>pl,useReactive:()=>xs,useService:()=>hl,useWatch:()=>El,watch:()=>Bu});var Br="3.6.1",ha=Lr,cn={ON_DATA_CHANGED:"ON_DATA_CHANGED",ON_SHARE_CREATED:"ON_SHARE_CREATED",ON_ERROR_OCCURED:"ON_ERROR_OCCURED"},an={NO:"no",PRIVATE:"private",GLOBAL:"global"},Yr=0,Gr=Symbol,ma=typeof Gr=="function";function te(e){return ma?Gr(e):(Yr+=1,`__HELUX_SYMBOL_${Yr}__`)}var ga="__proto__",Ea=we(),va=te("HeluxUndefined"),Hr=te("HeluxMutateFnItem"),ut=te("HeluxFnKey"),lt=te("HeluxSharedKey"),$r=te("HeluxReactiveMeta"),un=te("HeluxIsBlock"),Ne=te("HeluxIsAtom"),ft=te("HeluxIsDerivedAtom"),dt=[lt,Ne,ft,un],pt="SingleMutate",Sa="HeluxGlobalLoading",_a=6,Aa=!0,jr=2e3,Da=20,Ve="1",ln="2",yt=1,ht=2,Wr=3,be="|",mt={TASK:"task",MAY_TRANSFER:"may_transfer"},ne={STATIC:"static",HOOK:"hook"},q={USER_STATE:"user_state",GLOGAL_EMPTY:"global_empty",GLOGAL_LOADING:"global_loading",PRIVATE_LOADING:"private_loading"},Ka="derive",Xr="watch",gt="Object",Ta="Map",Ra="Array",Ma="Other",H={SET_STATE:"SetState",MUTATE:"Mutate",ACTION:"Action",REACTIVE:"Reactive",LOADING:"Loading",SYNC:"Sync"};function Ue(e){var t;return e&&(t=e[Ne])!=null?t:!1}function he(e){return e&&e[ft]||!1}function zr(e){return Ue(e)||he(e)?e.val:e}function ba(){return{keySeed:{static:0,hook:0,Reactive:0,Mutate:0},runningFnKey:"",runningSharedKey:0,isIgnore:!1,depKeys:[],GID_INSKEYS_MAP:new Map,FNKEY_STATIC_CTX_MAP:new Map,FNKEY_HOOK_CTX_MAP:new Map,DEPKEY_FNKEYS_MAP:new Map,UNMOUNT_INFO_MAP:new Map,DEPKEY_COMPUTING_FNKEYS_MAP:new Map}}function Ia(){return{keySeed:0,keyPrefix:0,initCount:0,mountedCount:0,latest:{val:null,stateOrResult:null,sharedKey:0,depKey:"",keyPath:[],isDerivedResult:!1,isDerivedAtom:!1},runningKey:"",isDynamic:!1,KEY_CTX_MAP:new Map,KEY_DYNAMIC_CTX_MAP:new Map}}function Ca(){return{keySeed:0,UNMOUNT_INFO_MAP:new Map}}function Fa(){return{keySeed:0,SHARED_KEY_STATE_MAP:new Map,STATE_SHARED_KEY_MAP:new Map,INTERMAL_MAP:new Map,COMPARE_MAP:new Map,isStateChanged:!1}}function Jr(){const e={};return{on:(t,n)=>{Pe(e,t,[]).push(n)},emit:(t,...n)=>{(e[t]||[]).slice().forEach(o=>o(...n))},off:(t,n)=>{const r=e[t]||[],o=r.findIndex(s=>s===n);o>=0&&r.splice(o,1)},canEmit:t=>e[t]}}function Zr(){const e={VER:Br,LIMU_VER:Lr,rootState:{},setState:(t,n)=>{const r=e.ctx.mod[t];if(!r)throw new Error(`moduleName ${t} not found`);r.setState(n)},ctx:{bus:Jr(),userBus:Jr(),mod:{},middlewares:[],plugins:[],sharedScope:Fa(),fnScope:ba(),insScope:Ca(),blockScope:Ia(),markAtomMap:new Map,renderSN:0,globalLoading:null,globalLoadingInternal:null,globalEmpty:null,globalEmptyInternal:null,isRootRender:!0},legacyRoot:{}};return e}var Et={},qr=!1,Qr=null,eo=!1;function N(){return Et.ctx||{}}function wa(){return Et}function to(e){Et=e.ROOT,Qr=e.api,qr=e.inited}function Oa(){return{ROOT:Et,inited:qr,API:Qr}}function Pa(e){if(eo)return!1;eo=!0;const{isRootRender:t=!0}=e;return N().isRootRender=t,!0}function xa(e){const{middlewares:t}=N();t.push(e)}function ka(e,t,n,r){const{middlewares:o}=N();if(!o.length)return;const s={},{sharedKey:a,moduleName:c,forAtom:i}=e,f={forAtom:i,draftRoot:t,draft:n,sharedKey:a,moduleName:c,setData:(l,d)=>s[l]=d,data:s,idx:0,sn:r};o.forEach((l,d)=>{l(Y(F({},f),{idx:d}))})}var{ON_DATA_CHANGED:fn,ON_SHARE_CREATED:no,ON_ERROR_OCCURED:La}=cn,Na=[q.GLOGAL_LOADING,q.PRIVATE_LOADING];function Va(e){const{plugins:t,bus:n}=N();t.push(e);const r={on:(o,s)=>n.on(o,s),onStateChanged:o=>n.on(fn,o)};e.install(r)}function Ua(e,t){const{bus:n}=N();if(n.canEmit(fn)){const{from:r,desc:o}=t,{sharedKey:s,moduleName:a,snap:c,usefulName:i,stateType:u}=e;let f;Na.includes(u)?f=`${i}/setState`:f=`${i}@${r||"Api"}/${o}`,n.emit(fn,{snap:c,sharedKey:s,moduleName:a,type:f})}}function Ba(e){const{bus:t}=N();if(t.canEmit(no)){const{snap:n,sharedKey:r,moduleName:o,usefulName:s}=e,a=`${s}@FactoryApi/createShared`;t.emit(no,{snap:n,sharedKey:r,moduleName:o,type:a})}}function ro(e,t,n){const{bus:r}=N();if(!r.canEmit(t))return!1;const{sharedKey:o,moduleName:s}=e;return r.emit(t,{moduleName:s,sharedKey:o,data:n}),!0}function oo(e,t){ro(e,La,{err:t})||(console.warn("found uncaught error, sugguest add a plugin to handle this error"),console.error(t))}function Ya(){const{userBus:e}=N();return e}function Ga(e,...t){const{userBus:n}=N();n.emit(e,...t)}function Ha(e,t){const{userBus:n}=N();return n.on(e,t),()=>n.off(e,t)}function $a(e,t){return e.__proto__=t,e}function ja(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(e,n)||(e[n]=t[n]);return e}var dn=Object.setPrototypeOf||({__proto__:[]}instanceof Array?$a:ja);function Wa(e){const t=Object.create(null);return dn(t,F({},Object.prototype)),e&&Object.assign(t,e),t}function so(e){if(O(e))return;const t=Object.create(null);return dn(t,Object.prototype),dn(e,t),e}function co(e,t,n){return e[t]=n,!0}function ao(e,t){return e[t]}function Be(e,t){const{set:n=co,get:r=ao,obj:o={}}=t||{};return Object.keys(e).forEach(s=>{Object.defineProperty(o,s,{enumerable:!0,configurable:!1,set:function(a){return n(e,s,a)},get:function(){return r(e,s)}})}),o}function me(e,t){const{set:n=co,get:r=ao}=t||{};if(we())return new Proxy(e,{set(a,c,i){return n(a,c,i)},get(a,c){return r(a,c)}});const o=Wa();return Be(o,{obj:o,set:n,get:r})}var Ye=N();function vt(e){const n=N()[e];return Ye[e]=n,n}function Q(){return Ye.blockScope||vt("blockScope")}function L(){return Ye.fnScope||vt("fnScope")}function re(){return Ye.sharedScope||vt("sharedScope")}function io(){return Ye.insScope||vt("insScope")}function uo(){const{INTERMAL_MAP:e}=re();return e}function Xa(e,t){if(!e||!ie()||!t)return;const{INTERMAL_MAP:n,SHARED_KEY_STATE_MAP:r,STATE_SHARED_KEY_MAP:o}=re();let s=[],a=!1;if(n.forEach(c=>{c.moduleName===e&&c.loc===t&&c.stateType===q.USER_STATE&&s.push(c.sharedKey)}),s.length>1){const c=s[0],i=n.get(c);n.delete(c),i&&(r.delete(i.sharedKey),o.delete(i.rawState))}return a}function Ge(e){return uo().get(e)}function U(e){const t=oe(e);return Ge(t)}function za(e,t){const n=uo(),r=oe(e);n.set(r,t)}function Ja(e){return U(e).rawState}function Za(e,t=!0){const n=U(e);return t?n.prevSnap:n.snap}function oe(e){return e&&(e[lt]||re().STATE_SHARED_KEY_MAP.get(e))||0}function qa(e){const t=re(),{STATE_SHARED_KEY_MAP:n}=t,r=Oe(t.keySeed);return n.set(e,r),t.keySeed=r,r}function Qa(e,t){const{SHARED_KEY_STATE_MAP:n,STATE_SHARED_KEY_MAP:r}=re();n.set(e,t),r.set(t,e)}function ei(e){return re().SHARED_KEY_STATE_MAP.get(e)}function ti(e,t){const{rootState:n,ctx:r}=wa(),{moduleName:o,usefulName:s}=t,a=n[s],c=U(a);if(o&&c&&c.loc!==t.loc){const i=`
loc1:${c.loc} 
loc2:${t.loc}`;return Re(`only-dev-mode tip: moduleName ${o} duplicate! this does not effect helux but the duplicated module will be ignored by devtool`+i)}n[s]=e,r.mod[s]=U(e)}var ni={innerSetState:w};function lo(e,t){const{rawState:n,forAtom:r}=e,o=new Map,s={},a={},c=[],i=F({},n);let u=i;return r&&(u=n.val),Y(F(F({ver:0,sn:0,reactive:n,reactiveRoot:n,sync:w,syncer:w,snap:i,prevSnap:i,rawStateVal:u},e),t),{insCtxMap:o,key2InsKeys:s,id2InsKeys:a,recordId(f,l){if(!f)return;const d=Pe(a,f,[]);C(d,l)},delId(f,l){f&&J(a[f]||[],l)},recordDep(f,l){const d=Pe(s,f,[]);C(d,l)},delDep(f,l){J(s[f]||[],l)},mapInsCtx(f,l){o.set(l,f)},delInsCtx(f){o.delete(f)},extra:{},loadingInternal:ni,level1ArrKeys:c})}var ri={Mutate:"",Reactive:"r",[ne.STATIC]:"s",[ne.HOOK]:"h"};function oi(){const e=io(),t=Oe(e.keySeed);return e.keySeed=t,t}function si(){const e=Q(),{keySeed:t,keyPrefix:n}=e,r=Oe(t);e.keySeed=r;let o=n;return ur(t)&&(o=Oe(n),e.keyPrefix=o),`${o}_${r}`}function ci(){const e=N(),t=e.renderSN,n=t===Number.MAX_VALUE?1:t+1;return e.renderSN=n,n}function pn(e){const t=ri[e],r=L().keySeed,o=Oe(r[e]);return r[e]=o,`${t}${o}`}function ai(){return pn("Reactive")}var{MAY_TRANSFER:ii}=mt,{SET_STATE:ui,REACTIVE:li}=H,fi=()=>({isReplaced:!1,replacedValue:null}),di=()=>{},pi=hn({isFake:!0});function fo(e,t,n=w){const{desc:r="",onRead:o,from:s=li,depKeys:a=[],isTop:c=!1,expired:i=!1}=t;return{draft:e,finish:n,modified:!1,expired:i,sharedKey:0,moduleName:"",hasFlushTask:!1,nextTickFlush:w,data:[],isTop:c,key:"",fnKey:"",depKeys:a,writeKeys:[],desc:r,onRead:o,from:s}}function yn(e){const{ids:t=[],globalIds:n=[],isReactive:r=!1,from:o=ui,enableDep:s=!1,handleCbReturn:a=!0,sn:c=ci(),isFirstCall:i=!1,desc:u=""}=e;return{fnKey:"",depKeys:[],forcedDepKeys:[],triggerReasons:[],ids:t,globalIds:n,readKeys:{},writeKeys:{},arrKeyDict:{},writeKeyPathInfo:{},handleCbReturn:a,draftVal:null,from:o,isReactive:r,enableDep:s,sn:c,isFirstCall:i,desc:u}}function He(e,t,n){const{isChanged:r=!0,parentKeyPath:o=[],op:s="set",parentType:a="Object"}=n,c=o.slice();return c.push(e),{isChanged:r,isCustom:!1,op:s,immutBase:!1,key:e,value:t,proxyValue:t,parentType:a,keyPath:o,fullKeyPath:c,isBuiltInFnKey:!1,replaceValue:w,getReplaced:fi}}function hn(e){const l=e||{},{desc:t="",fn:n=w,task:r=di,depKeys:o=[],writeKeys:s=[],deps:a=Te,isFake:c=!1,onlyDeps:i=!1}=l,u=uc(l,["desc","fn","task","depKeys","writeKeys","deps","isFake","onlyDeps"]);return F({fn:n,task:r,deps:a,oriDesc:"",onlyDeps:i,desc:t,depKeys:o,writeKeys:s,checkDeadCycle:void 0,watchKey:"",isFake:c,enabled:!0},u)}function po(){const e={fnKey:"",fn:w,subFnInfo:pi,checkDeadCycle:!0,isFirstLevel:!0,isExpired:!1,task:w,deps:Te,status:{loading:!1,err:null,ok:!0},forAtom:!1,remainRunCount:0,showLoading:!1,nextLevelFnKeys:[],prevLevelFnKeys:[],mountStatus:yt,depKeys:[],depSharedKeys:[],result:{},fnType:"watch",returnUpstreamResult:!1,scopeType:"static",renderStatus:Ve,proxyResult:{},updater:w,createTime:Date.now(),shouldReplaceResult:!1,isAsync:!1,isAsyncTransfer:!1,isSimpleWatch:!1,isRunning:!1,dcErrorInfo:{err:null,tipFn:w},asyncType:ii,subscribe:t=>{t()},extra:{},setLoading:(t,n=null)=>{const r=!t&&!n;e.status={loading:t,err:n,ok:r}},renderInfo:{time:0,insKey:0,sn:0,getDeps:()=>e.depKeys.slice()}};return e}var yo={draftRoot:{val:null},isFake:!0,isAtom:!0},ho=yn({}),mn=fo(!0,{expired:!0}),Yd=hn(),mo=lo({rawState:{},forAtom:!1,usefulName:""},{}),go=po(),St=yo,gn=ho,Eo="",En=new Map,vn=new Map,Sn=new Map,_n=w,An=[],Dn="";function yi(){return St}var $e={current:()=>Dn,set:e=>Dn=e,del:()=>Dn=""},Kn={current:()=>_n,set:e=>_n=e,del:()=>_n=w},je={current:e=>vn.get(e)||"SetState",set:(e,t)=>vn.set(e,t),del:e=>vn.delete(e)},We={current:()=>An,set:e=>An=e,del:()=>An=[]},se={current:()=>Sn.get(Eo)||mn,markUsing:e=>Eo=e,set:(e,t)=>Sn.set(e,t),del:e=>Sn.delete(e)},Tn={current:e=>En.get(e),set:(e,t)=>En.set(e,t),del:e=>En.delete(e)},_t={current:()=>St,set:(e,t)=>{Object.assign(St,{draftRoot:e,isAtom:t,isFake:!1})},del:()=>St=yo},Rn={current:()=>gn,set:e=>gn=e,del:()=>gn=ho};function Mn(e){const{FNKEY_STATIC_CTX_MAP:t,FNKEY_HOOK_CTX_MAP:n}=L();return e[0]==="s"?t:n}function hi(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=L();nt(n,e,[]).push(t)}function mi(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=L(),r=n.get(e);r&&J(r,t)}function gi(e){const{DEPKEY_FNKEYS_MAP:t}=L(),{depKeys:n,fnKey:r}=e;n.forEach(o=>{const s=t.get(o)||[];J(s,r)})}function vo(e,t){const{FNKEY_STATIC_CTX_MAP:n}=L(),{fnKey:r,prevLevelFnKeys:o}=e;o.forEach(s=>{var c;const a=(c=n.get(s))==null?void 0:c.nextLevelFnKeys;a&&(t?C(a,r):J(a,r))})}function Ei(){const{FNKEY_HOOK_CTX_MAP:e}=L();ie()&&e.forEach(t=>{t.isExpired=!0})}function So(e,t,n){const r=n||pn(t);return O(e)?e[ut]=r:(so(e),e.__proto__[ut]=r),r}function _o(e){return O(e)?e[ut]||"":j(e)&&e.__proto__[ut]||""}function ge(e){return Mn(e).get(e)}function bn(e){return Mn(e).get(e)||go}function Xe(e){const t=_o(e);return ge(t)||null}function At(){const{runningFnKey:e,depKeys:t,runningSharedKey:n,isIgnore:r}=L();return{fnCtx:e?ge(e):null,depKeys:t,isIgnore:r,runningSharedKey:n}}function vi(){return L().runningFnKey}var{USER_STATE:Si}=q;function _i(e,t=8){let n="";if(ie()&&e)try{throw new Error("loc")}catch(r){const o=r.stack.split(`
`),s=o[1]||"";s.includes("webpack-internal")||s.includes("/node_modules/")?n=o.slice(0,16).join(" -> "):n=o.map(c=>c.substring(0,c.indexOf("(")).trim()).slice(4,t).join(" -> ")}return n}function Ao(e){const[t,n]=e.split("/"),r=n.split(be);return{sharedKey:Number(t),keyPath:r,depKey:e}}function Do(e){const{sharedKey:t,forAtom:n}=e,r=n?"/val":"",o=n?["val"]:[];return{depKey:`${t}${r}`,keyPath:o,sharedKey:t}}function $(e,t){try{return Yt(e.join(be),t)}catch(n){return console.warn("found Symbol key in your path :",e),`${t}`}}function Ai(e,t){const{snap:n,prevSnap:r,stateType:o}=e;if(Si!==o)return!0;const{keyPath:s}=Ao(t);try{const a=le(n,s),c=le(r,s);return a!==c}catch(a){return!0}}function Di(e,t){return we()?it(e,{onOperate:t,compareVer:!0}):me(e,{get(n,r){const o=n[r],s=He(r,o,{isChanged:!1,parentKeyPath:[]});return t(s),o}})}function Ki(e,t){if(t!==void 0){if(e)return{val:t};if(j(t))return t}}function Ti(e,t,n){const r=O(t)?t(n):t;return Ki(e,r)}function Dt(e,t){let{value:n}=e;if(t){t(e);const{replacedValue:r,isReplaced:o}=e.getReplaced();o&&(n=r)}return n}function Ko(e){return[Ra,Ta].includes(e)}function Ri(e){return Array.isArray(e)||Vt(e)}var{isObject:Ee,getDataType:To}=kr;function Ro(e,t){if(e===t)return e;const r=t.substring(e.length+1).split(be);return`${e}${be}${r[0]}`}function Mi(e,t){Ke(e,t)||C(e,t)}var In=new Map;function Mo(e,t){let n=!1;const{depKey:r,keyPath:o,sharedKey:s}=e,{stopDepInfo:a,level1ArrKeys:c,recordCb:i}=t,u=In.get(r);if(u)return i(u),!0;const{keys:f,isArrDict:l,depth:d,arrKeyStopDcit:y,stopArrDep:E}=a,p=Ke(c,r),g=o.length>d;if(g||p){let _="",K=d;return p&&(K=d+1,y[p]===!1||E&&(g?_=$(o.slice(0,K),s):_=Ro(p,r))),_||(_=$(o.slice(0,K),s)),p||In.set(r,_),i(_),!0}const v=String(s);for(const _ of f){if(!r.startsWith(_)||_===v)continue;const K=l[_],M=K?Ro(_,r):_;K||In.set(r,M),i(M),n=!0;break}return n}function Cn(e,t){const n=Q(),{runningKey:r}=n;if(r){const{KEY_DYNAMIC_CTX_MAP:o,KEY_CTX_MAP:s,isDynamic:a}=n,i=(a?o:s).get(r);if(i){const{results:u,depKeys:f}=i;t?C(u,t):e.forEach(l=>C(f,l))}}}function Kt(e,t){const n=re(),{COMPARE_MAP:r}=n;let o=r.get(t);return o!==void 0?o:e.sharedKeyStr===t?n.isStateChanged:(o=Ai(e,t),r.set(t,o),o&&(n.isStateChanged=!0),o)}function bo(e,t,n){if(t.includes(n)&&Kt(e,n))return!0;let r=!1;for(const o of t)o.startsWith(n)&&Kt(e,o)&&(r=!0);return r}function bi(){const e=re();e.COMPARE_MAP.clear(),e.isStateChanged=!1}function Fn(e=!0){const t=L();t.isIgnore=e}function Ie(e,t){const{fnCtx:n,depKeys:r,isIgnore:o}=At(),s=t.specificCtx||n;if(!s){Kn.current()(e);return}const{DEPKEY_FNKEYS_MAP:a}=L(),{belongCtx:c,sharedKey:i}=t;if(i&&C(s.depSharedKeys,i),n&&c){n.isFirstLevel=!1,c.isAsync&&(n.isAsync=!0);const f=c.fnKey;C(s.prevLevelFnKeys,f),C(c.nextLevelFnKeys,n.fnKey)}const{fnKey:u}=s;e.forEach(f=>{if(ga===f||o)return;n&&C(r,f);const l=nt(a,f,[]);C(l,u)})}function wn(e){e&&e.depKeys.forEach(t=>Ie([t],{specificCtx:e}))}function Io(e){const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=L(),{fnKey:r}=e;t.set(r,e),vo(e,!0);let o=n.get(r);o?o.c=2:(o={c:1,t:Date.now(),prev:0},n.set(r,o));const{c:s}=o;if(s===2){const a=ge(r);wn(a)}}function Co(e){let t="";return e.depSharedKeys.forEach(n=>{var o;const r=((o=Ge(n))==null?void 0:o.ver)||0;t+=`${r}_`}),t}function Ii(e,t,n){const{DEPKEY_FNKEYS_MAP:r}=L(),o=r.get(t)||[],s=[],a=[];return o.forEach(c=>{const i=ge(c);if(i&&bo(e,i.depKeys,t)){i.isFirstLevel&&s.push(c),i.isAsync&&a.push(c);const u=n[c];n[c]=u===void 0?1:u+1}}),{firstLevelFnKeys:s,asyncFnKeys:a}}function On(e){gi(e),vo(e)}function Ci(){const{FNKEY_HOOK_CTX_MAP:e}=L();if(e.size>=Da){const t=Date.now();e.forEach(n=>{const{mountStatus:r,createTime:o,fnKey:s}=n;[yt,Wr].includes(r)&&t-o>jr&&(On(n),e.delete(s))})}}function Pn(e,t,n,r,o,s=!1,a=!1){const c=Q();c.latest={sharedKey:e,val:t,stateOrResult:n,depKey:r,keyPath:o,isDerivedResult:s,isDerivedAtom:a}}function Fi(){return Q().latest}function Fo(e){const{KEY_DYNAMIC_CTX_MAP:t,KEY_CTX_MAP:n}=Q();return e?t:n}function wo(){return Re("changing shared state is invalid"),!0}function Tt(e,t,n,r,o){return r===Ne?e?t:!1:r===lt?n:o}function xn(e,t,n){e.replaceValue(Tt(e.keyPath.length===0,t,n,e.key,e.value))}function wi(e){let t={};const{rawState:n,sharedKey:r,forAtom:o,onRead:s,isPrimitive:a,stopDepth:c}=e,i=(f,l)=>{const d=$(f,r);Ie([d],{sharedKey:r}),Cn([d]),Pn(r,l,t,d,f)};if(Ea)t=it(n,{customKeys:dt,onOperate:f=>{const{isBuiltInFnKey:l,isCustom:d}=f;if(d)return xn(f,o,r);if(!l){const{fullKeyPath:y}=f,E=Dt(f,s);i(y,E)}},compareVer:!0});else{const f=(l,d,y)=>Be(l,{set:wo,get:(E,p)=>{const g=E[p];if(dt.includes(p))return Tt(d===1,o,r,p,g);const v=He(p,g,{isChanged:!1,parentKeyPath:y});if(d<c&&Ee(g))return f(g,d+1,v.fullKeyPath);const _=Dt(v,s);return i(v.fullKeyPath,_),_}});t=f(n,1,[])}let u=t;return o&&(a?u=n.val:u=me(n,{set:wo,get:(f,l)=>t.val[l]})),Qa(r,t),{sharedRoot:t,sharedState:u}}var Oo=null;function kn(){return Oo}function Oi(e,t){const n=N();let r=n.globalEmpty;if(!r){const{state:o}=t({apiCtx:e,rawState:{},forGlobal:!0,stateType:q.GLOGAL_EMPTY}),s=U(o);n.globalEmpty=o,n.globalEmptyInternal=s}return Oo=r,r}function Ln(e){const{GID_INSKEYS_MAP:t}=L();return nt(t,e,[])}function Pi(){return N().globalEmptyInternal}function Po(e,t){if(!e)return;const n=Ln(e);C(n,t)}function xi(e,t){if(!e)return;const n=Ln(e);J(n,t)}var{REACTIVE:ki}=H,ze=new Map;function Li(e){return!!(e&&!e.expired&&e.modified)}function Ni(e){const{sharedKey:t}=e;e.expired=!0,se.del(e.key);const n=je.current(t);return je.del(t),e.finish(null,{desc:n})}function xo(e,t){const n=oe(e);return t&&je.set(n,t),n}function Nn(e,t){const n=oe(e);Je(n,t)}function Vi(){const e=se.current();e.isTop&&Je(e.sharedKey,e.desc)}function Je(e,t){const n=ze.get(e);Li(n)&&(t&&je.set(e,t),Ni(n))}function Ui(e){const t=ze.get(e)||mn;t.expired=!0}function Bi(e,t){const n=ze.get(e)||mn;n.modified=!0,n.nextTickFlush(t)}function ko(e,t,n){const{sharedKey:r}=e;let o=ze.get(r);if(!o||o.expired){const{from:a=ki}=t,{finish:c,draftRoot:i}=e.setStateFactory({isReactive:!0,from:a,handleCbReturn:!1,enableDep:!0}),u=fo(i,t,c);u.key=ai(),u.nextTickFlush=f=>{const{expired:l,hasFlushTask:d}=u;l||(u.data=[f]),d||(u.hasFlushTask=!0,Promise.resolve().then(()=>{const[y]=u.data;Je(r,y)}))},o=u,ze.set(r,o),se.set(o.key,o)}se.markUsing(o.key),o.fnKey=$e.current();const{draft:s}=o;return{val:n?s.val:s,meta:o}}function Vn(e,t){let n={},r={};const{rawState:o,deep:s,forAtom:a,isPrimitive:c,sharedKey:i}=e;if(Gt(s)){const u={[lt]:i,[Ne]:a},f=(d,y,E)=>{const{val:p}=ko(e,t,d);return p[y]=E,!0},l=(d,y,E)=>{const p=E[y];if(p!==void 0)return p;const{val:g,meta:v}=ko(e,t,d);return $r===y?v:g[y]};if(n=new Proxy(o,{set:(d,y,E)=>f(!1,y,E),get:(d,y)=>l(!1,y,u)}),r=n,a){const d=Y(F({},u),{[Ne]:!1});r=c?o.val:new Proxy(o.val,{set:(y,E,p)=>f(!0,E,p),get:(y,E)=>l(!0,E,d)})}}else n=o,r=o.val;return{draftRoot:n,draft:r}}function Yi(e){const{UNMOUNT_INFO_MAP:t}=io(),{insKey:n,readMap:r,internal:o}=e;o.mapInsCtx(e,n);let s=t.get(n);s?(s.c=2,s.prev=n-1):(s={c:1,t:Date.now(),prev:0},t.set(n,s));const{c:a}=s;a===2&&Object.keys(r).forEach(c=>{o.recordDep(c,n)})}function Lo(e){const{readMap:t,insKey:n,internal:r}=e;Object.keys(t).forEach(o=>r.delDep(o,n)),r.delInsCtx(n)}function Gi(e){const{canCollect:t,isFirstRender:n,currentDepKeys:r}=e;if(!t){n&&(e.depKeys=r.slice());return}e.depKeys=r.slice()}function Hi(e){const{canCollect:t}=e;t&&(e.readMap={},e.delReadMap={},e.depKeys=e.currentDepKeys.slice(),e.currentDepKeys.length=0)}function No(e,t,n){if(!e.canCollect)return;const{parentType:r,rawVal:o}=n,s=Ri(o);s&&Mi(e.internal.level1ArrKeys,t.depKey),e.recordDep(t,r,s)}function Un(e,t){const{depKeys:n,currentDepKeys:r,fixedDepKeys:o}=e;return(t?r:n).concat(o)}function $i(e){if(!e)return;const{updater:t,mountStatus:n,createTime:r}=e;if(n===yt){Date.now()-r>jr?Lo(e):e.needEFUpdate=!0;return}t()}function Vo(e){const{internal:t,isReactive:n}=e,{rawState:r,isDeep:o,sharedKey:s,onRead:a,forAtom:c}=t;if(o){const i=u=>{const{isBuiltInFnKey:f,key:l}=u;if(f)return;if(Ut(l))return xn(u,c,s);const{fullKeyPath:d,keyPath:y,parentType:E}=u,p=Dt(u,a),v={depKey:$(d,s),keyPath:d,parentKeyPath:y,sharedKey:s};No(e,v,{parentType:E,rawVal:p})};if(n){const{draft:u,draftRoot:f}=Vn(t,{onRead:i});e.proxyState=f,e.proxyStateVal=u}else e.proxyState=it(r,{onOperate:i,compareVer:!0})}else e.proxyState=me(r,{set:()=>(Re("changing shared state is invalid"),!0),get:(i,u)=>{const f=i[u];if(Ut(u))return Tt(!0,c,s,u,f);const l=Dt(He(u,f,{isChanged:!1,parentKeyPath:[]}),a),d=Yt(u,s),y=Ee(i)?gt:Ma;return No(e,{depKey:d,keyPath:[u],sharedKey:s},{parentType:y,rawVal:l}),l}})}function ji(e){var T;const{updater:t,sharedState:n,id:r="",globalId:o="",collectType:s="every",deps:a,pure:c=!0,arrDep:i=!0,isReactive:u=!1}=e,f=i&&(T=e.arrIndexDep)!=null?T:!0,l=U(n);if(!l)throw new Error("ERR_OBJ_NOT_SHARED: input object is not a result returned by share api");const d=oi(),{rawState:y,isDeep:E,ver:p,ruleConf:g,level1ArrKeys:v,forAtom:_,sharedKey:K,sharedKeyStr:M,snap:b}=l,{stopDepInfo:A}=g,R={readMap:{},delReadMap:{},pure:c,depKeys:[],fixedDepKeys:[],currentDepKeys:[],isDeep:E,isReactive:u,insKey:d,internal:l,rawState:y,sharedState:n,proxyState:{},proxyStateVal:{},updater:t,mountStatus:yt,renderStatus:Ve,needEFUpdate:!1,createTime:Date.now(),rootVal:null,ver:p,id:r,globalId:o,collectType:s,canCollect:s!=="no",isFirstRender:!0,subscribe:h=>{h()},extra:{},getDeps:()=>Un(R,!0),renderInfo:{setDraft:l.insSetDraft,time:Date.now(),sn:0,snap:b,insKey:d,getDeps:()=>Un(R,!0),getPrevDeps:()=>Un(R,!1)},recordDep:(h,D,S)=>{let m=h.depKey;Mo(h,{stopDepInfo:A,level1ArrKeys:v,recordCb:Ae=>{m=Ae}});const{renderStatus:I,fixedDepKeys:B}=R;if(I===ln)return;const{readMap:V,insKey:kt,currentDepKeys:qe,delReadMap:Qe}=R;Ie([m],{}),vi()&&(J(qe,m),C(R.fixedDepKeys,m));const Lt=()=>{V[m]=1,l.recordDep(m,kt),B.includes(m)||C(qe,m)};if(!V[m]&&!Qe[m]){const{parentKeyPath:Ae}=h;if(c&&D===gt&&Ae){const ae=Ae.length?$(Ae,K):M;V[ae]&&(delete V[ae],Qe[ae]=1,J(qe,ae))}const et=Ko(D);if(et){f&&Lt();return}(!S||!et&&i)&&Lt()}}};if(o&&Po(o,d),Vo(R),l.mapInsCtx(R,d),l.recordId(r,d),O(a)){const h=_?R.proxyState.val:R.proxyState,D=G(a,h),S=R.getDeps().slice();D.includes(h)&&S.push(l.rootValKey),R.fixedDepKeys=S}return R}function Uo(e){const{result:t,forAtom:n}=e;e.proxyResult=me(t,{set:()=>(Re("changing derived result is invalid"),!1),get:(r,o)=>ft===o?n:(Ve===e.renderStatus&&wn(e),t[o])})}function Wi(e){const{proxyState:t,internal:n,renderInfo:r,canCollect:o,isReactive:s}=e,{sharedKey:a,sharedKeyStr:c,insSetState:i,forAtom:u,isPrimitive:f}=n;r.snap=n.snap,r.time=Date.now();const l=u?t.val:t;return e.isFirstRender&&(e.rootVal=l,Tn.set(e.rootVal,e)),!u&&o&&e.recordDep({depKey:c,keyPath:[],sharedKey:a},gt),[s?t:l,i,r]}function Xi(e,t){if(t&&!Ue(e))throw new Error("useAtom only accept atom")}function zi(e){const{ver:t,internal:{ver:n}}=e;t!==n&&(e.ver=n,Vo(e))}function Ji(e){e.mountStatus=ht;const{id:t,globalId:n,insKey:r}=e;e.internal.recordId(t,r),Po(n,r),Yi(e)}function Zi(e){e.mountStatus=Wr;const{id:t,globalId:n,insKey:r}=e;e.internal.delId(t,r),xi(n,r),Lo(e)}function qi(e,t){const n=U(t).sharedKey;return e.internal.sharedKey!==n}function Rt(e,t,n,r){if(N().isRootRender)try{const o=r||n;e.react.useSyncExternalStore(t,n,o)}catch(o){console.error(o)}}var Qi=null;function Bo(e,t,n){const{hookImpl:r,react:o}=e,s=r.useForceUpdate(),a=o.useRef({ctx:Qi});let c=a.current.ctx;return(!c||qi(c,t))&&(c=ji(F({updater:s,sharedState:t},n)),a.current.ctx=c),c}function Yo(e,t){e.react.useEffect(()=>(t.isFirstRender=!1,Tn.del(t.rootVal),t.collectType==="first"&&(t.canCollect=!1),t.needEFUpdate&&(t.needEFUpdate=!1,t.updater()),Ji(t),()=>{Zi(t)}),[t])}function eu(e,t,n,r){n.renderStatus=Ve,Hi(n),Rt(e,n.subscribe,()=>U(t).snap),e.react.useEffect(()=>{n.renderStatus=ln,n.isFirstRender=!1,Gi(n)})}function Bn(e,t,n={}){const r=Bo(e,t,n);return Rt(e,r.subscribe,()=>U(t).snap),Yo(e,r),r}function Mt(e,t,n={}){const{forAtom:r}=n;Xi(t,r);const o=Bo(e,t,n);return eu(e,t,o,n),Yo(e,o),zi(o),{tuple:Wi(o),insCtx:o}}function Go(e,t){const{forAtom:n,label:r,strict:o=!1}=t||{};let s;if(typeof e=="number"?s=Ge(e):s=U(e),!s&&e){const c=e[$r];s=Ge(c==null?void 0:c.sharedKey)}let a=r?`[[${r}]] err:`:"err:";if(!s)if(o)ue(`${a} not a valid shared or atom`,{throwErr:!0});else return null;return n!==void 0&&(n&&!s.forAtom&&ue(`${a} expect a shared but recived a atom`,{throwErr:!0}),!n&&s.forAtom&&ue(`${a} expect a atom but recived a shared`,{throwErr:!0})),s}function ve(e,t){return Go(e,Y(F({},t||{}),{strict:!0}))}var{MUTATE:tu,LOADING:nu}=H,{GLOGAL_LOADING:ru,PRIVATE_LOADING:ou}=q,{PRIVATE:su,GLOBAL:cu}=an,Ho={},au={},iu={time:0,sn:0,getDeps:Te,getPrevDeps:Te,insKey:0,setDraft:w},uu=[Se(Ho,au,tu),w,iu];function lu(e,t){const{internal:n,apiCtx:r}=t,{mutateFnDict:o,moduleName:s}=n,a={};Object.keys(o).forEach(u=>{a[u]={loading:!1,err:null,ok:!0}});const c=s?`${s}@Loading`:"";return e({apiCtx:r,rawState:a,isLoading:!0,stateType:ou},{moduleName:c}).state}var $o=null;function fu(){return $o}function jo(){return N().globalLoadingInternal}function du(e,t){const n=N();let r=n.globalLoading;if(!r){const{state:o}=t({apiCtx:e,rawState:{},stateType:ru},{moduleName:Sa}),s=U(o);n.globalLoadingInternal=s,n.globalLoading=o}return $o=r,r}function Yn(e,t){let n=t;return Ut(t)&&(n=t.toString()),`${e}>${n}`}function Wo(e,t,n){if(!t)return;const{loadingInternal:r}=e;r.innerSetState(o=>{o[t]=n},{from:nu}),n.err&&(ro(e,cn.ON_ERROR_OCCURED,{err:n.err}),console.error(n.err))}function Se(e,t,n){let r=e[n];return r||(r=me(t,{get(o,s){const a=Yn(n,s);return o[a]||{loading:!1,ok:!0,err:null}}}),e[n]=r),r}function bt(e,t){const{internal:n,from:r}=t,{stateType:o,recordLoading:s}=n,a=q.USER_STATE===o;let c=Se(Ho,{},r),i={};if(a)if(su===s)i=n.extra.loadingProxy,i||(i=lu(e,t),n.extra.loadingProxy=i,n.loadingInternal=U(i)),c=Se(n.extra,i,r);else if(cu===s){const u=jo();i=fu(),n.loadingInternal=u,c=Se(u.extra,i,r)}else i=kn();else i=n.sharedState,c=Se(n.extra,i,r);return{loadingState:c,loadingProxy:i}}function Xo(e,t){if(!Ee(t))return e;const n=Object.keys(t);if(!n.length)return e;const r=t[n[0]];return r.__sharedKey?Y(F({},e),{internal:ve(r.__sharedKey)}):e}function zo(e,t){const{internal:n,from:r,apiCtx:o}=t,{stateType:s}=n,a=q.USER_STATE===s;let c=()=>uu;return a&&(c=i=>{const u=Xo(t,i),f=bt(e,u).loadingProxy,{insCtx:{proxyState:l,internal:d,extra:y,renderInfo:E}}=Mt(o,f);return[Se(y,l,r),d.setState,E]}),{useLoading:c,getLoading:i=>{const u=Xo(t,i);return bt(e,u).loadingState}}}function It(e){const t=po();return Object.assign(t,e||{})}function Ce(){const e=L(),{runningFnKey:t}=e;if(!t)return[];const n=ge(t);let r=[];if(n){const{depKeys:o}=e,{depKeys:s}=n,a={};o.forEach(i=>a[i]=1),o.forEach(i=>{const u=fr(a,i);u&&u!==i&&delete a[u]}),Object.keys(a).forEach(i=>C(s,i)),r=s.slice()}return e.runningFnKey="",e.depKeys=[],e.runningSharedKey=0,r}function Jo(e,t){const n=L();n.runningFnKey=e,n.runningSharedKey=t,n.isIgnore=!1}function Zo(e,t){const{specificProps:n,fnCtxBase:r}=t,{scopeType:o}=n,s=So(e,o),a=F({fn:e,fnKey:s},n),c=r?Object.assign(r,a):It(a);return Mn(o).set(s,c),c}function Gn(e){var o;const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=L(),{fnKey:r}=e;On(e),e.extra.deferedWatch=null,t.delete(r),((o=n.get(r))==null?void 0:o.c)===2&&n.delete(r),Ci()}function qo(e){const{DEPKEY_COMPUTING_FNKEYS_MAP:t}=L(),{prevLevelFnKeys:n,depKeys:r}=e;let o=!1;for(const s of r){const a=t.get(s)||[];if(tt(a,n)){o=!0;break}}return o}function pu(e,t=!0,n=be){return e.map(r=>{const[o,s]=r.split("/"),a=s.split(be);return`${t?`${Ge(Number(o)).usefulName}/`:""}${a.join(n)}`})}var Ct=new Map,Ft={WATCH:"1",MUTATE:"2"},yu={[Ft.WATCH]:"watch",[Ft.MUTATE]:"mutate fn or task"};function hu(e=0){return{sn:e,descs:[],errs:[],timer:null,cycle:[]}}function Qo(e,t,n){const r=new Error(`DEAD_CYCLE: module(${e}) found mutate fn(${n}) in these dead cycle fns [${t.join(",")}]`);return r.cause="DeadCycle",r.data=t,r}function mu(e){Ct.delete(e)}function gu(e,t,n,r){const o=yu[r],{desc:s,task:a,fn:c,isFake:i}=t.subFnInfo,u=s?`(${s})`:"",f=`DEAD_CYCLE: found reactive object in ${o}${u} cb is changing module(${e.usefulName})'s some of these dep keys(${pu(n,!1,".")}), it will cause a infinity loop call!`,l=i?t.fn:a||c;return{err:new Error(`[only-dev-mode alert] ${f}`),tipFn:()=>console.error(` ${f} open the stack to find the below fn: 
`,l)}}function Eu(e,t,n){if(e&&n){const{usefulName:r}=e,o=nt(Ct,r,hu(t));o.sn!==t&&(o.descs=[],o.errs=[]);const{descs:s}=o;if(s.length>1&&s[0]===n){const a=s.slice();throw o.cycle=a,s.length=0,Qo(r,a,n)}C(s,n)}}function Hn(e,t){t.tipFn(),ue(t.err,{logErr:!1,throwErr:!1,alertErr:e.alertDeadCycleErr})}function _e(e,t,n){const{depKeys:r,subFnInfo:o}=t;let s=t.depKeys,a=n;r.length>n.length&&(s=n,a=r);let c=!1;if(tt(s,a)){const i=o.desc?Ft.MUTATE:Ft.WATCH,u=gu(e,t,n,i);Hn(e,u),t.dcErrorInfo=u,c=!0}return c}function vu(e,t){const n=Ct.get(e);return!n||!n.cycle.includes(t)?{isIn:!1,cycle:[]}:{isIn:!0,cycle:n.cycle}}function Su(e,t,n=!0){const r=Ct.get(e);if(!r)return;const{timer:o,errs:s}=r;s.push(t),o&&clearTimeout(o),r.timer=setTimeout(()=>{let a=null;for(const c of s)a?c.data.length>a.data.length&&(a=c):a=c;a&&ue(a,{alertErr:n}),s.length=0},0)}function $n(e,t=0){const n=ge(e);n&&(n.showLoading&&(n.setLoading(!0),n.updater()),t&&(n.remainRunCount+=t))}var{MAY_TRANSFER:_u}=mt;function Au(e,t){const{isFirstCall:n=!1,triggerReasons:r=[],sn:o=0,from:s,internal:a=mo,desc:c,fromFnKey:i}=t;if(e.dcErrorInfo.err){Hn(a,e.dcErrorInfo);return}if(e.fnKey===i){_e(a,e,e.depKeys);return}if(e.isSimpleWatch||!e.checkDeadCycle)return e.fn({isFirstCall:n,triggerReasons:r,sn:o});if(H.MUTATE===s&&Eu(a,o,c),e.isRunning&&_e(a,e,t.depKeys||[]))return;const u=se.current();if(u.fnKey===e.fnKey&&_e(a,e,u.writeKeys)||(Je(u.sharedKey,u.desc),e.isRunning===!0&&u.isTop&&_e(a,e,u.writeKeys)))return;e.isRunning=!0,$e.set(e.fnKey);const l=e.fn({isFirstCall:n,triggerReasons:r,sn:o});$e.del();const d=se.current();if(!(d.isTop&&d.fnKey===e.fnKey&&_e(a,e,d.writeKeys))&&!(l&&l.task&&d.from===H.MUTATE&&_e(a,e,e.subFnInfo.writeKeys)))return e.isRunning=!1,l}function Ze(e,t={}){const{isFirstCall:n=!1,forceFn:r=!1,forceTask:o=!1,throwErr:s=!1,triggerReasons:a=[],sn:c=0,err:i,unbox:u=!1,internal:f=mo}=t,l=ge(e),d=(S=null)=>{if(S&&s)throw S;const m=l||go;return u?[m.result.val,S]:[m.result,S]};if(!l)return d(new Error(`not a valid watch or derive cb for key ${e}`));if(l.fnType===Xr)return Au(l,t);const{isAsync:y,fn:E,task:p,isAsyncTransfer:g,forAtom:v,result:_,depKeys:K}=l;l.remainRunCount>0&&(l.remainRunCount-=1);const M=S=>{const m=v?{val:S}:S;!l.returnUpstreamResult&&m&&Object.assign(l.result,m),l.shouldReplaceResult=!0},b=()=>{l.renderInfo.sn=c,l.updater()},A=S=>{const{data:m,err:I=null}=S;I?l.setLoading(!1,I):(M(m),n?y&&l.status.loading&&!qo(l)&&l.setLoading(!1,I):l.remainRunCount===0&&l.setLoading(!1,I)),b(),l.nextLevelFnKeys.forEach(B=>{Ze(B,{isFirstCall:n,sn:c,triggerReasons:a,err:I})})},R=v?_.val:_,T=G(l.deps),h={isFirstCall:n,prevResult:R,triggerReasons:a,input:T,sn:c};if(!y||r||y&&!p){const S=E(h);return A({data:S}),d()}if(y&&n&&l.nextLevelFnKeys.forEach(S=>$n(S,0)),g)return A({err:i}),d();if(l.asyncType===_u){const S=E(h);return A({data:S}),d()}if(p){let S=fc;return n?(K.forEach(m=>hi(m,e)),S=()=>K.forEach(m=>mi(m,e))):o&&l.nextLevelFnKeys.forEach(m=>$n(m)),Promise.resolve(()=>{const m=p(h);return Bt(m)?m:(ue("ERR_NON_FN: derive task arg should be async function!",{throwErr:s}),null)}).then(m=>m()).then(m=>(S(),A({data:m}),d())).catch(m=>{if(S(),A({err:m}),s)throw m;return oo(f,m),d(m)})}return d(i)}function wt(e,t){const n=Xe(e);if(!n)throw new Error("[Helux]: not a derived result");return Ze(n.fnKey,F({},t||{}))}function Du(e,t){return wt(e,{forceFn:!0,throwErr:t})}function Ku(e,t){return Promise.resolve(wt(e,{forceTask:!0,throwErr:t}))}function Tu(e,t){return wt(e,{forceFn:!0,throwErr:t,unbox:!0})}function Ru(e,t){return Promise.resolve(wt(e,{forceTask:!0,throwErr:t,unbox:!0}))}function Mu(e){const t=Xe(e);return t?t.status:{loading:!1,err:null,ok:!0}}function jn(e,t,n){const r=e.get(t);r&&(r.renderInfo.sn=n,$i(r))}function bu(e){const{mutateCtx:t,internal:n}=e,{ids:r,globalIds:o,depKeys:s,triggerReasons:a,isFirstCall:c,from:i,sn:u,desc:f,fnKey:l}=t,{key2InsKeys:d,id2InsKeys:y,insCtxMap:E,rootValKey:p}=n;let g=[],v=[],_=[],K=[];const M={};if(c){const A=Ce();We.set(A)}const b=A=>{if(!Kt(n,A))return;const R=d[A]||[],T=[];for(const S of R){if(g.includes(S))continue;const m=E.get(S);if(!m)continue;const I=m.getDeps();if(I[0]===p){Kt(n,p)&&T.push(S);continue}bo(n,I,A)&&T.push(S)}g=g.concat(T);const{firstLevelFnKeys:h,asyncFnKeys:D}=Ii(n,A,M);_=_.concat(h),K=K.concat(D)};if(s.forEach(A=>b(A)),s.includes(p)||b(p),bi(),r.forEach(A=>{g=g.concat(y[A]||[])}),o.forEach(A=>{Ln(A).forEach(R=>C(v,R))}),g=De(g),_=De(_),K=De(K),K.forEach(A=>$n(A,M[A])),_.forEach(A=>Ze(A,{depKeys:s,sn:u,from:i,triggerReasons:a,internal:n,desc:f,isFirstCall:c,fromFnKey:l})),g.forEach(A=>jn(E,A,u)),v.length){const A=Pi().insCtxMap;v.forEach(R=>jn(A,R,u))}}function Iu(e){const{state:t,internal:n,mutateCtx:r}=e,{rawState:o,isDeep:s,ver:a,snap:c}=n;s?(n.prevSnap=a===0?F({},c):c,n.snap=t,Object.assign(o,t)):n.snap=F({},o),n.ver+=1,n.sn=r.sn,bu(e)}var{MUTATE:Cu}=H;function es(e,t){const{writeKey:n,ids:r,internal:o,opParams:s}=t,{snap:a}=o,{fullKeyPath:c,value:i}=s;Object.keys(e).forEach(u=>{n.startsWith(u)&&le(a,c)!==i&&e[u].forEach(f=>C(r,f))})}function ts(e,t){const{isChanged:n,fullKeyPath:r,keyPath:o,parentType:s,value:a}=e,{internal:c,mutateCtx:i}=t,{arrKeyDict:u,isReactive:f,readKeys:l}=i,{sharedKey:d}=c,y=Ko(s),E=se.current();if(e.op==="get"){y&&(u[$(o,d)]=1);const m=$(r,d);l[m]=1,i.enableDep&&(E.onRead?E.onRead(e):(At().fnCtx&&Ie([m],{sharedKey:d}),f&&(Cn([m]),Pn(d,a,c.sharedState,m,r))));return}if(!n)return;const{moduleName:p,ruleConf:g,level1ArrKeys:v}=c,{writeKeyPathInfo:_,ids:K,globalIds:M,writeKeys:b}=i,A=$(r,d);if(E.key&&(E.isTop?C(E.writeKeys,A):E.from===Cu&&C(bn(E.fnKey).subFnInfo.writeKeys||[],A)),y){const m=$(o,d);_[m]={sharedKey:d,moduleName:p,keyPath:o},b[m]=1}const{hasIds:R,hasGlobalIds:T,stopDepInfo:h}=g;_[A]={sharedKey:d,moduleName:p,keyPath:r};const D=fr(u,A);D&&(b[D]=1),Mo({sharedKey:d,keyPath:r,depKey:A},{stopDepInfo:h,level1ArrKeys:v,recordCb:m=>{b[m]=1}})||(b[A]=1),R&&es(g.idsDict,{ids:K,writeKey:A,internal:c,opParams:e}),T&&es(g.globalIdsDict,{ids:M,writeKey:A,internal:c,opParams:e}),f?Bi(d,E.desc):Ui(d)}function ns(e,t){Object.keys(t).forEach(n=>{e[n]=t[n]})}function Ot(e,t){if(!t)return e;Fn(!0);const n=e.val;return Fn(!1),n}function rs(e){const{partial:t,forAtom:n,draftRoot:r,draftNode:o}=e;if(!t)return;if(!n){Ee(t)&&ns(o,t);return}const s=t.val;if(Ee(o)){Ee(s)?ns(o,s):console.warn("dict atom deny to handle a non-dict returned value!");return}r.val=s}function Fu(e,t){const{internal:n,mutateCtx:r}=e,o=Ot(t,n.forAtom),{from:s,sn:a,desc:c}=r;n.before({from:s,draftRoot:t,draft:o,desc:c,sn:a}),ka(n,t,o,a)}function os(e,t,n,r){const{mutateCtx:o,internal:s}=e,{writeKeys:a,writeKeyPathInfo:c,handleCbReturn:i}=o,{forAtom:u}=s;i&&rs({partial:r,forAtom:u,draftRoot:t,draftNode:n}),Fu(e,t),o.depKeys=Object.keys(a),_t.del(),Rn.del(),e.state=sn(t),e.state!==s.rawState&&(o.triggerReasons=Object.values(c),Iu(e),Ua(s,o))}function ss(e,t){const{ids:n,globalIds:r,from:o,desc:s,fnKey:a}=t;n&&n.forEach(c=>C(e.ids,c)),r&&r.forEach(c=>C(e.globalIds,c)),o&&(e.from=o),s&&(e.desc=s),a&&(e.fnKey=a)}function wu(e){const{internal:t,setFactoryOpts:n}=e,{forAtom:r,rawState:o}=t,s=yn(n),a=on(o,{customKeys:dt,onOperate:i=>{if(i.isCustom)return xn(i,r,t.sharedKey);ts(i,{internal:t,mutateCtx:s})}});_t.set(a,r),Rn.set(s);const c=Ot(a,r);return r&&(s.readKeys={}),{draftRoot:a,draftNode:c,finishMutate(i,u={}){ss(s,u),os({state:{},mutateCtx:s,internal:t},a,c,i)}}}function Ou(e){return so(e),qa(e)}function Pu(e){if(!e)return{};const{desc:t,ids:n,globalIds:r}=e;return{desc:t,ids:n,globalIds:r}}function xu(e){const{forAtom:t=!1}=e;let n=e.rawState;const r=O(n);let o=!1;if(t)n=r?{val:n()}:{val:n},o=!n.val||!lr(n.val);else{if(n=r?n():n,!j(n))throw new Error("ERR_NON_OBJ: pass an non-object to createShared!");if(oe(n))throw new Error("ERR_ALREADY_SHARED: pass a shared object to createShared!")}return{isPrimitive:o,rawState:n}}function cs(e,t,n){let r=null,o=t||"";if(O(e)&&e!==w)r={[Hr]:1,fn:e,deps:Te,oriDesc:o,onlyDeps:!1,desc:o,depKeys:[],writeKeys:[],checkDeadCycle:void 0,watchKey:"",isFake:!1,enabled:!0};else if(j(e)){const{fn:s,desc:a,deps:c,task:i,immediate:u,checkDeadCycle:f,onlyDeps:l=!1}=e,d=t||a||"",y=O(s)?s:void 0,E=O(i)?i:void 0,p=O(c)?c:Te;(s||i)&&(r={[Hr]:1,checkDeadCycle:f,fn:y,watchKey:"",desc:d,oriDesc:d,deps:p,task:E,onlyDeps:l,immediate:u,depKeys:[],writeKeys:[],isFake:!1,enabled:!0})}if(r&&n){const{oriDesc:s}=r;(!s||n[s])&&(r.desc=pn(H.MUTATE))}return r}function as(e,t,n=!0){const r={},o=t||{};if(!e)return r;const s=(a,c)=>{const i=cs(a,c,o);i&&(i.enabled=n,r[i.desc]=i,o[i.desc]=i)};if(Array.isArray(e))if(e.length===1){const a=e[0],c=(j(a)?a.desc:"")||pt;s(e[0],c)}else e.forEach(a=>s(a));else O(e)?s(e,pt):j(e)&&Object.keys(e).forEach(a=>{s(e[a],a)});return r}function ku(e,t={}){var T,h,D,S,m;const{forAtom:n=!1,forGlobal:r=!1,stateType:o=q.USER_STATE}=e,{rawState:s,isPrimitive:a}=xu(e),c=Ou(s),i=t.moduleName||"",u=(T=t.alertDeadCycleErr)!=null?T:ie(),f=(h=t.deep)!=null?h:!0,l=(D=t.checkDeadCycle)!=null?D:!0,d=(S=t.enableMutate)!=null?S:!0,y=t.recordLoading||an.PRIVATE,E=t.rules||[],p=t.before||w,g=t.mutate||w,v=(m=t.stopArrDep)!=null?m:!0,_=t.stopDepth||_a,K=`${c}`,M=n?`${c}/val`:K,b=i||K,A=_i(i),R=as(g,{},d);return{isDestroyed:!1,alertDeadCycleErr:u,checkDeadCycle:l,rawState:s,sharedKey:c,sharedKeyStr:K,rootValKey:M,moduleName:i,usefulName:b,forAtom:n,forGlobal:r,loc:A,deep:f,rules:E,before:p,mutate:g,mutateFnDict:R,onRead:null,enableMutate:d,stateType:o,recordLoading:y,stopArrDep:v,stopDepth:_,isPrimitive:a}}function Lu(e){const{rawState:t,sharedKey:n,rootValKey:r,deep:o,rules:s,stopDepth:a,stopArrDep:c,forAtom:i}=e,u={},f={},l={keys:[],isArrDict:{},arrKeyStopDcit:{},depth:a,stopArrDep:c},d={},y=Gt(o);s.forEach(g=>{const v=[],{when:_,ids:K=[],globalIds:M=[],stopDep:b}=g;let A;if(y){let S="";A=it(t,{onOperate:({fullKeyPath:m,value:I,isBuiltInFnKey:B})=>{if(B)return;const V=$(m,n);S&&V.includes(S)&&v.pop(),v.push(V),d[V]=Array.isArray(I),S=V}})}else A=me(t,{set:Ec,get:(S,m)=>{const I=$([m],n);v.push(I);const B=S[m];return d[I]=Array.isArray(B),B}});const R=i?A.val:A,T=G(_,R),h=(S,m,I)=>{const B=Pe(S,I,[]);m.forEach(V=>C(B,V))},D=S=>{h(u,K,S),h(f,M,S);let m;d[S]?(m=b!=null?b:Aa,l.arrKeyStopDcit[S]=m,l.isArrDict[S]=d[S]):m=b!=null?b:!1,m&&C(l.keys,S)};v.forEach(D),T.includes(R)&&D(r)});const E=Object.keys(u).length>0,p=Object.keys(f).length>0;return{hasIds:E,idsDict:u,hasGlobalIds:p,globalIdsDict:f,stopDepInfo:l}}function Nu(e){const{out:t=!0,desc:n=pt,strict:r=!1}={};return typeof e=="string"?{out:t,desc:e,strict:r}:F({out:t,desc:n,strict:r},e)}function is(e){var r;let t=w,n=!1;return O(e)?t=e:j(e)&&(t=e.deps||w,n=(r=e.immediate)!=null?r:!1),{immediate:n,deps:t}}function Vu(e){return e?typeof e=="boolean"?{enableStatus:e}:j(e)?e:{}:{}}function Uu(e){Array.isArray(e)&&e.forEach(t=>{const n=Tn.current(t),r=U(t)||(n==null?void 0:n.internal);if(r){const{depKey:o,sharedKey:s}=Do(r);Ie([o],{sharedKey:s})}n&&n.recordDep(Do(r))})}function Pt(e,t){const{scopeType:n,fnCtxBase:r,immediate:o,deps:s=w,label:a="watch",sharedState:c,isSimpleWatch:i}=t;if(!O(e))throw new Error(`ERR_NON_FN: pass an non-function to ${a}!`);const u=Zo(e,{specificProps:{scopeType:n,fnType:Xr,isSimpleWatch:i},fnCtxBase:r});Jo(u.fnKey,oe(c));const f=s()||[];return Uu(f),o&&e({isFirstCall:!0}),Ce(),u}function Bu(e,t){const{deps:n,immediate:r}=is(t),o=Pt(e,{scopeType:ne.STATIC,deps:n,immediate:r});return{run:s=>Ze(o.fnKey,{throwErr:s}),unwatch:()=>On(o)}}var us=()=>{},Wn=new Map;function ls(e,t){const{forAtom:n,rawState:r}=e;return n?G(t.deps,r.val):G(t.deps,r)}function Yu(e){var t;return(t=Wn.get(e))!=null?t:!1}function Xn(e,t){const{sn:n,getArgs:r=w,from:o,throwErr:s,isFirstCall:a,fnItem:c,mergeReturn:i}=t,{desc:u="",depKeys:f,task:l=us}=c,d=U(e),{sharedKey:y}=d,E={desc:u,sn:n,from:o},p=Yn(o,u),{draft:g,draftRoot:v}=Vn(d,{depKeys:f,desc:u,from:o}),_=m=>{Je(y,m)},K=m=>{_(u);const{finish:I}=d.setStateFactory(E);return I(m)},M=H.MUTATE===o?ls(d,c):[],b={isFirstCall:a,desc:u,setState:K,input:M,draft:g,draftRoot:v,flush:_},A=r(b)||[b],R=Wn.get(l),T=R===void 0,h=(m,I,B)=>{(T||R)&&Wo(d,p,{loading:m,err:I,ok:B})};h(!0,null,!1);const D=m=>{if(We.del(),h(!1,m,!1),s)throw m;return{snap:d.snap,err:m,result:null}},S=m=>(i&&m&&K(m),h(!1,null,!0),_(u),{snap:d.snap,err:null,result:m});try{const m=l(...A),I=Bt(m);return Wn.set(l,I),I?Promise.resolve(m).then(S).catch(D):S(m)}catch(m){return D(m)}}function fs(e,t){const{sn:n,getArgs:r=w,from:o,throwErr:s,isFirstCall:a=!1,fnItem:c}=t,{desc:i="",watchKey:u,fn:f=us}=c,l=H.MUTATE===o;l&&$e.set(u);const d=U(e),{setStateFactory:y,forAtom:E,sharedState:p}=d,v={desc:i,sn:n,from:o,isFirstCall:a,enableDep:l&&a},_=h=>{const{finish:D}=y(v);return D(h)},K=Ot(p,E),M=l?ls(d,c):[],{draftNode:b,draftRoot:A,finish:R}=y(v),T=r({isFirstCall:a,draft:b,draftRoot:A,setState:_,desc:i,input:M})||[b,{input:M,state:K,draftRoot:A,isFirstCall:a}];try{const h=bn(c.watchKey);if(h.dcErrorInfo.err)return Hn(d,h.dcErrorInfo),{snap:d.snap,err:null,result:null};const D=f(...T);return R(D,{fnKey:h.fnKey}),ds(d,c,a),{snap:d.snap,err:null,result:null}}catch(h){if(ds(d,c,a),s)throw h;return{snap:d.snap,err:h,result:null}}}function ds(e,t,n){n&&!t.onlyDeps&&(At().fnCtx?t.depKeys=Ce():t.depKeys=We.current(),We.del());const r=se.current();r.isTop&&r.fnKey===t.watchKey&&_e(e,bn(t.watchKey),r.writeKeys),$e.del()}function Gu(e,t){var r;Vi(),We.del(),Fn(!1);const n=At().fnCtx;n&&(n.subFnInfo=t,n.checkDeadCycle=(r=t.checkDeadCycle)!=null?r:e.checkDeadCycle,t.watchKey=n.fnKey),t.onlyDeps&&(t.depKeys=Ce())}function zn(e){const{target:t,dict:n}=e,r=Object.keys(n);if(!r.length)return;const o=U(t),{mutateFnDict:s,usefulName:a,forAtom:c,sharedState:i}=o,u=f=>oo(o,f);r.forEach(f=>{const l=s[f];Pt(({sn:d,isFirstCall:y})=>{if(y&&Gu(o,l),!o.enableMutate)return;const{desc:E,fn:p,task:g,immediate:v}=l,_=vu(a,E);try{if(_.isIn)throw Qo(a,_.cycle,E);const K={sn:d,throwErr:!0,isFirstCall:y,fnItem:l,from:H.MUTATE};if(p&&(y||!g)&&fs(t,K),g){y&&(l.depKeys=Ce());const M=y&&(v!=null?v:!p);(!y||M)&&Xn(t,K).catch(u)}return l}catch(K){K.cause==="DeadCycle"&&Su(a,K,o.alertDeadCycleErr),u(K)}},{deps:()=>l.deps?l.deps(Ot(i,c))||[]:[],sharedState:t,scopeType:ne.STATIC,immediate:!0})})}var{ACTION:ps}=H;function Hu(e,t){const{label:n,throwErr:r,desc:o="",task:s,mergeReturn:a=!0}=t,c=ve(e,{label:n}),{forAtom:i}=c,u=(f,l)=>{const d=l!=null?l:r,y=hn({desc:o,task:s,depKeys:[]}),E=(p,g)=>p.__action?p.__action(g):p(g);return Xn(e,{fnItem:y,from:ps,mergeReturn:a,throwErr:d,getArgs:({draft:p,draftRoot:g,setState:v,desc:_,flush:K})=>[{draft:p,draftRoot:g,setState:v,desc:_,payload:f,flush:K,merge:b=>{rs({partial:b,forAtom:i,draftRoot:g,draftNode:p})},dispatch:E}]})};return Wo(c,Yn(ps,o),{loading:!1,ok:!0,err:null}),u.__sharedKey=c.sharedKey,u.__fnName=o,u.__task=s,s.__action=u,u}function ys(e){return t=>(n,r="",o)=>Hu(e,{task:n,desc:r,label:"action",mergeReturn:t,throwErr:o})}var{TASK:hs}=mt,{STATIC:$u,HOOK:ju}=ne;function ms(e,t,n){if(!n&&(!j(t)||Bt(t)))throw new Error("ERR_NON_OBJ: derive,deriveAsync expect result to be a plain object");const{isAsync:r,isAsyncTransfer:o}=e;if(r&&!o){const s=_o(t),a=oe(t);if(s&&e.fnKey!==s||a)throw new Error("ERR_INVALID_CALL: derive,deriveAsync can not transfer another derived result or shared state, it will cause wrong result")}}function Wu(e,t){const n=me(e.result,{set:()=>(Re("changing derived result is invalid"),!1),get:(r,o)=>{if(o===ft)return t;const s=r[o];return Ie(e.depKeys,{belongCtx:e}),Cn(e.depKeys,n),Pn(0,s,n,"",[o],!0,t),s}});return e.proxyResult=n,n}function gs(e,t){var r;const n=Xe(t.result);n&&(e.depKeys=De(e.depKeys.concat(n.depKeys)),C(n.nextLevelFnKeys,e.fnKey),C(e.prevLevelFnKeys,n.fnKey),e.isFirstLevel=!1,(r=t.isUpstream)==null||r.call(t))}function Xu(e){var M,b;const{scopeType:t=$u,fnCtxBase:n,isAsyncTransfer:r=!1,asyncType:o=hs,returnUpstreamResult:s,runAsync:a=!0,forAtom:c=!1,immediate:i}=e;if(!O(e.fn))throw new Error("ERR_NON_FN: derive need fn arg!");const{fn:u=w,deps:f=w,task:l}=e,d=A=>{const R=G(f);return A.isFirstCall&&R.forEach(T=>gs(p,{result:T})),u(Y(F({},A),{input:R}))},y=(M=e.isAsync)!=null?M:O(l),E=(b=e.showLoading)!=null?b:y,p=Zo(d,{specificProps:{forAtom:c,scopeType:t,fnType:Ka,task:l,deps:f,isAsync:y,asyncType:o,isAsyncTransfer:r,showLoading:E},fnCtxBase:n});Jo(p.fnKey,0);let g=d({isFirstCall:!0,prevResult:null,triggerReasons:[]});Ce();const v=Xe(g);c&&!v&&(g={val:g,z__is_atom_result__:!0});const _=p.fnKey;ms(p,g),gs(p,{result:g,isUpstream:()=>{p.returnUpstreamResult=s!=null?s:!y}}),wn(p),p.returnUpstreamResult||So(g,t,_);const K=a&&o===hs&&(i!=null?i:!e.fn);return l&&K&&Ze(_,{isFirstCall:!0,sn:p.renderInfo.sn+1}).then(A=>{ms(p,A[0],c)}).catch(A=>ue(A)),p.result=g,t===ju&&qo(p)&&p.setLoading(!0),p.returnUpstreamResult?p.proxyResult=g:Wu(p,c),p}function Jn(e,t){const n=O(e)?{fn:e}:e||{};return Xu(F(F({},t||{}),n))}function Es(e){return Jn(e,{forAtom:!0}).proxyResult}function zu(e){return Jn(e).proxyResult}function Ju(e){return t=>Y(F({},t),{deps:e})}function Zu(e){return e}var xt=e=>[e.snap,e.err];function Zn(e){const{target:t,desc:n="",forTask:r=!1}=e,{mutateFnDict:o,snap:s}=U(t),a=n||pt,c=o[a];if(!c)return{snap:s,err:new Error(`mutate fn ${a} not defined`),result:null};if(r&&!c.task)return{snap:s,err:new Error(`mutate task ${a} not defined`),result:null};const i={sn:0,fnItem:c,from:H.MUTATE};return r?Xn(t,i):fs(t,i)}function vs(e,t,n,r){return{run:()=>{const o=Zn({target:e,desc:t});return xt(o)},runTask:()=>Promise.resolve(Zn({target:e,desc:t,forTask:!0})).then(xt),desc:t,oriDesc:n,getSnap:()=>r.snap,snap:r.snap,__sharedKey:r.sharedKey}}function qu(e){const{target:t,fnItem:n,label:r}=e,o=ve(t,{label:r}),s=cs(n,"",o.mutateFnDict);if(!s)throw new Error("not a fn or fnItem { fn }");o.mutateFnDict[s.desc]=s,s.enabled=o.enableMutate;const a={[s.desc]:s};return o.enableMutate&&zn({target:t,dict:a}),vs(t,s.desc,s.oriDesc,o)}function Qu(e){const{target:t,fnDict:n,label:r}=e,o=ve(t,{label:r}),s=as(n,o.mutateFnDict,o.enableMutate);o.enableMutate&&zn({target:t,dict:s});const a={};return Object.keys(s).forEach(c=>{a[c]=vs(t,c,c,o)}),a}function el(e,t){const{label:n,descOrOptions:r,forTask:o=!1}=t,{desc:s,strict:a}=Nu(r);return s?Go(e,{label:n,strict:a})?{ok:!0,desc:s,forTask:o,err:null}:{ok:!1,desc:s,forTask:o,err:new Error("not a valid atom or shared result")}:{ok:!1,desc:s,forTask:o,err:new Error("miss desc")}}function Ss(e,t){const{ok:n,desc:r,forTask:o,err:s}=el(e,t);if(!n)return o?Promise.resolve([e,s]):[e,s];const a=Zn({target:e,desc:r,forTask:o});return o?Promise.resolve(a).then(xt):xt(a)}function _s(e,t){return Ss(e,{descOrOptions:t,label:"runMutate"})}function As(e,t){return Ss(e,{descOrOptions:t,label:"runMutateTask",forTask:!0})}function Ds(e){return t=>qu({target:e,fnItem:t,label:"mutate"})}function qn(e){return t=>Qu({target:e,fnDict:t,label:"mutateDict"})}function Ks(e,t,n={}){const{tuple:r}=Mt(e,t,n);return r}function Ts(e,t,n={}){const{tuple:r}=Mt(e,t,n),[o,s,a]=r;return Y(F({},a),{state:o,setState:s})}var tl="ERR_NOT_DERIVED_RESULT: useDerived only accept derived result",nl="ERR_NOT_ATOM_RESULT: useDerivedAtom only accept derived atom";function rl(e,t,n){return e.isExpired?(e.isExpired=!1,!0):O(n)?!1:n!==t}function ol(e){Gn(e),e.depKeys.length=0,e.prevLevelFnKeys.length=0,e.renderInfo.sn+=1}function sl(e,t){const{result:n,forAtom:r,showLoading:o}=t,{fnCtx:s,input:a,deriveFn:c}=e;let i=!1;if(c)if(rl(s,a,n))i=!0,ol(s);else return;e.input=n;const u=Xe(n);if(!u)throw new Error(tl);if(r&&!he(n))throw new Error(nl);e.deriveFn=()=>u.result,Jn({fn:()=>u.result,deps:()=>[],task:()=>lc(this,null,function*(){return u.result})},{isAsync:u.isAsync,scopeType:ne.HOOK,fnCtxBase:s,isAsyncTransfer:!0,runAsync:!1,returnUpstreamResult:!0,forAtom:r,asyncType:mt.MAY_TRANSFER,showLoading:o}),Uo(s),i&&s.updater()}function Rs(e,t){const{result:n,forAtom:r}=t,{hookImpl:o,react:s}=e,a=o.useForceUpdate(),{current:c}=s.useRef({input:n,deriveFn:null,fnCtx:null});c.fnCtx||(c.fnCtx=It({updater:a,scopeType:ne.HOOK,forAtom:r}));const i=c.fnCtx;return i.renderStatus=Ve,sl(c,t),i}function cl(e,t){t.shouldReplaceResult&&(Uo(t),t.shouldReplaceResult=!1),Rt(e,t.subscribe,()=>Co(t)),e.react.useEffect(()=>{t.renderStatus=ln})}function Ms(e,t){e.react.useEffect(()=>(t.mountStatus=ht,Io(t),()=>{Gn(t)}),[t])}function Qn(e,t){const n=Rs(e,t);return Rt(e,n.subscribe,()=>Co(n)),Ms(e,n),n}function al(e,t){const n=Rs(e,t);return cl(e,n),Ms(e,n),n}function er(e,t,n){const r=al(e,F({result:t},n||{})),{proxyResult:o,status:s,renderInfo:a}=r;return[he(t)?o.val:o,s,a]}function bs(e,t,n){if(t===null)return n;if(!O(t))return null;const{sharedState:r,forAtom:o}=e,s=o?r.val:r,a={};Kn.set(i=>a[i[0]]=1);const c=G(t,s);return Kn.del(),c.includes(s)?e.key2InsKeys:a}function Is(e,t,n){const r=ve(t),[o]=e.react.useState(()=>bs(r,n,null));return s=>{const{insCtxMap:a,key2InsKeys:c}=r,i=bs(r,s,c)||o||c,u={};if(Object.keys(i).forEach(l=>{(c[l]||[]).forEach(y=>u[y]=1)}),Object.keys(u).length){r.sn+=1;const l=r.sn;Object.keys(u).forEach(d=>{jn(a,Number(d),l)})}}}function il(e,t){rr(e);const n=kn();return Bn(e,n,{collectType:"no",globalId:t}).renderInfo}var{ACTION:Cs,MUTATE:Fs}=H;function tr(e,t){rr(e);const{target:n,from:r="Mutate"}=t||{};let o=jo();n&&(o=ve(n));const{loadingProxy:s,loadingState:a}=bt(ce,{apiCtx:e,internal:o,from:r});return{loadingProxy:s,loadingState:a,internal:o,from:r}}function ws(e,t){const{loadingProxy:n,internal:r,from:o}=tr(e,t),{proxyState:s,extra:a,renderInfo:c}=Bn(e,n);return[Se(a,s,o),r.setState,c]}function ul(e,t){const{loadingProxy:n}=tr(e,{target:t,from:Fs});return n}function ll(e,t){return ws(e,{target:t,from:Fs})}function fl(e,t){const{loadingProxy:n}=tr(e,{target:t,from:Cs});return n}function dl(e,t){return ws(e,{target:t,from:Cs})}function Os(e){return e.hookImpl.useForceUpdate()}function Ps(e,t){const n=(r,o)=>{let s=null;if(O(r)){const a=on(o),c=r(a);s=sn(a),j(c)&&Object.assign(s,c)}else j(r)&&(s=F(F({},o),r));return s};return e.hookImpl.useObjectLogic(t,n,!0)}function pl(e,t,n){e.react.useEffect(()=>{const r=Ya();return r.on(t,n),()=>r.off(t,n)},[])}function xs(e,t,n={}){const r=Ue(t),{insCtx:o}=Mt(e,t,Y(F({},n),{forAtom:r,isReactive:!0}));return[o.proxyStateVal,o.proxyState,o.renderInfo]}function yl(e,t,n){const r=j(n)?n:{};e.react.useEffect(()=>{const{srvRef:o}=r;O(o)&&o(t)},[])}function hl(e,t,n){const r=e.hookImpl.useStable(t);return yl(e,r,n),r}function ml(e){return t=>e.current=t}var{HOOK:ks}=ne;function Ls(e,t){e(()=>{var n,r;return t.mountStatus=ht,Io(t),(r=(n=t.extra).deferedWatch)==null||r.call(n),()=>{Gn(t)}},[t])}function gl(e,t,n){const{useState:r,useEffect:o}=e.react,[s]=r(()=>It());if(s.fn===w){const{manualDepKeys:a=[]}=n;Pt(t,{scopeType:ks,fnCtxBase:s,deps:()=>a.map(i=>{const{sharedKey:u,keyPath:f}=Ao(i),l=ei(u);return le(l,f)}),isSimpleWatch:!0})}Ls(o,s)}function El(e,t,n){const{useRef:r,useState:o,useMemo:s,useEffect:a}=e.react,c=r({fn:t,wrap:null}),[i]=o(()=>It());if(c.current.fn=s(()=>t,[t]),!c.current.wrap){const{deps:u,immediate:f}=is(n);c.current.wrap=l=>{i.mountStatus===ht?c.current.fn(l):i.extra.deferedWatch=()=>c.current.fn(l)},Pt(c.current.wrap,{scopeType:ks,fnCtxBase:i,deps:u,immediate:f,label:"useWatch"})}Ls(a,i)}function vl(e){const{internal:t,setFactoryOpts:n}=e,{rawState:r,forAtom:o,stopDepth:s,sharedKey:a}=t,c=yn(n),i=F({},r),u=(y,E,p,g)=>{const v=He(E,p,{parentType:To(y),parentKeyPath:g});ts(v,{internal:t,mutateCtx:c}),pr(i,v.fullKeyPath,p)},f=(y,E,p)=>Be(y,{set:(g,v,_)=>(u(g,v,_,p),!0),get:(g,v)=>{const _=g[v];if(dt.includes(v))return Tt(E===1,o,a,v,_);const K=He(v,_,{isChanged:!1,parentKeyPath:p,op:"get",parentType:To(g)});return E<s&&Ee(_)?f(_,E+1,K.fullKeyPath):le(i,K.fullKeyPath)}}),l=f(i,1,[]);_t.set(l,o),Rn.set(c);const d=o?l.val:l;return{draftRoot:l,draftNode:d,finishMutate(y,E={}){ss(c,E);const p=F({state:{},mutateCtx:c},e);os(p,l,d,y)}}}function Sl(e){let t=e;if(e){e.persist&&e.persist();const{currentTarget:n}=e;n&&e.type?n.tagName==="INPUT"&&n.type==="checkbox"?t=n.checked:t=n.value:e.nativeEvent&&e.target&&(t=e.target.value)}return t}function _l(e){let t=[];return{target:Di(e,({fullKeyPath:r})=>{t=r}),getPath:()=>t}}function Ns(e,t,n){return o=>{let s=Sl(o);e(a=>{const{isAtom:c,draftRoot:i}=_t.current(),u={draft:a,draftRoot:i,path:t,isAtom:c,UNDEFINED:va},f=n==null?void 0:n(s,u);pr(i,t,f!==void 0?f:s)},{from:H.SYNC})}}function nr(e,t){const{sharedKey:n,innerSetState:r}=t;let o=$(e,n),s=Vs.get(o);return s||(s=Ns(r,e),Vs.set(o,s)),s}var Vs=new Map;function Us(e){const{forAtom:t,rawState:n}=e;return t?lr(n.val)?Be(n.val,{get:(r,o)=>nr(["val",o],e)}):nr(["val"],e):Be(n,{get:(r,o)=>nr([o],e)})}var Bs=new Map;function Ys(e){const{forAtom:t,sharedKey:n,innerSetState:r,rawState:o}=e,s=_l(o);return(a,c)=>{let i=[];if(Array.isArray(a))i=t?["val",...a]:a;else{const{target:l,getPath:d}=s;a(t?l.val:l),i=d()}let u=$(i,n);c&&(u+=`${c.toString()}`);let f=Bs.get(u);return f||(f=Ns(r,i,c),Bs.set(u,f)),f}}function Al(e,t){const{deep:n,forAtom:r,sharedKey:o}=t,s=Lu(t),a=Gt(n),c=(g={})=>{const v={internal:p,setFactoryOpts:g},{finishMutate:_,draftRoot:K,draftNode:M}=a?wu(v):vl(v);return{finish:(b,A={})=>{const R=p.snap;if(b===R)return R;const T=Ti(r,b,M);return _(T,A),p.snap},draftRoot:K,draftNode:M}},i=(g={})=>c(g),u=(g,v={})=>c().finish(g,v),f=(g,v)=>{const[_,K,M]=v;return Nn(e,je.current(o)),c({handleCbReturn:_,enableDep:K}).finish(g,Pu(M))},p=lo(t,{sharedState:e,setState:(g,v)=>f(g,[!0,!0,v]),setDraft:(g,v)=>f(g,[!1,!0,v]),insSetState:(g,v)=>f(g,[!0,!1,v]),insSetDraft:(g,v)=>f(g,[!1,!1,v]),setStateFactory:i,innerSetState:u,ruleConf:s,isDeep:a});return p.sync=Ys(p),p.syncer=Us(p),za(e,p),p}function Dl(e,t){const n=ku(e,t),{sharedRoot:r,sharedState:o}=wi(n),s=Al(r,n);ti(r,n),Ei(),zn({target:r,dict:n.mutateFnDict});const{draft:a,draftRoot:c}=Vn(s,{isTop:!0});return s.reactive=a,s.reactiveRoot=c,Xa(n.moduleName,s.loc),mu(s.usefulName),Ba(s),{sharedRoot:r,sharedState:o,internal:s,parsedOptions:n}}var{USER_STATE:Gs}=q,{MUTATE:Kl,ACTION:Hs}=H;function rr(e,t){Gs===(t||Gs)&&!kn()&&(Oi(e,ce),du(e,ce))}function $s(e,t){const{createFn:n,ldAction:r,actionDict:o,actionCreator:s,internal:a,apiCtx:c,forTp:i=!1}=e;bt(n,{internal:a,from:Hs,apiCtx:c});const u={},f={};return Object.keys(o).forEach(l=>{const d=o[l],y=i?d.__task:d,E=s(!1)(y,l,t);E.__fnName=l,f[l]=E;const p=(...g)=>{const v=E(...g);return Yu(y)?Promise.resolve(v).then(_=>_.result):v.result};p.__fnName=l,u[l]=p}),{actions:u,eActions:f,getLoading:()=>r.getLoading(u),useLoading:()=>r.useLoading(u)[0],useLoadingInfo:()=>r.useLoading(u)}}function js(e){const{state:t,ldMutate:n,mutateFnDict:r}=e,o=qn(t)(r);return{witnessDict:o,getLoading:()=>n.getLoading(o),useLoading:()=>n.useLoading(o)[0],useLoadingInfo:()=>n.useLoading(o)}}function Tl(e){const{apiCtx:t,ldMutate:n,inital:r,mutateFnDict:o}=e,[s,,a]=or(t,r),c=js({state:s,ldMutate:n,mutateFnDict:o});return F({derivedState:s,useDerivedState:u=>{const[f,,l]=a.useState(u);return[f,l]}},c)}function Rl(e){const{apiCtx:t,deriveFnDict:n,throwErr:r}=e,o={},s={};return Object.keys(n).forEach(c=>{const i=Es(n[c]);o[c]=i,s[c]={runDerive:u=>Tu(i,u!=null?u:r),runDeriveTask:u=>Ru(i,u!=null?u:r),useDerived:u=>er(t,i,u)[0],useDerivedInfo:u=>er(t,i,u)}}),{result:new Proxy(o,{get:(c,i)=>o[i].val}),helper:s}}function Ml(e,t){if(t.enableMutate=e,e){const{mutateFnDict:n}=t,r={};Object.keys(n).forEach(o=>{const s=n[o];s.enabled||(s.enabled=!0,r[o]=s)}),qn(t.sharedState)(r)}}function bl(e){const{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:a,checkDeadCycle:c,enableMutate:i}=e;return{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:a,checkDeadCycle:c,enableMutate:i}}function ce(e,t){const{stateType:n,apiCtx:r}=e;rr(r,n);const{sharedRoot:o,sharedState:s,internal:a}=Dl(e,t),{syncer:c,sync:i,forAtom:u,setState:f,setDraft:l,sharedKey:d,sharedKeyStr:y,rootValKey:E,reactive:p,reactiveRoot:g}=a,v=ys(o),_=v(),K={internal:a,from:Kl,apiCtx:r},M=ce,b=zo(M,Y(F({},K),{from:Hs})),A=zo(M,K),R={createFn:M,internal:a,apiCtx:r},T=Y(F({},R),{ldAction:b,actionCreator:v});return{state:o,stateVal:s,setState:f,setDraft:l,setEnableMutate:h=>Ml(h,a),getOptions:()=>bl(a),setOnReadHook:h=>a.onRead=h,defineActions:h=>D=>$s(Y(F({},T),{actionDict:D}),h),defineTpActions:h=>D=>$s(Y(F({},T),{actionDict:D,forTp:!0}),h),defineMutateDerive:h=>D=>Tl(Y(F({},R),{ldMutate:A,inital:h,mutateFnDict:D})),defineMutateSelf:()=>h=>js({ldMutate:A,state:o,mutateFnDict:h}),defineFullDerive:h=>D=>Rl({apiCtx:r,deriveFnDict:D,throwErr:h}),mutate:Ds(o),runMutate:h=>_s(o,h),runMutateTask:h=>As(o,h),action:v,call:(h,D,S,m)=>_(h,S,m)(D),useState:h=>Ks(r,o,h),useStateX:h=>Ts(r,o,h),useForceUpdate:h=>Is(r,o,h),useLocalState:h=>Ps(r,h),useLocalForceUpdate:()=>Os(r),getMutateLoading:A.getLoading,useMutateLoading:A.useLoading,getActionLoading:b.getLoading,useActionLoading:b.useLoading,sync:i,syncer:c,sharedKey:d,sharedKeyStr:y,rootValKey:E,reactive:p,reactiveRoot:g,reactiveDesc:h=>xo(o,h),useReactive:h=>xs(r,o,h),flush:h=>Nn(o,h),isAtom:u}}function or(e,t,n){const r=ce({apiCtx:e,rawState:t},n);return[r.state,r.setState,r]}function Il(e,t,n){return ce({apiCtx:e,rawState:t},n)}function Cl(e,t,n){const r=ce({apiCtx:e,rawState:t,forAtom:!0},n);return[r.state,r.setState,r]}function Fl(e,t,n){return ce({apiCtx:e,rawState:t,forAtom:!0},n)}function Ws(e,t){const{label:n,isSyncer:r}=t,o=ve(e,{label:n});return(r?Us:Ys)(o)}function wl(e){return Ws(e,{label:"sync"})}function Ol(e){return Ws(e,{label:"syncer",isSyncer:!0})}var Pl=100,xl=5e3;function kl(e,t){return{key:e,results:[],depKeys:[],enableStatus:t,collected:!1,mounted:!1,renderAtomOnce:!1,time:0,status:{loading:!1,err:null,ok:!0}}}function Ll(e,t=!1){const n=Q();e&&(n.initCount+=1);const r=si(),o=kl(r,t);return Fo(e).set(r,o),o}function Nl(e){const t=Q();e.mounted=!0,e.time=Date.now(),t.mountedCount+=1}function Vl(e,t){const n=Q(),r=Fo(t);if(r.delete(e),t&&r.size===Pl&&n.initCount-n.mountedCount>2){n.initCount=0,n.mountedCount=0;const o=Date.now();r.forEach((s,a)=>{!s.mounted&&o-s.time>xl&&r.delete(a)})}}function Ul(e,t){const n=Q();n.runningKey=e.key,n.isDynamic=t}function Bl(e){const t=Q();t.runningKey="",t.isDynamic=!1,e.collected=!0}function Yl(e,t,n){gl(e,n,{manualDepKeys:t.depKeys})}function Xs(e,t,n){let r={loading:!1,err:null,ok:!0};return Yl(e,t,n),t.results.forEach(o=>{const s=Qn(e,{result:o,forAtom:he(o),showLoading:t.enableStatus});s.status.ok||(r=s.status)}),r}function zs(e,t,n){e.react.useEffect(()=>(t.mounted||Nl(t),()=>{Vl(t.key,n)}),[t])}var Fe=()=>!0,Gl=e=>e;function Hl(e){const t=[];for(let n=1;n<=e.length;n++)t.push(e.slice(0,n));return t}function sr(e,t,n,r,o){const s=t;return s.displayName=n,r?e.react.memo(s,o):s}function Js(e,t){const{sharedState:n,depKey:r,keyPath:o,compare:s,sharedKey:a,format:c=Gl}=t;return sr(e,function(){const u=Bn(e,n,{arrDep:!0});u.isFirstRender&&(o.length>=2?Hl(o).forEach(d=>{u.recordDep({sharedKey:a,depKey:$(d,a),keyPath:d,parentKeyPath:d.slice(0,d.length-1)},gt)}):u.recordDep({sharedKey:a,depKey:r,keyPath:o}));const f=le(u.internal.rawState,o);return c(f)},"HeluxSignal",!0,s)}function cr(e,t,n){return sr(e,function(){return Qn(e,{result:t,forAtom:!0}).proxyResult.val},"HeluxDerivedAtomSignal",!0,n)}function $l(e,t,n,r){return sr(e,function(){return Qn(e,{result:t,forAtom:!1}),le(t,n)},"HeluxDerivedSignal",!0,r)}function Zs(e,t){const{isDynamic:n,cb:r,props:o,ref:s}=t,{collected:a,status:c}=e;a||Ul(e,n);const u=r(o,{props:o,status:c,read:dc,ref:s})||"";return a||Bl(e),u}function qs(e,t,n){const r=he(n);if(t.renderAtomOnce&&!r)throw new Error("block cb once returned derived atom but not keep to return it in new render period!");if(r){t.renderAtomOnce=!0;const o=cr(e,n);return e.react.createElement(o,{status:{loading:!1,err:null,ok:!0}})}return zr(n)}function Qs(e,t,n,r){const{memo:o=!0,compare:s}=r||{},{key:a}=t,{react:c}=e,i=c.forwardRef||w,u=n();let f=i(u);ie()&&(u.displayName="HeluxKeyedBlockForHMR",f=i((d,y)=>(y&&gc(y,"current")&&(t.ref=y),c.createElement(u,Y(F({},d),{key:a})))));const l=o?c.memo(f,s):f;return l.displayName="HeluxBlock",l[un]=!0,l}function jl(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,{useForceUpdate:a}=o.hookImpl,c=r?zs:w;return Qs(o,s,()=>(i,u)=>{const f=s.ref||u,l=Zs(s,{isDynamic:r,cb:n,props:i,ref:f}),d=a();return Xs(o,s,d),c(o,s,r),qs(o,s,l)},t)}function Wl(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,a=r?zs:w,{useForceUpdate:c}=o.hookImpl,{useEffect:i}=o.react;return Qs(o,s,()=>(u,f)=>{const l=s.ref||f,d=Zs(s,{isDynamic:r,cb:n,props:u,ref:l}),y=c(),E=Xs(o,s,y);a(o,s,r);const p=s.status.loading,g=E.loading;return i(()=>{p!==g&&y()},[p,g]),s.status=E,qs(o,s,d)},t)}function ec(e,t){const n=Vu(t),{enableStatus:r}=n,o=Y(F({},e),{blockCtx:Ll(e.isDynamic,r)});return r?Wl(o,n):jl(o,n)}function Xl(e,t,n){return ec({apiCtx:e,isDynamic:!1,cb:t},n)}function tc(e,t,n){return ec({apiCtx:e,isDynamic:!0,cb:t},n)}function nc(e,t,n){const{react:r}=e;if(t&&t[un])return r.createElement(t);if(O(t)){const l=tc(e,t,{compare:Fe});return r.createElement(l)}if(he(t)){const l=cr(e,t,Fe);return r.createElement(l)}if(Ue(t)){const l=oe(t),d=Yt("val",l),E=Js(e,{sharedKey:l,sharedState:t,depKey:d,keyPath:["val"],compare:Fe});return r.createElement(E)}const o=Fi(),{sharedKey:s,val:a,stateOrResult:c,depKey:i,keyPath:u,isDerivedResult:f}=o;if(t===a&&c){if(o.isDerivedAtom){const d=cr(e,c,Fe);return r.createElement(d)}if(f){const d=$l(e,c,u,Fe);return r.createElement(d)}const l=Js(e,{sharedKey:s,sharedState:c,depKey:i,keyPath:u,compare:Fe,format:n});return r.createElement(l)}return t}var{shallowCompare:zl,isDiff:Jl}=kr,Zl=or,ql=nc;function rc(e,t,n){return t(e,n)}function Ql(e,t){return rc(e,t)}function ef(e,t){return{build:n=>rc(e,t,n)}}var tf=["atom","atomx","share","sharex","getMutateLoading","getActionLoading","$","signal","block","blockStatus","dynamicBlock","dynamicBlockStatus"];function nf(e){return e.startsWith("use")||tf.includes(e)}function rf(e){return Object.assign({useSyncExternalStore:w},e)}function of(e,t){const n=Rc(e),r=F({},n),o={react:rf(e),hookImpl:n,act:t};t&&(n.useForceUpdate=()=>{const[,c]=e.useState({});return()=>t(()=>c({}))});const s=Ur;return Object.keys(s).forEach(c=>{const i=s[c];nf(c)?r[c]=i.bind(null,o):r[c]=i}),Object.assign({model:c=>Ql(r,c),modelFactory:c=>ef(r,c)},r)}function sf(e){const{inited:t,API:n}=Oa();if(t)return n;const{heluxCtxKey:r,standalone:o,transfer:s,reactLib:a,act:c}=e,i=Z[r],u=(f,l)=>{const d=l||Zr(),y=of(a,c);return to({ROOT:d,inited:!0,api:y}),Z[f]=d,y};if(!i)return u(r);if(o)return u(`${String(r)}_${Date.now()}`);if(s){const f=Zr();to({ROOT:f,inited:!0}),s(i,f)}return u(r,i)}var cf=P(70079),af=P.t(cf,2),oc=sf({heluxCtxKey:"__HELUX__",reactLib:af}),uf=oc.share,{atom:lf,atomx:ff,share:df,sharex:pf,derive:yf,deriveDict:hf,defineDeriveTask:mf,defineDeriveFnItem:gf,runDerive:Ef,runDeriveTask:vf,watch:Sf,useAtom:_f,useAtomX:Af,useReactive:Df,useDerived:Kf,useWatch:Tf,useGlobalId:Rf,useService:Mf,useOnEvent:bf,useMutable:If,useMutateLoading:Cf,useActionLoading:Ff,useEffect:wf,useLayoutEffect:Of,useStable:Pf,useObject:xf,useLocalForceUpdate:kf,useGlobalForceUpdate:Lf,action:Nf,signal:Vf,block:Uf,dynamicBlock:Bf,$:Yf,mutate:Gf,mutateDict:Hf,runMutate:$f,runMutateTask:jf,sync:Wf,syncer:Xf,model:zf,modelFactory:Jf,emit:Zf,on:qf,init:Qf,reactiveDesc:ed,flush:td,isAtom:nd,isDerivedAtom:rd,storeSrv:od,shallowCompare:sd,isDiff:cd,produce:ad,getMutateLoading:id,getActionLoading:ud,getDeriveLoading:ld,getRawState:fd,getSnap:dd,getAtom:pd,addMiddleware:yd,addPlugin:hd,EVENT_NAME:md,RECORD_LOADING:gd,VER:Ed,LIMU_VER:vd}=oc}}]);
}());