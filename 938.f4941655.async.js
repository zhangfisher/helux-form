!(function(){"use strict";var jd=Object.defineProperty,$d=Object.defineProperties;var Wd=Object.getOwnPropertyDescriptors;var Vt=Object.getOwnPropertySymbols;var vc=Object.prototype.hasOwnProperty,Sc=Object.prototype.propertyIsEnumerable;var Ec=(V,U,N)=>U in V?jd(V,U,{enumerable:!0,configurable:!0,writable:!0,value:N}):V[U]=N,F=(V,U)=>{for(var N in U||(U={}))vc.call(U,N)&&Ec(V,N,U[N]);if(Vt)for(var N of Vt(U))Sc.call(U,N)&&Ec(V,N,U[N]);return V},G=(V,U)=>$d(V,Wd(U));var Ac=(V,U)=>{var N={};for(var w in V)vc.call(V,w)&&U.indexOf(w)<0&&(N[w]=V[w]);if(V!=null&&Vt)for(var w of Vt(V))U.indexOf(w)<0&&Sc.call(V,w)&&(N[w]=V[w]);return N};var _c=(V,U,N)=>new Promise((w,Z)=>{var be=W=>{try{we(N.next(W))}catch(Q){Z(Q)}},ct=W=>{try{we(N.throw(W))}catch(Q){Z(Q)}},we=W=>W.done?w(W.value):Promise.resolve(W.value).then(be,ct);we((N=N.apply(V,U)).next())});(self.webpackChunkspeedform_docs=self.webpackChunkspeedform_docs||[]).push([[938],{20938:function(V,U,N){N.r(U),N.d(U,{$:function(){return fd},action:function(){return cd},addMiddleware:function(){return Bd},addPlugin:function(){return Yd},atom:function(){return wl},atomx:function(){return Il},block:function(){return id},createShared:function(){return bl},cst:function(){return Hd},defineDeriveFnItem:function(){return kl},defineDeriveTask:function(){return xl},defineMutateFnItem:function(){return hd},derive:function(){return Ol},deriveDict:function(){return Pl},dynamicBlock:function(){return ud},emit:function(){return Sd},flush:function(){return Kd},getActionLoading:function(){return kd},getAtom:function(){return Ud},getDeriveLoading:function(){return Ld},getMutateLoading:function(){return xd},getRawState:function(){return Nd},getSnap:function(){return Vd},init:function(){return _d},isAtom:function(){return Rd},isDerivedAtom:function(){return Md},isDerivedResult:function(){return bd},isDiff:function(){return Od},isDraft:function(){return wd},isSharedState:function(){return Td},markRaw:function(){return Cd},model:function(){return Ed},modelFactory:function(){return vd},mutate:function(){return ld},mutateDict:function(){return dd},on:function(){return Ad},produce:function(){return Pd},reactiveDesc:function(){return Dd},runDerive:function(){return Ll},runDeriveTask:function(){return Nl},runMutate:function(){return pd},runMutateTask:function(){return yd},shallowCompare:function(){return Fd},share:function(){return Fl},sharex:function(){return Cl},signal:function(){return ad},storeSrv:function(){return Id},sync:function(){return md},syncer:function(){return gd},useActionLoading:function(){return Ql},useAtom:function(){return Bl},useAtomX:function(){return Yl},useDerived:function(){return jl},useEffect:function(){return ed},useGlobalForceUpdate:function(){return sd},useGlobalId:function(){return Xl},useLayoutEffect:function(){return td},useLocalForceUpdate:function(){return od},useMutable:function(){return Zl},useMutateLoading:function(){return ql},useObject:function(){return rd},useOnEvent:function(){return Jl},useReactive:function(){return Hl},useReactiveX:function(){return Gl},useService:function(){return zl},useStable:function(){return nd},useWatch:function(){return $l},useWatchEffect:function(){return Wl},watch:function(){return Vl},watchEffect:function(){return Ul}});function w(e,t){e.includes(t)||e.push(t)}function Z(e,t){const n=e.indexOf(t);n>=0&&e.splice(n,1)}function be(e){return Array.from(new Set(e))}function ct(e,t){let n=!1;for(const r of e)if(t.includes(r)){n=!0;break}return n}function we(e,t){let n="";const r=e.length;for(let o=0;o<r;o++){const s=e[o];if(t.startsWith(s)){n=s;break}}return n}function W(e,t,n){if(!e)return[];const r=e(t,n);return Array.isArray(r)?r:[r]}var Q=function(){if(typeof globalThis!="undefined")return globalThis;if(typeof global!="undefined")return global;if(typeof window!="undefined")return window;if(this!==void 0)return this;throw new Error("no globalThis")}(),dr=!1;function C(...e){}var Dc=C;function Kc(...e){return e}function Ie(...e){return[]}function Xd(...e){}var Rc=Object.prototype.toString,Tc="[object Map]";function zd(){return!(typeof window!="undefined"&&window.document)}function Ut(e){return Rc.call(e)===Tc}function pr(e){return e===Number.MAX_SAFE_INTEGER}function pe(){return!(!dr&&Q.name!=="previewFrame"&&!Q.BrowserFS)}function X(e){return e&&typeof e=="object"&&!Array.isArray(e)}function yr(e){return e&&typeof e=="object"}function P(e){return typeof e=="function"}function Jd(e){return dr?Object.prototype.toString.call(e)==="[object AsyncFunction]":!0}function Bt(e){return typeof e=="symbol"}function Yt(e){if(!e)return!1;const t=typeof e;return(t==="object"||t==="function")&&P(e.then)}function Zd(e){try{return e.test,!1}catch(t){return!0}}function Ne(){return typeof Proxy=="function"}function ye(e,t){var l;const{throwErr:n=!1,prefixLabel:r="",suffixLabel:o=", see details in console.",logErr:s=!0,alertErr:c}=t||{};let a=e,i=!1;if(e instanceof Error&&(i=!0,a=e.message),(c!=null?c:pe())&&e&&((l=Q.alert)==null||l.call(Q,`${r}${a}${o}`)),s&&console.error(e),n)throw i?e:new Error(String(e))}function Fe(e,t=0){t===0?(console.error(e),pe()&&console.trace(e)):t===1?console.error(e):console.warn(e)}function Ve(e){return pr(e)?1:e+1}var Mc=!!Reflect,bc=Object.prototype.hasOwnProperty;function wc(e,t){return Mc?Reflect.has(e,t):bc.call(e,t)}function Ue(e,t,n){let r=e[t];return r||(r=e[t]=n),r}function Be(e,t,n){let r=e.get(t);return r||(e.set(t,n),r=n),r}function hr(e,t){let n="";for(const r in e)if(t.startsWith(r)){n=r;break}return n}function mr(e,t){const n=e.get(t);if(n!==void 0)return n;const r=e.get(Number(t)||t);return r!==void 0?r:void 0}function he(e,t){let n,r=e;return t.forEach(o=>{n=Ut(r)?mr(r,o):r[o],r=n}),n}function gr(e,t,n){let r=e;const o=t.length-1;t.forEach((s,c)=>{const a=Ut(r);if(c===o)return void(a?r.set(s,n):r[s]=n);r=a?mr(r,s):r[s]})}function Ic(){return Fe("changing shared state is invalid"),!0}function qd(e){return e}function Ht(e,t){return`${t}/${e}`}function Gt(e){return e&&Ne()}var Fc=Object.defineProperty,jt={};((e,t)=>{for(var n in t)Fc(e,n,{get:t[n],enumerable:!0})})(jt,{useEffect:()=>xc,useEffectLogic:()=>Wt,useForceUpdate:()=>Er,useLayoutEffect:()=>Pc,useObject:()=>Lc,useObjectLogic:()=>Sr,useStable:()=>vr});var Cc=0,at=new Map,$t=0;function Oc(e,t){const n=()=>{const r=t();return()=>{at.delete(e),r&&r()}};if(function(r){$t||($t=r)}(e),function(r){const o=at.get(r);o?o.count+=1:at.set(r,{count:1})}(e),$t%2!=0)return n();{const r=function(o){return at.get(o)}(e);if(r&&r.count>1)return n()}}function Wt(e,t,n){const{useState:r,useLayoutEffect:o,useEffect:s}=e.react,{isLayout:c,deps:a}=n,[i]=r(()=>++Cc);(c?o:s)(()=>Oc(i,t),a)}function Pc(e,t,n){Wt(e,t,{isLayout:!0,deps:n})}function xc(e,t,n){Wt(e,t,{deps:n})}function Er(e){const[,t]=e.react.useState({});return()=>t({})}function kc(e){const{data:t}=e.current;P(t)?e.current.wrap=(...n)=>e.current.data(...n):X(t)?e.current.wrap=function(n,r){if(!Ne()){const s={};return Object.keys(n).forEach(c=>{const a=n[c];P(a)?s[c]=(...i)=>r.current.data[c](...i):Object.defineProperty(s,c,{get:()=>r.current.data[c],set(i){r.current.data[c]=i}})}),s}const o={};return new Proxy(n,{get(s,c){const a=s[c];return P(a)?Ue(o,c,(...i)=>r.current.data[c](...i)):a}})}(t,e):e.current.wrap=t}function vr(e,t){const{useRef:n,useMemo:r}=e.react,o=n({data:t,wrap:{},inited:!1});return o.current.data=r(()=>t,[t]),o.current.inited||(kc(o),o.current.inited=!0),o.current.wrap}function Sr(e,t,n,r){const{useState:o,useRef:s,useEffect:c}=e.react,[a]=o(t),i=Er(e),l=s({state:null,unmount:!1,shouldCopy:!0}),f=vr(e,{setState(u){const p=l.current;if(p.unmount)return;let d;const{state:E}=p;n?(d=n(u,p.state||a),r&&d?(p.state=d,p.shouldCopy=!1):p.shouldCopy=!0):(d=(P(u)?u(E):u)||{},p.shouldCopy=!0),Object.assign(a,d||{}),i()},getLatestState(){const u=l.current;return u.shouldCopy&&(u.state=F({},a),u.shouldCopy=!1),u.state}});return c(()=>{const u=l.current;return u.unmount=!1,()=>{u.unmount=!0}},[l]),[a,f.setState,f]}function Lc(e,t){return Sr(e,t)}function Nc(e){const t={},n={react:e},r=jt;return Object.keys(jt).forEach(o=>{t[o]=r[o].bind(null,n)}),t}const Qd=3,Vc="3.12.3",it=Symbol("M"),Ar=Symbol("V"),_r=Symbol("IMMUT_BASE"),ut=Symbol("IS_RAW"),z="Map",q="Set",J="Array",Uc="Object",Bc=[Symbol.iterator,Symbol.toStringTag,ut],Yc={Map:z,Set:q,Array:J},Xt="[object Object]",ft="[object Map]",lt="[object Set]",zt="[object Array]",Jt="[object Function]",Hc={[ft]:z,[lt]:q,[zt]:J,[Xt]:Uc},Gc=["push","pop","shift","splice","unshift","reverse","copyWithin","delete","fill"],jc=["set","clear","delete"],$c=["add","clear","delete"],Wc=["splice","sort","unshift","shift"],Xc=["concat","copyWithin","entries","every","fill","filter","find","findIndex","flat","flatMap","forEach","includes","indexOf","join","keys","lastIndexOf","map","pop","push","reduce","reduceRight","reverse","shift","unshift","slice","some","sort","splice","values","valueOf"],zc=["clear","delete","entries","forEach","get","has","keys","set","values"],Jc=["add","clear","delete","entries","forEach","has","keys","values"],Dr={[z]:zc,[q]:Jc,[J]:Xc},Zc={[z]:["clear","set","delete"],[q]:["clear","add","delete"],[J]:["pop","push","shift","unshift","splice","sort","copyWithin"]},qc={[z]:["forEach","get"],[q]:["forEach"],[J]:["forEach","map"]},Ye={value:0,usablePrefix:1},Kr={autoFreeze:!1,fastModeRange:"array"},Qc=Object.prototype.toString,ea=!!Reflect,ta=Object.prototype.hasOwnProperty;function Rr(e,t){return ea?Reflect.has(e,t):ta.call(e,t)}function na(e,t,n,r){const o=(s,c,a)=>{oe(s)||(r(s,c,a),Array.isArray(s)&&s.forEach((i,l)=>{o(i,s,l)}),dt(s)&&s.forEach((i,l)=>{o(i,s,l)}),He(s)&&Object.keys(s).forEach(i=>{o(s[i],s,i)}))};o(e,t,n)}function me(e){return Qc.call(e)}function Ce(...e){return e}function He(e){return me(e)===Xt}function dt(e){return me(e)===ft}function Zt(e){return me(e)===lt}function ge(e){return me(e)===Jt}function Tr(e){var t=me(e);return Hc[t]}function oe(e){const t=me(e);return![Xt,zt,ft,lt,Jt].includes(t)}function Mr(e){return e.constructor.name==="AsyncFunction"||typeof e.then=="function"}function br(e){return typeof Promise!="undefined"&&e instanceof Promise}function qt(e){var t=typeof e;return t==="number"?!0:t==="string"?/^[0-9]*$/.test(e):!1}function ra(e){return typeof e=="symbol"}function oa(e){var t;return e&&(t=e[ut])!==null&&t!==void 0?t:!1}const sa={[zt]:Array.prototype,[ft]:Map.prototype,[lt]:Set.prototype,[Jt]:Function.prototype};function ca(e){const t=me(e),n=sa[t]||Object.prototype,r=Object.create(null);return Object.setPrototypeOf(r,n),Object.setPrototypeOf(e,r),e}const Qt=new Map;function Ge(e){e.rootMeta.modified=!0;const t=n=>{n&&!n.modified&&(n.modified=!0,t(n.parentMeta))};t(e)}function en(e,t,n){if(n.apiCtx.debug){const{fast:r}=n;r?e[it]=t:(ca(e),e.__proto__[it]=t)}return e}function aa(e,t,n){const r=[t],o=se(e,n);if(o&&o.level>0){const{keyPath:s}=o;return[...s,t]}return r}function ia(e,t,n){const{ver:r,parentMeta:o=null,immutBase:s,compareVer:c,apiCtx:a,hasOnOperate:i}=n,l=Tr(t);let f=[],u=0,p=null;o&&(p=o.copy,u=fa(p,a),f=aa(p,e,a));const d={rootMeta:null,parentMeta:o,parent:p,selfType:l,self:t,copy:null,key:e,keyPath:f,level:u,proxyVal:null,proxyItems:null,modified:!1,scopes:[],isImmutBase:s,isDel:!1,isFast:!1,isArrOrderChanged:!1,newNodeStats:{},newNodeMap:new Map,newNodes:[],ver:r,compareVer:c,revoke:Ce,hasOnOperate:i,execOnOperate:Ce};return u===0?d.rootMeta=d:d.rootMeta=o.rootMeta,d}function wr(e){const t=tn(e);return t?!t.isImmutBase:!1}function ua(){Ye.value>=Number.MAX_SAFE_INTEGER?(Ye.value=1,Ye.usablePrefix+=1):Ye.value+=1;const{value:e,usablePrefix:t}=Ye;return`${t}_${e}`}function fa(e,t){const n=Ee(e,t);return n?n.level+1:1}function se(e,t){return t.metaMap.get(e)}function Ee(e,t){let n=t||Fr(e);return(n==null?void 0:n.metaMap.get(e))||null}function Ir(e){return e&&e[Ar]||""}function Fr(e){const t=Ir(e);return Qt.get(t)||null}function tn(e){const t=Fr(e);return t&&t.metaMap.get(e)||null}function Cr(e,t){const n=tn(e),r=tn(t);if(!n&&!r)return!Object.is(e,t);const{self:o,modified:s,compareVer:c,ver:a,level:i}=n||{self:e,modified:!1,compareVer:!1,ver:"0",level:0},{self:l,modified:f,compareVer:u,ver:p,level:d}=r||{self:t,modified:!1,compareVer:!1,ver:"0",level:0};return o!==l||(c||u)&&(i===0||d===0)&&a!==p?!0:s||f}function la(e,t,n=!0){const r=n?Cr:Object.is;return!((c,a)=>{for(let i in c)if(!(i in a))return!0;for(let i in a)if(r(c[i],a[i]))return!0;return!1})(e,t)}function ep(e){const t=n=>{if(isPrimitive(n))return n;let r=n;if(Array.isArray(n)&&(r=n.slice(),r.forEach((o,s)=>{r[s]=t(o)})),isSet(n)){const o=Array.from(n);o.forEach((s,c)=>{o[c]=t(s)}),r=new Set(o)}return isMap(n)&&(r=new Map(n),r.forEach((o,s)=>{r.set(s,t(o))})),isObject(n)&&(r={},Object.keys(n).forEach(o=>{r[o]=t(n[o])})),r};return t(e)}function da(e,t){const{parentType:n,fastModeRange:r}=t;if(Array.isArray(e))return{copy:e.slice(),fast:!1};const o=r==="array"&&n===J||r==="all";let s=e;return e&&He(e)&&(s=Object.assign({},e)),dt(e)&&(s=new Map(e)),Zt(e)&&(s=new Set(e)),{copy:s,fast:o}}function pa(e,t,n){const{apiCtx:r,immutBase:o}=n;if(o)return{copy:e,fast:!1};const{copy:s,fast:c}=da(e,n);return en(s,t,{apiCtx:r,fast:c}),{copy:s,fast:c}}function ya(e,t,n){const{copy:r,isArrOrderChanged:o}=e,{targetNode:s,key:c}=n;if(o){const a=r.findIndex(i=>i===t.copy);a>=0&&(r[a]=s);return}r[c]=s}function ha(e,t){return He(e)?Ir(e)===t:!0}function ma(e,t){const{debug:n}=t,r=new Map;t.newNodeMap.forEach(o=>{const{node:s,parent:c,key:a}=o,i=r.get(s);if(i){c[a]=i;return}const l=o;na(s,c,a,(f,u,p)=>{const d=Ee(f,t);if(d){const{modified:E,copy:m,self:y}=d,v=E?m:y;u[p]=v}}),l.target=c[a],r.set(s,l.target)}),e.scopes.forEach(o=>{const{modified:s,copy:c,parentMeta:a,key:i,self:l,revoke:f,proxyVal:u,isDel:p,isFast:d}=o;if(!c||(n&&(d?delete c[it]:delete c.__proto__[it]),!a))return f();const E=s?c:l,m=a.copy,y=a.selfType;if(y===z)return m.set(i,E),f();if(y===q)return m.delete(u),m.add(E),f();if(y===J)return ya(a,o,{targetNode:E,key:i}),f();if(p!==!0)return m[i]=E,f()}),e.scopes.length=0}function ga(e,t){const{self:n,copy:r,modified:o}=e;let s=n;return r&&o&&(s=e.copy),ma(e,t),s}function Or(e){e.rootMeta.scopes.push(e)}function Pr(e,t,n){const{traps:r,parentType:o,fastModeRange:s,immutBase:c,apiCtx:a}=n,i=ia(e,t,n),{copy:l,fast:f}=pa(t,i,{immutBase:c,parentType:o,fastModeRange:s,apiCtx:a});if(i.copy=l,i.isFast=f,c){const u=new Proxy(l,r);i.proxyVal=u,i.revoke=Ce}else{const u=Proxy.revocable(l,r);i.proxyVal=u.proxy,i.revoke=u.revoke}return a.metaMap.set(l,i),a.metaMap.set(i.proxyVal,i),i}function Ea(e,t){return e===J?!0:(qc[e]||[]).includes(t)}function va(e,t){const{key:n,parentMeta:r,parent:o,parentType:s,fastModeRange:c,readOnly:a,apiCtx:i}=t;let l=e;if(a&&r&&!ge(e)){const{copy:u,self:p}=r,d=p[n];if(l!==d){const E=i.metaMap.get(l);E&&(i.metaMap.delete(l),i.metaMap.delete(E.proxyVal)),u[n]=d,l=d}}const f=(u,p)=>{const d=p||"";if(oe(u)||!u)return u;if(!r)throw new Error("[[ createMeta ]]: meta should not be null");if(!ge(u)){if(r.newNodeStats[d]||u[ut])return u;let m=se(u,i);return m||(m=Pr(d,u,t),Or(m),r.selfType===z?o.set(d,m.copy):o[d]=m.copy),m.proxyVal}if(!Ea(s,d)||r.proxyItems)return u;let E=[];if(s===q){const m=new Set;o.forEach(y=>m.add(f(y))),kr(m,r,{dataType:q,apiCtx:i}),E=en(m,r,{fast:c,apiCtx:i}),r.copy=E}else if(s===z){const m=new Map;o.forEach((y,v)=>m.set(v,f(y,v))),kr(m,r,{dataType:z,apiCtx:i}),E=en(m,r,{fast:c,apiCtx:i}),r.copy=E}else s===J&&d!=="sort"&&(r.copy=r.copy||o.slice(),E=r.proxyVal);return r.proxyItems=E,u};return f(l,n)}function xr(e,t){if(!He(e))return e;const n=se(e,t);return n?n.copy:e}function kr(e,t,n){const{dataType:r,apiCtx:o}=n,s=e.delete.bind(e),c=e.clear.bind(e);if(e.delete=function(...i){return Ge(t),s(...i)},e.clear=function(...i){return Ge(t),c(...i)},r===q){const a=e.add.bind(e);e.add=function(...l){return Ge(t),a(...l)}}if(r===z){const a=e.set.bind(e),i=e.get.bind(e);e.set=function(...f){if(Ge(t),t.hasOnOperate){const u=f[1];t.rootMeta.execOnOperate("set",f[0],{mayProxyVal:u,value:u,parentMeta:t})}return a(...f)},e.get=function(...f){const u=i(...f);if(t.hasOnOperate){const p=Ee(u,o),d=p?p.copy||p.self:u;t.rootMeta.execOnOperate("get",f[0],{mayProxyVal:u,value:d,parentMeta:t,isChanged:!1})}return u}}}function Sa(e){const{calledBy:t,parentMeta:n,op:r,parentType:o}=e;(["deleteProperty","set"].includes(t)||t==="get"&&(o===q&&$c.includes(r)||o===J&&Gc.includes(r)||o===z&&jc.includes(r)))&&Ge(n)}function Lr(e,t){const n=e.keyPath.slice();return n.push(t),n.join("|")}function nn(e,t){const{op:n,key:r,value:o,calledBy:s,parentType:c,parentMeta:a,apiCtx:i}=t,l=xr(o,i);if(!a){e[r]=l;return}const{self:f,copy:u}=a;Sa({calledBy:s,parentMeta:a,op:n,key:r,parentType:c});const p=Dr[c]||[];if(ge(o)&&p.includes(n))return n==="slice"?f.slice:(Wc.includes(n)&&(a.isArrOrderChanged=!0),u?c===q||c===z?u[n].bind(u):u[n]:f[n].bind(f));if(!u)return l;const d=u[r],E=()=>{const y=Ee(d,i);y&&(y.isDel=!0)},m=()=>{const y=Ee(o,i);y&&y.isDel&&(y.isDel=!1,y.key=r,y.keyPath=a.keyPath.concat([r]),y.level=a.level+1,y.parent=a.copy,y.parentMeta=a)};if(s==="deleteProperty"){const y=Ee(o,i);y?y.isDel=!0:E();const v=u[r];oe(v)||i.newNodeMap.delete(Lr(a,r)),delete u[r];return}oe(l)||(a.newNodeStats[r]=!0,i.newNodeMap.set(Lr(a,r),{parent:u,node:l,key:r,target:null})),u[r]=l,E(),m()}function rn(e){if(oe(e))return e;if(Array.isArray(e)&&e.length>0)return e.forEach(rn),Object.freeze(e);if(Zt(e)){const n=e;n.add=()=>n,n.delete=()=>!1,n.clear=Ce;for(const r of n.values())Object.freeze(r);return Object.freeze(e)}if(dt(e)){const n=e;n.set=()=>n,n.delete=()=>!1,n.clear=Ce;for(const r of n.values())Object.freeze(r);return Object.freeze(e)}return Object.getOwnPropertyNames(e).forEach(n=>{const r=e[n];rn(r)}),Object.freeze(e)}const Aa=["length","constructor","asymmetricMatch","nodeType","size"],Nr={};Aa.forEach(e=>Nr[e]=1);const _a={[J]:1,[q]:1,[z]:1},on=new Map;function Vr(e){var t,n,r,o,s;const c=e||{},a=c.onOperate,i=!!a,l=c.customKeys||[],f=c.fastModeRange||Kr.fastModeRange,u=(t=c[_r])!==null&&t!==void 0?t:!1,p=(n=c.readOnly)!==null&&n!==void 0?n:!1,d=c.disableWarn,E=(r=c.compareVer)!==null&&r!==void 0?r:!1,m=(o=c.debug)!==null&&o!==void 0?o:!1,y=(s=c.autoFreeze)!==null&&s!==void 0?s:Kr.autoFreeze,v=ua(),S={metaMap:new Map,newNodeMap:new Map,debug:m,metaVer:v};Qt.set(v,S);const R=()=>(d||console.warn("can not mutate state at readOnly mode!"),!0),T=(b,M,K)=>{const{mayProxyVal:h,parentMeta:g,value:A,isCustom:_=!1}=K;let D=!1;if(!a)return{isChanged:D,mayProxyVal:h};const x=g||{},{selfType:k="",keyPath:st=[],copy:L,self:O,modified:ne,proxyVal:re}=x||{};let Me=!1;K.isChanged!==void 0?D=K.isChanged:(Dr[k]||[]).includes(M)?(Me=!0,D=(Zc[k]||[]).includes(M)):b!=="get"&&(D=g?(ne?L:O)[M]!==A:!0);let de=null,lr=!1;return a({immutBase:u,parent:O,parentType:k,parentProxy:re,op:b,replaceValue:gc=>{lr=!0,de=gc},getReplaced:()=>({isReplaced:lr,replacedValue:de}),isBuiltInFnKey:Me,isChanged:D,isCustom:_,key:M,keyPath:st,fullKeyPath:st.concat(M),value:A,proxyValue:h}),{mayProxyVal:lr?de:h,isChanged:D}},I=(()=>{let b=!0;const M={get:(K,h)=>{if(Ar===h)return v;const g=K[h];if(Bc.includes(h))return ge(g)?g.bind(K):g;if(h==="__proto__"||h==="toJSON"&&!Rr(K,h))return g;let A=g;const _=se(K,S);if(l.includes(h))return T("get",h,{parentMeta:_,mayProxyVal:A,value:g,isChanged:!1,isCustom:!0}).mayProxyVal;const D=_==null?void 0:_.selfType;return _a[D]&&Nr[h]?((h==="length"||h==="size")&&T("get",h,{parentMeta:_,mayProxyVal:A,value:g}),_.copy[h]):(A=va(g,{key:h,compareVer:E,parentMeta:_,parentType:D,ver:v,traps:M,parent:K,fastModeRange:f,immutBase:u,readOnly:p,apiCtx:S,hasOnOperate:i}),D===J&&qt(h)?T("get",h,{parentMeta:_,mayProxyVal:A,value:g}).mayProxyVal:Yc[D]?(A=nn(K,{op:h,key:h,value:g,metaVer:v,calledBy:"get",parentType:D,parentMeta:_,apiCtx:S}),T("get",h,{parentMeta:_,mayProxyVal:A,value:g}).mayProxyVal):T("get",h,{parentMeta:_,mayProxyVal:A,value:g}).mayProxyVal)},set:(K,h,g)=>{let A=g;const _=se(K,S);if(wr(g))if(ha(g,v)){if(A=xr(g,S),A===K[h])return!0}else b=!1;if(p)return T("set",h,{parentMeta:_,isChanged:!1,value:A}),R();if(_&&_.selfType===J){if(_.copy&&_.__callSet&&qt(h))return T("set",h,{parentMeta:_,value:A}),_.copy[h]=A,!0;_.__callSet=!0}let D=!1;return a?D=T("set",h,{parentMeta:_,value:A}).isChanged:D=(_.modified?_.copy:_.self)[h]!==g,D&&nn(K,{parentMeta:_,key:h,value:A,metaVer:v,calledBy:"set",apiCtx:S}),!0},deleteProperty:(K,h)=>{const g=se(K,S),A=K[h];return p?(T("del",h,{parentMeta:g,isChanged:!1,value:A}),R()):(T("del",h,{parentMeta:g,isChanged:!0,value:A}),nn(K,{parentMeta:g,op:"del",key:h,value:"",metaVer:v,calledBy:"deleteProperty",apiCtx:S}),!0)},apply:function(K,h,g){return K.apply(h,g)}};return{createDraft:K=>{if(oe(K))throw new Error("base state can not be primitive");let h=K;const g=se(K,S);if(g){if(u&&g.isImmutBase)return g.proxyVal;h=g.self}const A=Pr("",h,{ver:v,traps:M,immutBase:u,readOnly:p,compareVer:E,apiCtx:S,hasOnOperate:i});return Or(A),A.execOnOperate=T,on.set(A.proxyVal,I.finishDraft),A.proxyVal},finishDraft:K=>{const h=se(K,S);if(!h)throw new Error("rootMeta should not be null!");if(h.level!==0)throw new Error("can not finish sub draft node!");if(h.isImmutBase)return K;let g=ga(h,S);return y&&b&&(g=rn(g)),Qt.delete(v),g}}})();return I}function tp(e){const t=getDraftMeta(e);return t?t.self:e}function np(e){const t=getDraftMeta(e);return t?deepCopy(t.copy||t.self):e}function Da(e){return!e||oe(e)||(e[ut]=!0),e}const Ur={has:Rr,noop:Ce,isObject:He,isMap:dt,isSet:Zt,isFn:ge,isPrimitive:oe,isPromiseFn:Mr,isPromiseResult:br,isSymbol:ra,isMardedRaw:oa,canBeNum:qt,isDraft:wr,isDiff:Cr,shallowCompare:la,getDraftMeta:Ee,getDataType:Tr},Br=Vc;function sn(e,t){return Vr(t).createDraft(e)}function cn(e){const t=on.get(e);if(!t)throw new Error("Not a Limu root draft or draft has been finished!");return on.delete(e),t(e)}function Yr(e){if(!ge(e))throw new Error("produce callback is not a function")}function Ka(e,t){if(Mr(e)||br(t))throw new Error("produce callback can not be a promise function or result")}function Hr(e,t,n){Yr(t);const r=sn(e,n),o=t(r);return Ka(t,o),cn(r)}function Ra(e,t,n){if(!t||!ge(t)){const r=e,o=t;return Yr(e),s=>Hr(s,r,o)}return Hr(e,t,n)}const Ta=Ra,cp=null;function ap(e){return deepCopyFn(e)}function pt(e,t){return Vr(Object.assign(Object.assign({},t||{}),{readOnly:!0,[_r]:!0})).createDraft(e)}function ip(e){conf.autoFreeze=e}function up(){return conf.autoFreeze}const fp=null,Ma=Da,lp=null;var ba=Object.defineProperty,wa=(e,t)=>{for(var n in t)ba(e,n,{get:t[n],enumerable:!0})},Gr={};wa(Gr,{$:()=>gl,action:()=>_s,addMiddleware:()=>Za,addPlugin:()=>ti,atom:()=>Xf,atomx:()=>zf,block:()=>dl,createShared:()=>ml,cst:()=>El,currentDraftRoot:()=>wi,defineDeriveFnItem:()=>yf,defineDeriveTask:()=>pf,defineMutateFnItem:()=>Ef,derive:()=>Ts,deriveDict:()=>df,dynamicBlock:()=>pc,emit:()=>si,flush:()=>Un,getActionLoading:()=>wf,getAtom:()=>eo,getDeriveLoading:()=>Hu,getMutateLoading:()=>Mf,getRawState:()=>di,getSnap:()=>mo,init:()=>Ja,isAtom:()=>xe,isDerivedAtom:()=>ve,isDerivedResult:()=>Ha,isDiff:()=>yl,isDraft:()=>hl,isSharedState:()=>Ya,markRaw:()=>Ma,mutate:()=>Fs,mutateDict:()=>tr,on:()=>ci,produce:()=>Ta,reactiveDesc:()=>Bo,runDerive:()=>Vu,runDeriveTask:()=>Uu,runMutate:()=>ws,runMutateTask:()=>Is,shallowCompare:()=>pl,share:()=>rc,sharex:()=>oc,signal:()=>yc,storeSrv:()=>Pf,sync:()=>Jf,syncer:()=>Zf,useActionLoading:()=>If,useAtom:()=>Cs,useAtomX:()=>Os,useDerived:()=>rr,useGlobalForceUpdate:()=>Ls,useGlobalId:()=>Tf,useLocalForceUpdate:()=>Bs,useMutable:()=>Ys,useMutateLoading:()=>bf,useOnEvent:()=>Ff,useReactive:()=>sr,useReactiveX:()=>Hs,useService:()=>Of,useWatch:()=>kf,useWatchEffect:()=>Lf,watch:()=>nf,watchEffect:()=>rf});var jr="4.2.0",Ia=Br,an={ON_DATA_CHANGED:"ON_DATA_CHANGED",ON_SHARE_CREATED:"ON_SHARE_CREATED",ON_ERROR_OCCURED:"ON_ERROR_OCCURED"},un={NO:"no",PRIVATE:"private",GLOBAL:"global"},$r=0,Wr=Symbol,Fa=typeof Wr=="function";function ce(e){return Fa?Wr(e):($r+=1,`__HELUX_SYMBOL_${$r}__`)}var Ca="__proto__",Oa=Ne(),Pa=ce("HeluxUndefined"),Xr=ce("HeluxMutateFnItem"),yt=ce("HeluxFnKey"),ht=ce("HeluxSharedKey"),zr=ce("HeluxReactiveMeta"),fn=ce("HeluxIsBlock"),Oe=ce("HeluxIsAtom"),je=ce("HeluxIsDerivedAtom"),mt=[ht,Oe,je,fn],gt="SingleMutate",xa="HeluxGlobalLoading",ka=6,La=!0,Jr=2e3,Na=20,$e="1",ln="2",Et=1,vt=2,Zr=3,Pe="|",St={TASK:"task",MAY_TRANSFER:"may_transfer"},ae={STATIC:"static",HOOK:"hook"},ee={USER_STATE:"user_state",GLOGAL_EMPTY:"global_empty",GLOGAL_LOADING:"global_loading",PRIVATE_LOADING:"private_loading"},qr="derive",Qr="watch",At="Object",Va="Map",Ua="Array",Ba="Other",j={SET_STATE:"SetState",MUTATE:"Mutate",ACTION:"Action",REACTIVE:"Reactive",LOADING:"Loading",SYNC:"Sync"};function xe(e){var t;return e&&(t=e[Oe])!=null?t:!1}function Ya(e){return e?e[Oe]!==void 0:!1}function ve(e){return e&&e[je]||!1}function Ha(e){return e?e[je]!==void 0:!1}function eo(e){return xe(e)||ve(e)?e.val:e}function Ga(){return{keySeed:{static:0,hook:0,Reactive:0,Mutate:0},runningFnKey:"",runningSharedKey:0,isIgnore:!1,depKeys:[],delPathAoa:[],GID_INSKEYS_MAP:new Map,FNKEY_STATIC_CTX_MAP:new Map,FNKEY_HOOK_CTX_MAP:new Map,DEPKEY_FNKEYS_MAP:new Map,SKEY_FNKEYS_MAP:new Map,UNMOUNT_INFO_MAP:new Map,DEPKEY_COMPUTING_FNKEYS_MAP:new Map}}function ja(){return{keySeed:0,keyPrefix:0,initCount:0,mountedCount:0,latest:{val:null,stateOrResult:null,sharedKey:0,depKey:"",keyPath:[],isDerivedResult:!1,isDerivedAtom:!1},runningKey:"",isDynamic:!1,KEY_CTX_MAP:new Map,KEY_DYNAMIC_CTX_MAP:new Map}}function $a(){return{keySeed:0,UNMOUNT_INFO_MAP:new Map}}function Wa(){return{keySeed:0,SHARED_KEY_STATE_MAP:new Map,STATE_SHARED_KEY_MAP:new Map,INTERMAL_MAP:new Map,COMPARE_MAP:new Map,isStateChanged:!1}}function to(){const e={};return{on:(t,n)=>{Ue(e,t,[]).push(n)},emit:(t,...n)=>{(e[t]||[]).slice().forEach(o=>o(...n))},off:(t,n)=>{const r=e[t]||[],o=r.findIndex(s=>s===n);o>=0&&r.splice(o,1)},canEmit:t=>e[t]}}function no(){const e={VER:jr,LIMU_VER:Br,rootState:{},setState:(t,n)=>{const r=e.ctx.mod[t];if(!r)throw new Error(`moduleName ${t} not found`);r.setState(n)},ctx:{bus:to(),userBus:to(),mod:{},middlewares:[],plugins:[],sharedScope:Wa(),fnScope:Ga(),insScope:$a(),blockScope:ja(),markAtomMap:new Map,renderSN:0,globalLoading:null,globalLoadingInternal:null,globalEmpty:null,globalEmptyInternal:null,isRootRender:!0},legacyRoot:{}};return e}var _t={},ro=!1,oo=null,so=!1;function H(){return _t.ctx||{}}function Xa(){return _t}function co(e){_t=e.ROOT,oo=e.api,ro=e.inited}function za(){return{ROOT:_t,inited:ro,API:oo}}function Ja(e){if(so)return!1;so=!0;const{isRootRender:t=!0}=e;return H().isRootRender=t,!0}function Za(e){const{middlewares:t}=H();t.push(e)}function qa(e,t,n,r){const{middlewares:o}=H();if(!o.length)return;const s={},{sharedKey:c,moduleName:a,forAtom:i}=e,f={forAtom:i,draftRoot:t,draft:n,sharedKey:c,moduleName:a,setData:(u,p)=>s[u]=p,data:s,idx:0,sn:r};o.forEach((u,p)=>{u(G(F({},f),{idx:p}))})}var{ON_DATA_CHANGED:dn,ON_SHARE_CREATED:ao,ON_ERROR_OCCURED:Qa}=an,ei=[ee.GLOGAL_LOADING,ee.PRIVATE_LOADING];function ti(e){const{plugins:t,bus:n}=H();t.push(e);const r={on:(o,s)=>n.on(o,s),onStateChanged:o=>n.on(dn,o)};e.install(r)}function ni(e,t){const{bus:n}=H();if(n.canEmit(dn)){const{from:r,desc:o}=t,{forAtom:s,sharedKey:c,moduleName:a,snap:i,usefulName:l,stateType:f}=e;let u;ei.includes(f)?u=`${l}/setState`:u=`${l}@${r||"Api"}/${o}`,n.emit(dn,{forAtom:s,snap:i,sharedKey:c,moduleName:a,usefulName:l,type:u})}}function ri(e){const{bus:t}=H();if(t.canEmit(ao)){const{forAtom:n,snap:r,sharedKey:o,moduleName:s,usefulName:c}=e,a=`${c}@FactoryApi/createShared`;t.emit(ao,{forAtom:n,snap:r,sharedKey:o,moduleName:s,usefulName:c,type:a})}}function io(e,t,n){const{bus:r}=H();if(!r.canEmit(t))return!1;const{sharedKey:o,moduleName:s}=e;return r.emit(t,{moduleName:s,sharedKey:o,data:n}),!0}function uo(e,t){io(e,Qa,{err:t})||(console.warn("found uncaught error, sugguest add a plugin to handle this error"),console.error(t))}function oi(){const{userBus:e}=H();return e}function si(e,...t){const{userBus:n}=H();n.emit(e,...t)}function ci(e,t){const{userBus:n}=H();return n.on(e,t),()=>n.off(e,t)}function ai(e,t){return e.__proto__=t,e}function ii(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(e,n)||(e[n]=t[n]);return e}var pn=Object.setPrototypeOf||({__proto__:[]}instanceof Array?ai:ii);function ui(e){const t=Object.create(null);return pn(t,F({},Object.prototype)),e&&Object.assign(t,e),t}function fo(e){if(P(e))return;const t=Object.create(null);return pn(t,Object.prototype),pn(e,t),e}function lo(e,t,n){return e[t]=n,!0}function po(e,t){return e[t]}function We(e,t){const{set:n=lo,get:r=po,obj:o={}}=t||{};return Object.keys(e).forEach(s=>{Object.defineProperty(o,s,{enumerable:!0,configurable:!1,set:function(c){return n(e,s,c)},get:function(){return r(e,s)}})}),o}function Se(e,t){const{set:n=lo,get:r=po}=t||{};if(Ne())return new Proxy(e,{set(c,a,i){return n(c,a,i)},get(c,a){return r(c,a)}});const o=ui();return We(o,{obj:o,set:n,get:r})}var Xe=H();function Dt(e){const n=H()[e];return Xe[e]=n,n}function te(){return Xe.blockScope||Dt("blockScope")}function B(){return Xe.fnScope||Dt("fnScope")}function ie(){return Xe.sharedScope||Dt("sharedScope")}function yo(){return Xe.insScope||Dt("insScope")}function ho(){const{INTERMAL_MAP:e}=ie();return e}function fi(e,t){if(!e||!pe()||!t)return;const{INTERMAL_MAP:n,SHARED_KEY_STATE_MAP:r,STATE_SHARED_KEY_MAP:o}=ie();let s=[],c=!1;if(n.forEach(a=>{a.moduleName===e&&a.loc===t&&a.stateType===ee.USER_STATE&&s.push(a.sharedKey)}),s.length>1){const a=s[0],i=n.get(a);n.delete(a),i&&(r.delete(i.sharedKey),o.delete(i.rawState))}return c}function ze(e){return ho().get(e)}function Y(e){const t=ue(e);return ze(t)}function li(e,t){const n=ho(),r=ue(e);n.set(r,t)}function di(e){return Y(e).rawState}function mo(e,t=!0){const n=Y(e);return t?n.prevSnap:n.snap}function ue(e){return e&&(e[ht]||ie().STATE_SHARED_KEY_MAP.get(e))||0}function yn(e){let t={state:{},stateRoot:{},isAtom:!1};if(!e)return t;const n=Y(e);if(n){const{sharedState:r,sharedRoot:o}=n;t={state:r,stateRoot:o,isAtom:n.forAtom}}return t}function pi(e){const t=ie(),{STATE_SHARED_KEY_MAP:n}=t,r=Ve(t.keySeed);return n.set(e,r),t.keySeed=r,r}function yi(e,t){const{SHARED_KEY_STATE_MAP:n,STATE_SHARED_KEY_MAP:r}=ie();n.set(e,t),r.set(t,e)}function hi(e){return ie().SHARED_KEY_STATE_MAP.get(e)}function mi(e,t){const{rootState:n,ctx:r}=Xa(),{moduleName:o,usefulName:s}=t,c=n[s],a=Y(c);if(o&&a&&a.loc!==t.loc){const i=`
loc1:${a.loc} 
loc2:${t.loc}`;return Fe(`only-dev-mode tip: moduleName ${o} duplicate! this does not effect helux but the duplicated module will be ignored by devtool`+i)}n[s]=e,r.mod[s]=Y(e)}var gi={innerSetState:C};function go(e,t){const{rawState:n,forAtom:r}=e,o=new Map,s={},c={},a=[],i=F({},n);let l=i;return r&&(l=n.val),G(F(F({ver:0,sn:0,reactive:n,reactiveRoot:n,sync:C,syncer:C,snap:i,prevSnap:i,rawStateVal:l},e),t),{insCtxMap:o,key2InsKeys:s,id2InsKeys:c,recordId(f,u){if(!f)return;const p=Ue(c,f,[]);w(p,u)},delId(f,u){f&&Z(c[f]||[],u)},recordDep(f,u){const p=Ue(s,f,[]);w(p,u)},delDep(f,u){Z(s[f]||[],u)},mapInsCtx(f,u){o.set(u,f)},delInsCtx(f){o.delete(f)},extra:{},loadingInternal:gi,level1ArrKeys:a})}var Ei={Mutate:"",Reactive:"r",[ae.STATIC]:"s",[ae.HOOK]:"h"};function vi(){const e=yo(),t=Ve(e.keySeed);return e.keySeed=t,t}function Si(){const e=te(),{keySeed:t,keyPrefix:n}=e,r=Ve(t);e.keySeed=r;let o=n;return pr(t)&&(o=Ve(n),e.keyPrefix=o),`${o}_${r}`}function Ai(){const e=H(),t=e.renderSN,n=t===Number.MAX_VALUE?1:t+1;return e.renderSN=n,n}function hn(e){const t=Ei[e],r=B().keySeed,o=Ve(r[e]);return r[e]=o,`${t}${o}`}function _i(){return hn("Reactive")}var{MAY_TRANSFER:Di}=St,{SET_STATE:Ki,REACTIVE:Ri}=j,Ti=()=>({isReplaced:!1,replacedValue:null}),Mi=()=>{},bi=gn({isFake:!0});function Eo(e,t,n=C){const{desc:r="",onRead:o,from:s=Ri,depKeys:c=[],isTop:a=!1,expired:i=!1,insKey:l=0}=t;return{draft:e,finish:n,modified:!1,expired:i,sharedKey:0,moduleName:"",hasFlushTask:!1,nextTickFlush:C,data:[],isTop:a,key:"",fnKey:"",depKeys:c,writeKeys:[],desc:r,onRead:o,from:s,insKey:l}}function mn(e){const{ids:t=[],globalIds:n=[],isReactive:r=!1,from:o=Ki,enableDep:s=!1,handleCbReturn:c=!0,sn:a=Ai(),isFirstCall:i=!1,desc:l="",onRead:f}=e;return{fnKey:"",depKeys:[],forcedDepKeys:[],triggerReasons:[],ids:t,globalIds:n,readKeys:{},writeKeys:{},arrKeyDict:{},writeKeyPathInfo:{},handleCbReturn:c,draftVal:null,from:o,isReactive:r,enableDep:s,sn:a,isFirstCall:i,desc:l,onRead:f}}function Je(e,t,n){const{isChanged:r=!0,parentKeyPath:o=[],op:s="set",parentType:c="Object"}=n,a=o.slice();return a.push(e),{isChanged:r,isCustom:!1,op:s,immutBase:!1,key:e,value:t,proxyValue:t,parentType:c,keyPath:o,fullKeyPath:a,isBuiltInFnKey:!1,replaceValue:C,getReplaced:Ti}}function gn(e){const u=e||{},{desc:t="",fn:n=C,task:r=Mi,depKeys:o=[],writeKeys:s=[],deps:c=Ie,isFake:a=!1,onlyDeps:i=!1}=u,l=Ac(u,["desc","fn","task","depKeys","writeKeys","deps","isFake","onlyDeps"]);return F({fn:n,task:r,deps:c,oriDesc:"",onlyDeps:i,desc:t,depKeys:o,writeKeys:s,checkDeadCycle:void 0,watchKey:"",isFake:a,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}},l)}function vo(){const e={fnKey:"",fn:C,subFnInfo:bi,checkDeadCycle:!0,isFirstLevel:!0,isExpired:!1,task:C,deps:Ie,status:{loading:!1,err:null,ok:!0},stateRoot:{},isStateAtom:!1,forAtom:!1,remainRunCount:0,showLoading:!1,nextLevelFnKeys:[],prevLevelFnKeys:[],mountStatus:Et,depKeys:[],depSharedKeys:[],result:{},fnType:"watch",returnUpstreamResult:!1,scopeType:"static",renderStatus:$e,proxyResult:{},updater:C,createTime:Date.now(),shouldReplaceResult:!1,isAsync:!1,isAsyncTransfer:!1,isSimpleWatch:!1,isRunning:!1,dcErrorInfo:{err:null,tipFn:C},asyncType:Di,subscribe:t=>{t()},extra:{},setLoading:(t,n=null)=>{const r=!t&&!n;e.status={loading:t,err:n,ok:r}},renderInfo:{time:0,insKey:0,sn:0,getDeps:()=>e.depKeys.slice()}};return e}var So={draftRoot:{val:null},isFake:!0,isAtom:!0},Ao=mn({}),Kt=Eo(!0,{expired:!0}),dp=gn(),_o=go({rawState:{},forAtom:!1,usefulName:""},{}),Do=vo(),Rt=So,En=Ao,Ko="",vn=new Map,Sn=new Map,An=new Map,_n=C,Dn=[],Kn="";function wi(){return Rt}var Ze={current:()=>Kn,set:e=>Kn=e,del:()=>Kn=""},Rn={current:()=>_n,set:e=>_n=e,del:()=>_n=C},qe={current:e=>Sn.get(e)||"SetState",set:(e,t)=>Sn.set(e,t),del:e=>Sn.delete(e)},Qe={current:()=>Dn,set:e=>Dn=e,del:()=>Dn=[]},fe={current:()=>An.get(Ko)||Kt,markUsing:e=>Ko=e,set:(e,t)=>An.set(e,t),del:e=>An.delete(e)},Tn={current:e=>vn.get(e),set:(e,t)=>vn.set(e,t),del:e=>vn.delete(e)},Tt={current:()=>Rt,set:(e,t)=>{Object.assign(Rt,{draftRoot:e,isAtom:t,isFake:!1})},del:()=>Rt=So},Mn={current:()=>En,set:e=>En=e,del:()=>En=Ao};function bn(e){const{FNKEY_STATIC_CTX_MAP:t,FNKEY_HOOK_CTX_MAP:n}=B();return e[0]==="s"?t:n}function Ii(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=B();Be(n,e,[]).push(t)}function Fi(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=B(),r=n.get(e);r&&Z(r,t)}function Ci(e){const{DEPKEY_FNKEYS_MAP:t}=B(),{depKeys:n,fnKey:r}=e;n.forEach(o=>{const s=t.get(o)||[];Z(s,r)})}function Ro(e,t){const{FNKEY_STATIC_CTX_MAP:n}=B(),{fnKey:r,prevLevelFnKeys:o}=e;o.forEach(s=>{var a;const c=(a=n.get(s))==null?void 0:a.nextLevelFnKeys;c&&(t?w(c,r):Z(c,r))})}function Oi(){const{FNKEY_HOOK_CTX_MAP:e}=B();pe()&&e.forEach(t=>{t.isExpired=!0})}function To(e,t,n){const r=n||hn(t);return P(e)?e[yt]=r:(fo(e),e.__proto__[yt]=r),r}function Mo(e){return P(e)?e[yt]||"":X(e)&&e.__proto__[yt]||""}function Ae(e){return bn(e).get(e)}function wn(e){return bn(e).get(e)||Do}function et(e){const t=Mo(e);return Ae(t)||null}function tt(){const{runningFnKey:e,depKeys:t,runningSharedKey:n,isIgnore:r,delPathAoa:o}=B();return{fnCtx:e?Ae(e):null,depKeys:t,delPathAoa:o,isIgnore:r,runningSharedKey:n}}function Pi(){return B().runningFnKey}var{USER_STATE:xi}=ee;function ki(e,t=8){let n="";if(pe()&&e)try{throw new Error("loc")}catch(r){const o=r.stack.split(`
`),s=o[1]||"";s.includes("webpack-internal")||s.includes("/node_modules/")?n=o.slice(0,16).join(" -> "):n=o.map(a=>a.substring(0,a.indexOf("(")).trim()).slice(4,t).join(" -> ")}return n}function bo(e){const[t,n]=e.split("/"),r=n.split(Pe);return{sharedKey:Number(t),keyPath:r,depKey:e}}function wo(e){const{sharedKey:t,forAtom:n}=e,r=n?"/val":"",o=n?["val"]:[];return{depKey:`${t}${r}`,keyPath:o,sharedKey:t}}function $(e,t){try{return Ht(e.join(Pe),t)}catch(n){return console.warn("found Symbol key in your path :",e),`${t}`}}function Li(e,t){const{snap:n,prevSnap:r,stateType:o}=e;if(xi!==o)return!0;const{keyPath:s}=bo(t);try{const c=he(n,s),a=he(r,s);return c!==a}catch(c){return!0}}function Ni(e,t){return Ne()?pt(e,{onOperate:t,compareVer:!0}):Se(e,{get(n,r){const o=n[r],s=Je(r,o,{isChanged:!1,parentKeyPath:[]});return t(s),o}})}function Vi(e,t){if(t!==void 0){if(e)return{val:t};if(X(t))return t}}function Ui(e,t,n){const r=P(t)?t(n):t;return Vi(e,r)}function Mt(e,t){let{value:n}=e;if(t){t(e);const{replacedValue:r,isReplaced:o}=e.getReplaced();o&&(n=r)}return n}function Io(e){return[Ua,Va].includes(e)}function Bi(e){return Array.isArray(e)||Ut(e)}var{isObject:_e,getDataType:Fo}=Ur;function In(e,t){return typeof e=="boolean"?e:t}function Co(e,t){if(e===t)return e;const r=t.substring(e.length+1).split(Pe);return`${e}${Pe}${r[0]}`}function Yi(e,t){we(e,t)||w(e,t)}var Fn=new Map;function Oo(e,t){let n=!1;const{depKey:r,keyPath:o,sharedKey:s}=e,{stopDepInfo:c,level1ArrKeys:a,recordCb:i}=t,l=Fn.get(r);if(l)return i(l),!0;const{keys:f,isArrDict:u,depth:p,arrKeyStopDcit:d,stopArrDep:E}=c,m=we(a,r),y=o.length>p;if(y||m){let S="",R=p;return m&&(R=p+1,d[m]===!1||E&&(y?S=$(o.slice(0,R),s):S=Co(m,r))),S||(S=$(o.slice(0,R),s)),m||Fn.set(r,S),i(S),!0}const v=String(s);for(const S of f){if(!r.startsWith(S)||S===v)continue;const R=u[S],T=R?Co(S,r):S;R||Fn.set(r,T),i(T),n=!0;break}return n}function Cn(e,t){const n=te(),{runningKey:r}=n;if(r){const{KEY_DYNAMIC_CTX_MAP:o,KEY_CTX_MAP:s,isDynamic:c}=n,i=(c?o:s).get(r);if(i){const{results:l,depKeys:f}=i;t?w(l,t):e.forEach(u=>w(f,u))}}}function bt(e,t){const n=ie(),{COMPARE_MAP:r}=n;let o=r.get(t);return o!==void 0?o:e.sharedKeyStr===t?n.isStateChanged:(o=Li(e,t),r.set(t,o),o&&(n.isStateChanged=!0),o)}function Po(e,t,n){if(t.includes(n)&&bt(e,n))return!0;let r=!1;for(const o of t)o.startsWith(n)&&bt(e,o)&&(r=!0);return r}function Hi(){const e=ie();e.COMPARE_MAP.clear(),e.isStateChanged=!1}function On(e=!0){const t=B();t.isIgnore=e}function ke(e,t){const{fnCtx:n,depKeys:r,isIgnore:o}=tt(),s=t.specificCtx||n;if(!s){Rn.current()(e);return}const{DEPKEY_FNKEYS_MAP:c,SKEY_FNKEYS_MAP:a}=B(),{belongCtx:i,sharedKey:l}=t;if(l&&w(s.depSharedKeys,l),n&&i){n.isFirstLevel=!1,i.isAsync&&(n.isAsync=!0);const u=i.fnKey;w(s.prevLevelFnKeys,u),w(i.nextLevelFnKeys,n.fnKey)}const{fnKey:f}=s;e.forEach(u=>{if(Ca===u||o)return;n&&w(r,u);const p=Be(c,u,[]);w(p,f);const[d]=u.split("/"),E=Be(a,d,[]);w(E,f)})}function Pn(e){e&&e.depKeys.forEach(t=>ke([t],{specificCtx:e}))}function xo(e){const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=B(),{fnKey:r}=e;t.set(r,e),Ro(e,!0);let o=n.get(r);o?o.c=2:(o={c:1,t:Date.now(),prev:0},n.set(r,o));const{c:s}=o;if(s===2){const c=Ae(r);Pn(c)}}function ko(e){let t="";return e.depSharedKeys.forEach(n=>{var o;const r=((o=ze(n))==null?void 0:o.ver)||0;t+=`${r}_`}),t}function Gi(e,t,n,r=!1){const{DEPKEY_FNKEYS_MAP:o,SKEY_FNKEYS_MAP:s}=B(),a=(r?s:o).get(t)||[],i=[],l=[];return a.forEach(f=>{const u=Ae(f);if(u&&Po(e,u.depKeys,t)){u.isFirstLevel&&i.push(f),u.isAsync&&u.fnType===qr&&l.push(f);const p=n[f];p===void 0?n[f]=1:r||(n[f]=p+1)}}),{firstLevelFnKeys:i,asyncFnKeys:l}}function xn(e){Ci(e),Ro(e)}function ji(){const{FNKEY_HOOK_CTX_MAP:e}=B();if(e.size>=Na){const t=Date.now();e.forEach(n=>{const{mountStatus:r,createTime:o,fnKey:s}=n;[Et,Zr].includes(r)&&t-o>Jr&&(xn(n),e.delete(s))})}}function kn(e,t,n,r,o,s=!1,c=!1){const a=te();a.latest={sharedKey:e,val:t,stateOrResult:n,depKey:r,keyPath:o,isDerivedResult:s,isDerivedAtom:c}}function $i(){return te().latest}function Lo(e){const{KEY_DYNAMIC_CTX_MAP:t,KEY_CTX_MAP:n}=te();return e?t:n}function No(){return Fe("changing shared state is invalid"),!0}function wt(e,t,n,r,o){return r===Oe?e?t:!1:r===ht?n:o}function Ln(e,t,n){e.replaceValue(wt(e.keyPath.length===0,t,n,e.key,e.value))}function Wi(e){let t={};const{rawState:n,sharedKey:r,forAtom:o,onRead:s,isPrimitive:c,stopDepth:a}=e,i=(f,u)=>{const p=$(f,r);ke([p],{sharedKey:r}),Cn([p]),kn(r,u,t,p,f)};if(Oa)t=pt(n,{customKeys:mt,onOperate:f=>{const{isBuiltInFnKey:u,isCustom:p}=f;if(p)return Ln(f,o,r);if(!u){const{fullKeyPath:d}=f,E=Mt(f,s);i(d,E)}},compareVer:!0});else{const f=(u,p,d)=>We(u,{set:No,get:(E,m)=>{const y=E[m];if(mt.includes(m))return wt(p===1,o,r,m,y);const v=Je(m,y,{isChanged:!1,parentKeyPath:d});if(p<a&&_e(y))return f(y,p+1,v.fullKeyPath);const S=Mt(v,s);return i(v.fullKeyPath,S),S}});t=f(n,1,[])}let l=t;return o&&(c?l=n.val:l=Se(n,{set:No,get:(f,u)=>t.val[u]})),yi(r,t),{sharedRoot:t,sharedState:l}}var Vo=null;function Nn(){return Vo}function Xi(e,t){const n=H();let r=n.globalEmpty;if(!r){const{stateRoot:o}=t({apiCtx:e,rawState:{},forGlobal:!0,stateType:ee.GLOGAL_EMPTY}),s=Y(o);n.globalEmpty=o,n.globalEmptyInternal=s}return Vo=r,r}function Vn(e){const{GID_INSKEYS_MAP:t}=B();return Be(t,e,[])}function zi(){return H().globalEmptyInternal}function Uo(e,t){if(!e)return;const n=Vn(e);w(n,t)}function Ji(e,t){if(!e)return;const n=Vn(e);Z(n,t)}var{REACTIVE:Zi}=j,nt=new Map;function qi(e){return!!(e&&!e.expired&&e.modified)}function Qi(e){const{sharedKey:t}=e;e.expired=!0,fe.del(e.key);const n=qe.current(t);return qe.del(t),e.finish(null,{desc:n})}function Bo(e,t){const n=ue(e);return t&&qe.set(n,t),n}function Un(e,t){const n=ue(e);rt(n,t)}function eu(){const e=fe.current();e.isTop&&rt(e.sharedKey,e.desc)}function rt(e,t){const n=nt.get(e);qi(n)&&(t&&qe.set(e,t),Qi(n))}function tu(e){const t=nt.get(e)||Kt;t.expired=!0}function nu(e,t){const n=nt.get(e)||Kt;n.modified=!0,n.nextTickFlush(t)}function ru(e,t){const{from:n=Zi,onRead:r}=t,{finish:o,draftRoot:s}=e.setStateFactory({isReactive:!0,from:n,handleCbReturn:!1,enableDep:!0,onRead:r}),c=Eo(s,t,o);return c.key=_i(),c.sharedKey=e.sharedKey,c.nextTickFlush=a=>{const{expired:i,hasFlushTask:l}=c;i||(c.data=[a]),l||(c.hasFlushTask=!0,Promise.resolve().then(()=>{const[f]=c.data;rt(e.sharedKey,f)}))},c}function Yo(e,t,n){const{sharedKey:r}=e,{insKey:o=0,from:s}=t;let c=nt.get(r)||Kt;c.expired&&(c=ru(e,{isTop:!0,from:s}),nt.set(r,c),fe.set(c.key,c),c.fnKey=Ze.current()),fe.markUsing(c.key),c.onRead=o?t.onRead:void 0,c.insKey=o;const{draft:a}=c;return{val:n?a.val:a,meta:c}}function Bn(e,t){let n={},r={};const{rawState:o,deep:s,forAtom:c,isPrimitive:a,sharedKey:i}=e;if(Gt(s)){const l={[ht]:i,[Oe]:c},f=(p,d,E)=>{const{val:m}=Yo(e,t,p);return m[d]=E,!0},u=(p,d,E)=>{const m=E[d];if(m!==void 0)return m;const{val:y,meta:v}=Yo(e,t,p);return zr===d?v:y[d]};if(n=new Proxy(o,{set:(p,d,E)=>f(!1,d,E),get:(p,d)=>u(!1,d,l)}),r=n,c){const p=G(F({},l),{[Oe]:!1});r=a?o.val:new Proxy(o.val,{set:(d,E,m)=>f(!0,E,m),get:(d,E)=>u(!0,E,p)})}}else n=o,r=o.val;return{draftRoot:n,draft:r}}function ou(e){const{UNMOUNT_INFO_MAP:t}=yo(),{insKey:n,readMap:r,internal:o}=e;o.mapInsCtx(e,n);let s=t.get(n);s?(s.c=2,s.prev=n-1):(s={c:1,t:Date.now(),prev:0},t.set(n,s));const{c}=s;c===2&&Object.keys(r).forEach(a=>{o.recordDep(a,n)})}function Ho(e){const{readMap:t,insKey:n,internal:r}=e;Object.keys(t).forEach(o=>r.delDep(o,n)),r.delInsCtx(n)}function su(e){const{canCollect:t,isFirstRender:n,currentDepKeys:r}=e;if(!t){n&&(e.depKeys=r.slice());return}e.depKeys=r.slice()}function cu(e){const{canCollect:t}=e;t&&(e.readMap={},e.delReadMap={},e.depKeys=e.currentDepKeys.slice(),e.currentDepKeys.length=0)}function Go(e,t,n){if(!e.canCollect)return;const{parentType:r,rawVal:o}=n,s=Bi(o);s&&Yi(e.internal.level1ArrKeys,t.depKey),e.recordDep(t,r,s)}function Yn(e,t){const{depKeys:n,currentDepKeys:r,fixedDepKeys:o}=e;return(t?r:n).concat(o)}function au(e){if(!e)return;const{updater:t,mountStatus:n,createTime:r}=e;if(n===Et){Date.now()-r>Jr?Ho(e):e.needEFUpdate=!0;return}t()}function jo(e){const{internal:t,isReactive:n,insKey:r}=e,{rawState:o,isDeep:s,sharedKey:c,onRead:a,forAtom:i}=t;if(s){const l=f=>{const{isBuiltInFnKey:u,key:p}=f;if(u)return;if(Bt(p))return Ln(f,i,c);const{fullKeyPath:d,keyPath:E,parentType:m}=f,y=Mt(f,a),S={depKey:$(d,c),keyPath:d,parentKeyPath:E,sharedKey:c};Go(e,S,{parentType:m,rawVal:y})};if(n){const{draft:f,draftRoot:u}=Bn(t,{onRead:l,insKey:r});e.proxyState=u,e.proxyStateVal=f}else e.proxyState=pt(o,{onOperate:l,compareVer:!0})}else e.proxyState=Se(o,{set:()=>(Fe("changing shared state is invalid"),!0),get:(l,f)=>{const u=l[f];if(Bt(f))return wt(!0,i,c,f,u);const p=Mt(Je(f,u,{isChanged:!1,parentKeyPath:[]}),a),d=Ht(f,c),E=_e(l)?At:Ba;return Go(e,{depKey:d,keyPath:[f],sharedKey:c},{parentType:E,rawVal:p}),p}})}function iu(e){var K;const{updater:t,sharedState:n,id:r="",globalId:o="",collectType:s="every",deps:c,pure:a=!0,arrDep:i=!0,isReactive:l=!1}=e,f=i&&(K=e.arrIndexDep)!=null?K:!0,u=Y(n);if(!u)throw new Error("ERR_OBJ_NOT_SHARED: input object is not a result returned by share api");const p=vi(),{rawState:d,isDeep:E,ver:m,ruleConf:y,level1ArrKeys:v,forAtom:S,sharedKey:R,sharedKeyStr:T,snap:I}=u,{stopDepInfo:b}=y,M={readMap:{},delReadMap:{},pure:a,depKeys:[],fixedDepKeys:[],currentDepKeys:[],isDeep:E,isReactive:l,insKey:p,internal:u,rawState:d,sharedState:n,sharedKey:R,proxyState:{},proxyStateVal:{},updater:t,mountStatus:Et,renderStatus:$e,needEFUpdate:!1,createTime:Date.now(),rootVal:null,ver:m,id:r,globalId:o,collectType:s,canCollect:s!=="no",isFirstRender:!0,subscribe:h=>{h()},extra:{},getDeps:()=>Yn(M,!0),renderInfo:{isAtom:S,setDraft:u.insSetDraft,time:Date.now(),sn:0,snap:I,insKey:p,getDeps:()=>Yn(M,!0),getPrevDeps:()=>Yn(M,!1)},recordDep:(h,g,A)=>{let _=h.depKey;Oo(h,{stopDepInfo:b,level1ArrKeys:v,recordCb:re=>{_=re}});const{renderStatus:D,fixedDepKeys:x}=M;if(D===ln)return;const{readMap:k,insKey:st,currentDepKeys:L,delReadMap:O}=M;ke([_],{}),Pi()&&(Z(L,_),w(M.fixedDepKeys,_));const ne=()=>{k[_]=1,u.recordDep(_,st),x.includes(_)||w(L,_)};if(!k[_]&&!O[_]){const{parentKeyPath:re}=h;if(a&&g===At&&re){const de=re.length?$(re,R):T;k[de]&&(delete k[de],O[de]=1,Z(L,de))}const Me=Io(g);if(Me){f&&ne();return}(!A||!Me&&i)&&ne()}}};if(o&&Uo(o,p),jo(M),u.mapInsCtx(M,p),u.recordId(r,p),P(c)){const h=S?M.proxyState.val:M.proxyState,g=W(c,h),A=M.getDeps().slice();g.includes(h)&&A.push(u.rootValKey),M.fixedDepKeys=A}return M}function $o(e){const{result:t,forAtom:n}=e;e.proxyResult=Se(t,{set:()=>(Fe("changing derived result is invalid"),!1),get:(r,o)=>je===o?n:($e===e.renderStatus&&Pn(e),t[o])})}function uu(e){const{proxyState:t,internal:n,renderInfo:r,canCollect:o,isReactive:s}=e,{sharedKey:c,sharedKeyStr:a,insSetState:i,forAtom:l}=n;r.snap=n.snap,r.time=Date.now();const f=l?t.val:t;return e.isFirstRender&&(e.rootVal=f,Tn.set(e.rootVal,e)),!l&&o&&e.recordDep({depKey:a,keyPath:[],sharedKey:c},At),[s?t:f,i,r]}function fu(e,t){if(t&&!xe(e))throw new Error("useAtom only accept atom")}function lu(e){const{ver:t,internal:{ver:n}}=e;t!==n&&(e.ver=n,jo(e))}function du(e){e.mountStatus=vt;const{id:t,globalId:n,insKey:r}=e;e.internal.recordId(t,r),Uo(n,r),ou(e)}function pu(e){e.mountStatus=Zr;const{id:t,globalId:n,insKey:r}=e;e.internal.delId(t,r),Ji(n,r),Ho(e)}function yu(e,t){const n=Y(t).sharedKey;return e.internal.sharedKey!==n}function It(e,t,n,r){if(H().isRootRender)try{const o=r||n;e.react.useSyncExternalStore(t,n,o)}catch(o){console.error(o)}}var hu=null;function Wo(e,t,n){const{hookImpl:r,react:o}=e,s=r.useForceUpdate(),c=o.useRef({ctx:hu});let a=c.current.ctx;return(!a||yu(a,t))&&(a=iu(F({updater:s,sharedState:t},n)),c.current.ctx=a),a}function Xo(e,t){e.react.useEffect(()=>(t.isFirstRender=!1,Tn.del(t.rootVal),t.collectType==="first"&&(t.canCollect=!1),t.needEFUpdate&&(t.needEFUpdate=!1,t.updater()),du(t),()=>{pu(t)}),[t])}function mu(e,t,n,r){n.renderStatus=$e,cu(n),It(e,n.subscribe,()=>Y(t).snap),e.react.useEffect(()=>{n.renderStatus=ln,n.isFirstRender=!1,su(n)})}function Hn(e,t,n={}){const r=Wo(e,t,n);return It(e,r.subscribe,()=>Y(t).snap),Xo(e,r),r}function Ft(e,t,n={}){const{forAtom:r}=n;fu(t,r);const o=Wo(e,t,n);return mu(e,t,o,n),Xo(e,o),lu(o),{tuple:uu(o),insCtx:o}}function zo(e,t){const{forAtom:n,label:r,strict:o=!1}=t||{};let s;if(typeof e=="number"?s=ze(e):s=Y(e),!s&&e){const a=e[zr];s=ze(a==null?void 0:a.sharedKey)}let c=r?`[[${r}]] err:`:"err:";if(!s)if(o)ye(`${c} not a valid shared or atom`,{throwErr:!0});else return null;return n!==void 0&&(n&&!s.forAtom&&ye(`${c} expect a shared but recived a atom`,{throwErr:!0}),!n&&s.forAtom&&ye(`${c} expect a atom but recived a shared`,{throwErr:!0})),s}function De(e,t){return zo(e,G(F({},t||{}),{strict:!0}))}var{MUTATE:gu,LOADING:Eu}=j,{GLOGAL_LOADING:vu,PRIVATE_LOADING:Su}=ee,{PRIVATE:Au,GLOBAL:_u}=un,Jo={},Du={},Ku={time:0,sn:0,getDeps:Ie,getPrevDeps:Ie,insKey:0,setDraft:C,isAtom:!1},Ru=[Ke(Jo,Du,gu),C,Ku];function Tu(e,t){const{internal:n,apiCtx:r}=t,{mutateFnDict:o,moduleName:s}=n,c={};Object.keys(o).forEach(l=>{c[l]={loading:!1,err:null,ok:!0}});const a=s?`${s}@Loading`:"";return e({apiCtx:r,rawState:c,isLoading:!0,stateType:Su},{moduleName:a}).state}var Zo=null;function Mu(){return Zo}function qo(){return H().globalLoadingInternal}function bu(e,t){const n=H();let r=n.globalLoading;if(!r){const{stateRoot:o}=t({apiCtx:e,rawState:{},stateType:vu},{moduleName:xa}),s=Y(o);n.globalLoadingInternal=s,n.globalLoading=o}return Zo=r,r}function Gn(e,t){let n=t;return Bt(t)&&(n=t.toString()),`${e}>${n}`}function Qo(e,t,n){if(!t)return;const{loadingInternal:r}=e;r.innerSetState(o=>{o[t]=n},{from:Eu}),n.err&&(io(e,an.ON_ERROR_OCCURED,{err:n.err}),console.error(n.err))}function Ke(e,t,n){let r=e[n];return r||(r=Se(t,{get(o,s){const c=Gn(n,s);return o[c]||{loading:!1,ok:!0,err:null}}}),e[n]=r),r}function ot(e,t){const{internal:n,from:r}=t,{stateType:o,recordLoading:s}=n,c=ee.USER_STATE===o;let a=Ke(Jo,{},r),i={};if(c)if(Au===s)i=n.extra.loadingProxy,i||(i=Tu(e,t),n.extra.loadingProxy=i,n.loadingInternal=Y(i)),a=Ke(n.extra,i,r);else if(_u===s){const l=qo();i=Mu(),n.loadingInternal=l,a=Ke(l.extra,i,r)}else i=Nn();else i=n.sharedState,a=Ke(n.extra,i,r);return{loadingState:a,loadingProxy:i}}function es(e,t){if(!_e(t))return e;const n=Object.keys(t);if(!n.length)return e;const r=t[n[0]];return r.__sharedKey?G(F({},e),{internal:De(r.__sharedKey)}):e}function ts(e,t){const{internal:n,from:r,apiCtx:o}=t,{stateType:s}=n,c=ee.USER_STATE===s;ot(e,t);let a=()=>Ru;return c&&(a=i=>{const l=es(t,i),f=ot(e,l).loadingProxy,{insCtx:{proxyState:u,internal:p,extra:d,renderInfo:E}}=Ft(o,f);return[Ke(d,u,r),p.setState,E]}),{useLoading:a,getLoading:i=>{const l=es(t,i);return ot(e,l).loadingState}}}function Ct(e){const t=vo();return Object.assign(t,e||{})}function Re(){const e=B(),{runningFnKey:t}=e;if(!t)return[];const n=Ae(t);let r=[];if(n){const{depKeys:o,delPathAoa:s,runningSharedKey:c}=e,{depKeys:a}=n,i={};o.forEach(f=>i[f]=1),o.forEach(f=>{const u=hr(i,f);u&&u!==f&&delete i[u]}),Object.keys(i).forEach(f=>w(a,f)),s.forEach(f=>{const u=f.length;for(let p=1;p<=u;p++){const d=$(f.slice(0,p),c);Z(a,d)}}),r=a.slice()}return e.runningFnKey="",e.depKeys=[],e.delPathAoa=[],e.runningSharedKey=0,r}function jn(e,t){const n=B();n.runningFnKey=e,n.runningSharedKey=t,n.isIgnore=!1}function ns(e,t){const{specificProps:n,fnCtxBase:r}=t,{scopeType:o}=n,s=To(e,o),c=F({fn:e,fnKey:s},n),a=r?Object.assign(r,c):Ct(c);return bn(o).set(s,a),a}function $n(e){var o;const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=B(),{fnKey:r}=e;xn(e),e.extra.deferedWatch=null,t.delete(r),((o=n.get(r))==null?void 0:o.c)===2&&n.delete(r),ji()}function rs(e){const{DEPKEY_COMPUTING_FNKEYS_MAP:t}=B(),{prevLevelFnKeys:n,depKeys:r}=e;let o=!1;for(const s of r){const c=t.get(s)||[];if(ct(c,n)){o=!0;break}}return o}function wu(e,t=!0,n=Pe){return e.map(r=>{const[o,s]=r.split("/"),c=s.split(Pe);return`${t?`${ze(Number(o)).usefulName}/`:""}${c.join(n)}`})}var Ot=new Map,Pt={WATCH:"1",MUTATE:"2"},Iu={[Pt.WATCH]:"watch",[Pt.MUTATE]:"mutate fn or task"};function Fu(e=0){return{sn:e,descs:[],errs:[],timer:null,cycle:[]}}function os(e,t,n){const r=new Error(`DEAD_CYCLE: module(${e}) found mutate fn(${n}) in these dead cycle fns [${t.join(",")}]`);return r.cause="DeadCycle",r.data=t,r}function Cu(e){Ot.delete(e)}function Ou(e,t,n,r){const o=Iu[r],{desc:s,task:c,fn:a,isFake:i}=t.subFnInfo,l=s?`(${s})`:"",f=`DEAD_CYCLE: found reactive object in ${o}${l} cb is changing module(${e.usefulName})'s some of these dep keys(${wu(n,!1,".")}), it will cause a infinity loop call!`,u=i?t.fn:c||a;return{err:new Error(`[only-dev-mode alert] ${f}`),tipFn:()=>console.error(` ${f} open the stack to find the below fn: 
`,u)}}function Pu(e,t,n){if(e&&n){const{usefulName:r}=e,o=Be(Ot,r,Fu(t));o.sn!==t&&(o.descs=[],o.errs=[]);const{descs:s}=o;if(s.length>1&&s[0]===n){const c=s.slice();throw o.cycle=c,s.length=0,os(r,c,n)}w(s,n)}}function Wn(e,t){t.tipFn(),ye(t.err,{logErr:!1,throwErr:!1,alertErr:e.alertDeadCycleErr})}function Te(e,t,n){const{depKeys:r,subFnInfo:o}=t;let s=t.depKeys,c=n;r.length>n.length&&(s=n,c=r);let a=!1;if(ct(s,c)){const i=o.desc?Pt.MUTATE:Pt.WATCH,l=Ou(e,t,n,i);Wn(e,l),t.dcErrorInfo=l,a=!0}return a}function xu(e,t){const n=Ot.get(e);return!n||!n.cycle.includes(t)?{isIn:!1,cycle:[]}:{isIn:!0,cycle:n.cycle}}function ku(e,t,n=!0){const r=Ot.get(e);if(!r)return;const{timer:o,errs:s}=r;s.push(t),o&&clearTimeout(o),r.timer=setTimeout(()=>{let c=null;for(const a of s)c?a.data.length>c.data.length&&(c=a):c=a;c&&ye(c,{alertErr:n}),s.length=0},0)}function Xn(e,t=0){const n=Ae(e);n&&(n.showLoading&&(n.setLoading(!0),n.updater()),t&&(n.remainRunCount+=t))}var{MAY_TRANSFER:Lu}=St;function Nu(e,t){const{isFirstCall:n=!1,triggerReasons:r=[],sn:o=0,from:s,internal:c=_o,desc:a,fromFnKey:i}=t;if(e.dcErrorInfo.err){Wn(c,e.dcErrorInfo);return}if(e.fnKey===i){Te(c,e,e.depKeys);return}if(e.isSimpleWatch||!e.checkDeadCycle)return e.fn({isFirstCall:n,triggerReasons:r,sn:o});if(j.MUTATE===s&&Pu(c,o,a),e.isRunning&&Te(c,e,t.depKeys||[]))return;const l=fe.current();if(l.fnKey===e.fnKey&&Te(c,e,l.writeKeys)||(rt(l.sharedKey,l.desc),e.isRunning===!0&&l.isTop&&Te(c,e,l.writeKeys)))return;e.isRunning=!0,Ze.set(e.fnKey);const u=e.fn({isFirstCall:n,triggerReasons:r,sn:o});Ze.del();const p=fe.current();if(!(p.isTop&&p.fnKey===e.fnKey&&Te(c,e,p.writeKeys))&&!(u&&u.task&&p.from===j.MUTATE&&Te(c,e,e.subFnInfo.writeKeys)))return e.isRunning=!1,u}function ss(e,t,n){let r=t.val;return n||(r=t),{input:W(e,{state:r,stateRoot:t,isAtom:n}),state:r,stateRoot:t}}function Le(e,t={}){const{isFirstCall:n=!1,forceFn:r=!1,forceTask:o=!1,throwErr:s=!1,triggerReasons:c=[],watchFnKeys:a=[],skipWatch:i=!1,sn:l=0,err:f,unbox:u=!1,internal:p=_o}=t,d=Ae(e),E=(L=null)=>{if(L&&s)throw L;const O=d||Do;return u?[O.result.val,L]:[O.result,L]};if(!d)return E(new Error(`not a valid watch or derive cb for key ${e}`));if(d.fnType===Qr)return i?w(a,d.fnKey):Nu(d,t);const{isAsync:m,fn:y,task:v,isAsyncTransfer:S,forAtom:R,result:T,depKeys:I}=d;d.remainRunCount>0&&(d.remainRunCount-=1);const b=L=>{const O=R?{val:L}:L;!d.returnUpstreamResult&&O&&Object.assign(d.result,O),d.shouldReplaceResult=!0},M=()=>{d.renderInfo.sn=l,d.updater()},K=L=>{const{data:O,err:ne=null}=L;ne?d.setLoading(!1,ne):(b(O),n?m&&d.status.loading&&!rs(d)&&d.setLoading(!1,ne):d.remainRunCount===0&&d.setLoading(!1,ne)),M();const re={isFirstCall:n,sn:l,triggerReasons:c,err:ne,watchFnKeys:a,skipWatch:i};d.nextLevelFnKeys.forEach(Me=>{Le(Me,re)})},h=R?T:T.val,{deps:g,isStateAtom:A}=d,{input:_,state:D,stateRoot:x}=ss(g,d.stateRoot,A),k={isAtom:d.isStateAtom,state:D,stateRoot:x,isFirstCall:n,prevResult:h,triggerReasons:c,input:_,sn:l};if(!m||r||m&&!v){const L=y(k);return K({data:L}),E()}if(m&&n&&d.nextLevelFnKeys.forEach(L=>Xn(L,0)),S)return K({err:f}),E();if(d.asyncType===Lu){const L=y(k);return K({data:L}),E()}if(v){let L=Dc;return n?(I.forEach(O=>Ii(O,e)),L=()=>I.forEach(O=>Fi(O,e))):o&&d.nextLevelFnKeys.forEach(O=>Xn(O)),Promise.resolve(()=>{const O=v(k);return Yt(O)?O:(ye("ERR_NON_FN: derive task arg should be async function!",{throwErr:s}),null)}).then(O=>O()).then(O=>(L(),K({data:O}),E())).catch(O=>{if(L(),K({err:O}),s)throw O;return uo(p,O),E(O)})}return E(f)}function xt(e,t){const n=et(e);if(!n)throw new Error("[Helux]: not a derived result");return Le(n.fnKey,F({},t||{}))}function Vu(e,t){return xt(e,{forceFn:!0,throwErr:t})}function Uu(e,t){return Promise.resolve(xt(e,{forceTask:!0,throwErr:t}))}function Bu(e,t){return xt(e,{forceFn:!0,throwErr:t,unbox:!0})}function Yu(e,t){return Promise.resolve(xt(e,{forceTask:!0,throwErr:t,unbox:!0}))}function Hu(e){const t=et(e);return t?t.status:{loading:!1,err:null,ok:!0}}function zn(e,t,n){const r=e.get(t);r&&(r.renderInfo.sn=n,au(r))}function Gu(e){const{mutateCtx:t,internal:n}=e,{ids:r,globalIds:o,depKeys:s,triggerReasons:c,isFirstCall:a,from:i,sn:l,desc:f,fnKey:u}=t,{key2InsKeys:p,id2InsKeys:d,insCtxMap:E,rootValKey:m}=n;let y=[],v=[],S=[],R=[];const T={};if(a){const g=Re();Qe.set(g)}const I=(g,A=!1)=>{const{firstLevelFnKeys:_,asyncFnKeys:D}=Gi(n,g,T,A);S=S.concat(_),R=R.concat(D)},b=g=>{if(!bt(n,g))return;const A=p[g]||[],_=[];for(const D of A){if(y.includes(D))continue;const x=E.get(D);if(!x)continue;const k=x.getDeps();if(k[0]===m){bt(n,m)&&_.push(D);continue}Po(n,k,g)&&_.push(D)}y=y.concat(_),I(g)};s.forEach(g=>b(g)),s.includes(m)||b(m),I(m,!0),Hi(),r.forEach(g=>{y=y.concat(d[g]||[])}),o.forEach(g=>{Vn(g).forEach(A=>w(v,A))}),y=be(y),S=be(S),R=be(R),R.forEach(g=>Xn(g,T[g]));const M=[],K={depKeys:s,sn:l,from:i,triggerReasons:c,watchFnKeys:M,skipWatch:!0,internal:n,desc:f,isFirstCall:a,fromFnKey:u};S.forEach(g=>Le(g,K));const h={depKeys:s,sn:l,from:i,triggerReasons:c,internal:n,desc:f,isFirstCall:a,fromFnKey:u};if(M.forEach(g=>Le(g,h)),y.forEach(g=>zn(E,g,l)),v.length){const g=zi().insCtxMap;v.forEach(A=>zn(g,A,l))}}function ju(e){const{state:t,internal:n,mutateCtx:r}=e,{rawState:o,isDeep:s,ver:c,snap:a}=n;s?(n.prevSnap=c===0?F({},a):a,n.snap=t,Object.assign(o,t)):n.snap=F({},o),n.ver+=1,n.sn=r.sn,Gu(e)}var{MUTATE:cs}=j;function as(e,t){const{writeKey:n,ids:r,internal:o,opParams:s}=t,{snap:c}=o,{fullKeyPath:a,value:i}=s;Object.keys(e).forEach(l=>{n.startsWith(l)&&he(c,a)!==i&&e[l].forEach(f=>w(r,f))})}function is(e,t){const{isChanged:n,fullKeyPath:r,keyPath:o,parentType:s,value:c}=e,{internal:a,mutateCtx:i}=t,{arrKeyDict:l,isReactive:f,readKeys:u,from:p}=i,{sharedKey:d}=a,E=Io(s),m=fe.current();if(e.op==="get"){E&&(l[$(o,d)]=1);const D=$(r,d);u[D]=1,i.enableDep&&(m.onRead?m.onRead(e):(tt().fnCtx&&ke([D],{sharedKey:d}),f&&(Cn([D]),kn(d,c,a.sharedState,D,r))));return}if(cs===p){const{delPathAoa:D,fnCtx:x}=tt();x&&D.push(o)}if(!n)return;const{moduleName:y,ruleConf:v,level1ArrKeys:S}=a,{writeKeyPathInfo:R,ids:T,globalIds:I,writeKeys:b}=i,M=$(r,d);if(m.key&&(m.isTop?w(m.writeKeys,M):m.from===cs&&w(wn(m.fnKey).subFnInfo.writeKeys||[],M)),E){const D=$(o,d);R[D]={sharedKey:d,moduleName:y,keyPath:o},b[D]=1}const{hasIds:K,hasGlobalIds:h,stopDepInfo:g}=v;R[M]={sharedKey:d,moduleName:y,keyPath:r};const A=hr(l,M);A&&(b[A]=1),Oo({sharedKey:d,keyPath:r,depKey:M},{stopDepInfo:g,level1ArrKeys:S,recordCb:D=>{b[D]=1}})||(b[M]=1),K&&as(v.idsDict,{ids:T,writeKey:M,internal:a,opParams:e}),h&&as(v.globalIdsDict,{ids:I,writeKey:M,internal:a,opParams:e}),f?nu(d,m.desc):tu(d)}function us(e,t){Object.keys(t).forEach(n=>{e[n]=t[n]})}function kt(e,t){if(!t)return e;On(!0);const n=e.val;return On(!1),n}function fs(e){const{partial:t,forAtom:n,draftRoot:r,draftNode:o}=e;if(!t)return;if(!n){_e(t)&&us(o,t);return}const s=t.val;if(_e(o)){_e(s)?us(o,s):console.warn("dict atom deny to handle a non-dict returned value!");return}r.val=s}function $u(e,t){const{internal:n,mutateCtx:r}=e,o=kt(t,n.forAtom),{from:s,sn:c,desc:a}=r;n.before({from:s,draftRoot:t,draft:o,desc:a,sn:c}),qa(n,t,o,c)}function ls(e,t,n,r){const{mutateCtx:o,internal:s}=e,{writeKeys:c,writeKeyPathInfo:a,handleCbReturn:i}=o,{forAtom:l}=s;i&&fs({partial:r,forAtom:l,draftRoot:t,draftNode:n}),$u(e,t),o.depKeys=Object.keys(c),Tt.del(),Mn.del(),e.state=cn(t),e.state!==s.rawState&&(o.triggerReasons=Object.values(a),ju(e),ni(s,o))}function ds(e,t){const{ids:n,globalIds:r,from:o,desc:s,fnKey:c}=t;n&&n.forEach(a=>w(e.ids,a)),r&&r.forEach(a=>w(e.globalIds,a)),o&&(e.from=o),s&&(e.desc=s),c&&(e.fnKey=c)}function Wu(e){const{internal:t,setFactoryOpts:n}=e,{forAtom:r,rawState:o}=t,s=mn(n),c=sn(o,{customKeys:mt,onOperate:i=>{if(i.isCustom)return Ln(i,r,t.sharedKey);is(i,{internal:t,mutateCtx:s})}});Tt.set(c,r),Mn.set(s);const a=kt(c,r);return r&&(s.readKeys={}),{draftRoot:c,draftNode:a,finishMutate(i,l={}){ds(s,l),ls({state:{},mutateCtx:s,internal:t},c,a,i)}}}function Xu(e){return fo(e),pi(e)}function zu(e){if(!e)return{};const{desc:t,ids:n,globalIds:r}=e;return{desc:t,ids:n,globalIds:r}}function Ju(e){const{forAtom:t=!1}=e;let n=e.rawState;const r=P(n);let o=!1;if(t)n=r?{val:n()}:{val:n},o=!n.val||!yr(n.val);else{if(n=r?n():n,!X(n))throw new Error("ERR_NON_OBJ: pass an non-object to createShared!");if(ue(n))throw new Error("ERR_ALREADY_SHARED: pass a shared object to createShared!")}return{isPrimitive:o,rawState:n}}function ps(e,t,n){let r=null,o=t||"";if(P(e)&&e!==C)r={[Xr]:1,fn:e,deps:Ie,oriDesc:o,onlyDeps:!1,desc:o,depKeys:[],writeKeys:[],checkDeadCycle:void 0,watchKey:"",isFake:!1,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}};else if(X(e)){const{fn:s,desc:c,deps:a,task:i,immediate:l,checkDeadCycle:f,onlyDeps:u=!1}=e,p=t||c||"",d=P(s)?s:void 0,E=P(i)?i:void 0,m=P(a)?a:Ie;(s||i)&&(r={[Xr]:1,checkDeadCycle:f,fn:d,watchKey:"",desc:p,oriDesc:p,deps:m,task:E,onlyDeps:u,immediate:l,depKeys:[],writeKeys:[],isFake:!1,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}})}if(r&&n){const{oriDesc:s}=r;(!s||n[s])&&(r.desc=hn(j.MUTATE))}return r}function ys(e,t,n=!0){const r={},o=t||{};if(!e)return r;const s=(c,a)=>{const i=ps(c,a,o);i&&(i.enabled=n,r[i.desc]=i,o[i.desc]=i)};if(Array.isArray(e))if(e.length===1){const c=e[0],a=(X(c)?c.desc:"")||gt;s(e[0],a)}else e.forEach(c=>s(c));else P(e)?s(e,gt):X(e)&&Object.keys(e).forEach(c=>{s(e[c],c)});return r}function Zu(e,t={}){var K,h,g,A,_;const{forAtom:n=!1,forGlobal:r=!1,stateType:o=ee.USER_STATE}=e,{rawState:s,isPrimitive:c}=Ju(e),a=Xu(s),i=t.moduleName||"",l=(K=t.alertDeadCycleErr)!=null?K:pe(),f=(h=t.deep)!=null?h:!0,u=(g=t.checkDeadCycle)!=null?g:!0,p=(A=t.enableMutate)!=null?A:!0,d=t.recordLoading||un.PRIVATE,E=t.rules||[],m=t.before||C,y=t.mutate||C,v=(_=t.stopArrDep)!=null?_:!0,S=t.stopDepth||ka,R=`${a}`,T=n?`${a}/val`:R,I=i||R,b=ki(i),M=ys(y,{},p);return{isDestroyed:!1,alertDeadCycleErr:l,checkDeadCycle:u,rawState:s,sharedKey:a,sharedKeyStr:R,rootValKey:T,moduleName:i,usefulName:I,forAtom:n,forGlobal:r,loc:b,deep:f,rules:E,before:m,mutate:y,mutateFnDict:M,onRead:null,enableMutate:p,stateType:o,recordLoading:d,stopArrDep:v,stopDepth:S,isPrimitive:c}}function qu(e){const{rawState:t,sharedKey:n,rootValKey:r,deep:o,rules:s,stopDepth:c,stopArrDep:a,forAtom:i}=e,l={},f={},u={keys:[],isArrDict:{},arrKeyStopDcit:{},depth:c,stopArrDep:a},p={},d=Gt(o);s.forEach(y=>{const v=[],{when:S,ids:R=[],globalIds:T=[],stopDep:I}=y;let b;if(d){let A="";b=pt(t,{onOperate:({fullKeyPath:_,value:D,isBuiltInFnKey:x})=>{if(x)return;const k=$(_,n);A&&k.includes(A)&&v.pop(),v.push(k),p[k]=Array.isArray(D),A=k}})}else b=Se(t,{set:Ic,get:(A,_)=>{const D=$([_],n);v.push(D);const x=A[_];return p[D]=Array.isArray(x),x}});const M=i?b.val:b,K=W(S,M),h=(A,_,D)=>{const x=Ue(A,D,[]);_.forEach(k=>w(x,k))},g=A=>{h(l,R,A),h(f,T,A);let _;p[A]?(_=I!=null?I:La,u.arrKeyStopDcit[A]=_,u.isArrDict[A]=p[A]):_=I!=null?I:!1,_&&w(u.keys,A)};v.forEach(g),K.includes(M)&&g(r)});const E=Object.keys(l).length>0,m=Object.keys(f).length>0;return{hasIds:E,idsDict:l,hasGlobalIds:m,globalIdsDict:f,stopDepInfo:u}}function Qu(e){const{desc:t=gt,strict:n=!1,throwErr:r=!1}={};return typeof e=="string"?{desc:e,strict:n,throwErr:r}:G(F({desc:t,strict:n},e),{throwErr:r})}function hs(e,t){var o;let n=C,r=!1;return P(t)?n=t:X(t)&&(n=t.deps||C,r=(o=t.immediate)!=null?o:!1),r=e?!0:r,{immediate:r,deps:n}}function ef(e){return e?typeof e=="boolean"?{enableStatus:e}:X(e)?e:{}:{}}function tf(e){Array.isArray(e)&&e.forEach(t=>{const n=Tn.current(t),r=Y(t)||(n==null?void 0:n.internal);if(r){const{depKey:o,sharedKey:s}=wo(r);ke([o],{sharedKey:s})}n&&n.recordDep(wo(r))})}function ms(e,t,n){const{deps:r,immediate:o}=hs(e,n),s=Lt(t,{scopeType:ae.STATIC,deps:r,immediate:o});return{run:c=>Le(s.fnKey,{throwErr:c}),unwatch:()=>xn(s)}}function Lt(e,t){const{scopeType:n,fnCtxBase:r,immediate:o,deps:s=C,label:c="watch",sharedState:a,isSimpleWatch:i}=t;if(!P(e))throw new Error(`ERR_NON_FN: pass an non-function to ${c}!`);const l=ns(e,{specificProps:{scopeType:n,fnType:Qr,isSimpleWatch:i},fnCtxBase:r});jn(l.fnKey,ue(a));const f=s()||[];return tf(f),o&&e({isFirstCall:!0}),Re(),l}function nf(e,t){return ms(!1,e,t)}function rf(e,t){return ms(!0,e,t)}var gs=()=>{},Jn=new Map;function Es(e,t){const{forAtom:n,rawState:r}=e,{deps:o,extraBound:s}=t;return n?W(o,r.val,s):W(o,r,s)}function of(e){var t;return(t=Jn.get(e))!=null?t:!1}function Zn(e,t){const{sn:n,getArgs:r=C,from:o,throwErr:s,isFirstCall:c,fnItem:a,mergeReturn:i}=t,{desc:l="",depKeys:f,task:u=gs,extraBound:p}=a,d=Y(e),{sharedKey:E}=d,m={desc:l,sn:n,from:o},y=Gn(o,l),{draft:v,draftRoot:S}=Bn(d,{depKeys:f,desc:l,from:o}),R=D=>{rt(E,D)},T=D=>{R(l);const{finish:x}=d.setStateFactory(m);return x(D)},I=j.MUTATE===o?Es(d,a):[],b={isFirstCall:c,desc:l,setState:T,input:I,draft:v,draftRoot:S,flush:R,extraBound:p},M=r(b)||[b],K=Jn.get(u),h=K===void 0,g=(D,x,k)=>{(h||K)&&Qo(d,y,{loading:D,err:x,ok:k})};g(!0,null,!1);const A=D=>{if(Qe.del(),g(!1,D,!1),s)throw D;return{snap:d.snap,err:D,result:null}},_=D=>(i&&D&&T(D),g(!1,null,!0),R(l),{snap:d.snap,err:null,result:D});try{const D=u(...M),x=Yt(D);return Jn.set(u,x),x?Promise.resolve(D).then(_).catch(A):_(D)}catch(D){return A(D)}}function vs(e,t){const{sn:n,getArgs:r=C,from:o,throwErr:s,isFirstCall:c=!1,fnItem:a}=t,{desc:i="",watchKey:l,fn:f=gs,extraBound:u}=a,p=j.MUTATE===o;p&&Ze.set(l);const d=Y(e),{setStateFactory:E,forAtom:m,sharedRoot:y}=d,S={desc:i,sn:n,from:o,isFirstCall:c,enableDep:p&&c},R=g=>{const{finish:A}=E(S);return A(g)},T=kt(y,m),I=p?Es(d,a):[],{draftNode:b,draftRoot:M,finish:K}=E(S),h=r({draft:b,draftRoot:M,setState:R,desc:i,input:I})||[b,{input:I,state:T,draftRoot:M,isFirstCall:c,extraBound:u}];try{const g=wn(a.watchKey);if(g.dcErrorInfo.err)return Wn(d,g.dcErrorInfo),{snap:d.snap,err:null,result:null};const A=f(...h);return K(A,{fnKey:g.fnKey}),Ss(d,a,c),{snap:d.snap,err:null,result:null}}catch(g){if(Ss(d,a,c),s)throw g;return{snap:d.snap,err:g,result:null}}}function Ss(e,t,n){n&&!t.onlyDeps&&(tt().fnCtx?t.depKeys=Re():t.depKeys=Qe.current(),Qe.del());const r=fe.current();r.isTop&&r.fnKey===t.watchKey&&Te(e,wn(t.watchKey),r.writeKeys),Ze.del()}function sf(e,t){var r;eu(),Qe.del(),On(!1);const n=tt().fnCtx;n&&(n.subFnInfo=t,n.checkDeadCycle=(r=t.checkDeadCycle)!=null?r:e.checkDeadCycle,t.watchKey=n.fnKey),t.onlyDeps&&(t.depKeys=Re())}function qn(e){const{target:t,dict:n}=e,r=Object.keys(n);if(!r.length)return;const o=Y(t),{mutateFnDict:s,usefulName:c,forAtom:a,sharedRoot:i}=o,l=f=>uo(o,f);r.forEach(f=>{const u=s[f];Lt(({sn:p,isFirstCall:d})=>{if(d&&sf(o,u),!o.enableMutate)return;const{desc:E,fn:m,task:y,immediate:v}=u,S=xu(c,E);try{if(S.isIn)throw os(c,S.cycle,E);const R={sn:p,throwErr:!0,isFirstCall:d,fnItem:u,from:j.MUTATE};if(m&&(d||!y)&&vs(t,R),y){d&&(u.depKeys=Re());const T=d&&(v!=null?v:!m);(!d||T)&&Zn(t,R).catch(l)}return u}catch(R){R.cause==="DeadCycle"&&ku(c,R,o.alertDeadCycleErr),l(R)}},{deps:()=>u.deps?u.deps(kt(i,a),u.extraBound)||[]:[],sharedState:t,scopeType:ae.STATIC,immediate:!0})})}var{ACTION:As}=j;function cf(e,t){const{label:n,throwErr:r,desc:o="",task:s,mergeReturn:c=!0}=t,a=In(r,!1),i=De(e,{label:n}),{forAtom:l}=i,f=(u,p)=>{const d=In(p,a),E=gn({desc:o,task:s,depKeys:[]}),m=(y,v)=>y.__action?y.__action(v):y(v);return Zn(e,{fnItem:E,from:As,mergeReturn:c,throwErr:d,getArgs:({draft:y,draftRoot:v,setState:S,desc:R,flush:T})=>[{draft:y,draftRoot:v,setState:S,desc:R,payload:u,flush:T,merge:b=>{fs({partial:b,forAtom:l,draftRoot:v,draftNode:y})},dispatch:m}]})};return Qo(i,Gn(As,o),{loading:!1,ok:!0,err:null}),f.__sharedKey=i.sharedKey,f.__fnName=o,f.__task=s,s.__action=f,f}function _s(e){return t=>(n,r="",o)=>cf(e,{task:n,desc:r,label:"action",mergeReturn:t,throwErr:o})}var{TASK:Ds}=St,{STATIC:af,HOOK:uf}=ae;function Ks(e,t,n){if(!n&&(!X(t)||Yt(t)))throw new Error("ERR_NON_OBJ: derive,deriveAsync expect result to be a plain object");const{isAsync:r,isAsyncTransfer:o}=e;if(r&&!o){const s=Mo(t),c=ue(t);if(s&&e.fnKey!==s||c)throw new Error("ERR_INVALID_CALL: derive,deriveAsync can not transfer another derived result or shared state, it will cause wrong result")}}function ff(e,t){const n=Se(e.result,{set:()=>(Fe("changing derived result is invalid"),!1),get:(r,o)=>{if(o===je)return t;const s=r[o];return ke(e.depKeys,{belongCtx:e}),Cn(e.depKeys,n),kn(0,s,n,"",[o],!0,t),s}});return e.proxyResult=n,n}function Rs(e,t){const{result:n,isUpstream:r}=t,o=et(n);o&&(e.depKeys=be(e.depKeys.concat(o.depKeys)),w(o.nextLevelFnKeys,e.fnKey),w(e.prevLevelFnKeys,o.fnKey),e.isFirstLevel=!1,r==null||r())}function lf(e){var K,h;const{scopeType:t=af,fnCtxBase:n,isAsyncTransfer:r=!1,asyncType:o=Ds,returnUpstreamResult:s,runAsync:c=!0,forAtom:a=!1,immediate:i}=e;if(!P(e.fn))throw new Error("ERR_NON_FN: derive need fn arg!");const{fn:l=C,deps:f=C,task:u,stateRoot:p={}}=e,d=xe(p),E=(K=e.isAsync)!=null?K:P(u),m=(h=e.showLoading)!=null?h:E,y=ns(l,{specificProps:{forAtom:a,scopeType:t,stateRoot:p,isStateAtom:d,fnType:qr,task:u,deps:f,isAsync:E,asyncType:o,isAsyncTransfer:r,showLoading:m},fnCtxBase:n});jn(y.fnKey,0);const{input:v,state:S}=ss(f,p,d);v.forEach(g=>Rs(y,{result:g}));let T=l({isFirstCall:!0,prevResult:null,triggerReasons:[],input:v,sn:0,state:S,stateRoot:p,isAtom:d});Re();const I=et(T);a&&!I&&(T={val:T,z__is_atom_result__:!0});const b=y.fnKey;Ks(y,T),Rs(y,{result:T,isUpstream:()=>{y.returnUpstreamResult=s!=null?s:!E}}),Pn(y),y.returnUpstreamResult||To(T,t,b);const M=c&&o===Ds&&(i!=null?i:!e.fn);return u&&M&&Le(b,{isFirstCall:!0,sn:y.renderInfo.sn+1}).then(g=>{Ks(y,g[0],a)}).catch(g=>ye(g)),y.result=T,t===uf&&rs(y)&&y.setLoading(!0),y.returnUpstreamResult?y.proxyResult=T:ff(y,a),y}function Qn(e,t){const n=P(e)?{fn:e}:e||{};return lf(F(F({},t||{}),n))}function Ts(e,t){return Qn(e,{forAtom:!0,stateRoot:t}).proxyResult}function df(e,t){return Qn(e,{stateRoot:t}).proxyResult}function pf(e){return t=>G(F({},t),{deps:e})}function yf(e){return e}var Nt=e=>[e.snap,e.err];function er(e){const{target:t,desc:n="",forTask:r=!1,throwErr:o}=e,{mutateFnDict:s,snap:c}=Y(t),a=n||gt,i=s[a];if(!i)return{snap:c,err:new Error(`mutate fn ${a} not defined`),result:null};if(r&&!i.task)return{snap:c,err:new Error(`mutate task ${a} not defined`),result:null};const l=In(o,!1),f={sn:0,fnItem:i,from:j.MUTATE,throwErr:l};return r?Zn(t,f):vs(t,f)}function Ms(e,t,n,r){return{run:o=>{const s=er({target:e,desc:t,throwErr:o});return Nt(s)},runTask:o=>Promise.resolve(er({target:e,desc:t,forTask:!0,throwErr:o})).then(Nt),desc:t,oriDesc:n,getSnap:()=>r.snap,snap:r.snap,__sharedKey:r.sharedKey}}function hf(e){const{target:t,fnItem:n,label:r,extraTarget:o}=e,s=De(t,{label:r}),c=ps(n,"",s.mutateFnDict);if(!c)throw new Error("not a fn or fnItem { fn }");o&&(c.extraBound=yn(o)),s.mutateFnDict[c.desc]=c,c.enabled=s.enableMutate;const a={[c.desc]:c};return s.enableMutate&&qn({target:t,dict:a}),Ms(t,c.desc,c.oriDesc,s)}function mf(e){const{target:t,fnDict:n,label:r}=e,o=De(t,{label:r}),s=ys(n,o.mutateFnDict,o.enableMutate);if(e.extraTarget){const a=yn(e.extraTarget);Object.keys(s).forEach(i=>s[i].extraBound=a)}o.enableMutate&&qn({target:t,dict:s});const c={};return Object.keys(s).forEach(a=>{c[a]=Ms(t,a,a,o)}),c}function gf(e,t){const{label:n,descOrOptions:r,forTask:o=!1}=t,{desc:s,strict:c,throwErr:a}=Qu(r);return s?zo(e,{label:n,strict:c})?{ok:!0,desc:s,forTask:o,throwErr:a,err:null}:{ok:!1,desc:s,forTask:o,throwErr:a,err:new Error("not a valid atom or shared result")}:{ok:!1,desc:s,forTask:o,throwErr:a,err:new Error("miss desc")}}function bs(e,t){const{ok:n,desc:r,forTask:o,err:s,throwErr:c}=gf(e,t);if(!n){if(c)throw s;return o?Promise.resolve([e,s]):[e,s]}const a=er({target:e,desc:r,forTask:o,throwErr:c});return o?Promise.resolve(a).then(Nt):Nt(a)}function ws(e,t){return bs(e,{descOrOptions:t,label:"runMutate"})}function Is(e,t){return bs(e,{descOrOptions:t,label:"runMutateTask",forTask:!0})}function Fs(e,t){return n=>hf({target:e,extraTarget:t,fnItem:n,label:"mutate"})}function tr(e,t){return n=>mf({target:e,extraTarget:t,fnDict:n,label:"mutateDict"})}function Ef(e){return e}function Cs(e,t,n={}){const{tuple:r}=Ft(e,t,n);return r}function Os(e,t,n={}){const{tuple:r}=Ft(e,t,n),[o,s,c]=r;return G(F({},c),{state:o,setState:s})}var vf="ERR_NOT_DERIVED_RESULT: useDerived only accept derived result",Sf="ERR_NOT_ATOM_RESULT: useDerivedAtom only accept derived atom";function Af(e,t,n){return e.isExpired?(e.isExpired=!1,!0):P(n)?!1:n!==t}function _f(e){$n(e),e.depKeys.length=0,e.prevLevelFnKeys.length=0,e.renderInfo.sn+=1}function Df(e,t){const{result:n,forAtom:r,showLoading:o}=t,{fnCtx:s,input:c,deriveFn:a}=e;let i=!1;if(a)if(Af(s,c,n))i=!0,_f(s);else return;e.input=n;const l=et(n);if(!l)throw new Error(vf);if(r&&!ve(n))throw new Error(Sf);e.deriveFn=()=>l.result,Qn({fn:()=>l.result,deps:()=>[],task:()=>_c(this,null,function*(){return l.result})},{isAsync:l.isAsync,scopeType:ae.HOOK,fnCtxBase:s,isAsyncTransfer:!0,runAsync:!1,returnUpstreamResult:!0,forAtom:r,asyncType:St.MAY_TRANSFER,showLoading:o}),$o(s),i&&s.updater()}function Ps(e,t){const{result:n,forAtom:r}=t,{hookImpl:o,react:s}=e,c=o.useForceUpdate(),{current:a}=s.useRef({input:n,deriveFn:null,fnCtx:null});a.fnCtx||(a.fnCtx=Ct({updater:c,scopeType:ae.HOOK,forAtom:r}));const i=a.fnCtx;return i.renderStatus=$e,Df(a,t),i}function Kf(e,t){t.shouldReplaceResult&&($o(t),t.shouldReplaceResult=!1),It(e,t.subscribe,()=>ko(t)),e.react.useEffect(()=>{t.renderStatus=ln})}function xs(e,t){e.react.useEffect(()=>(t.mountStatus=vt,xo(t),()=>{$n(t)}),[t])}function nr(e,t){const n=Ps(e,t);return It(e,n.subscribe,()=>ko(n)),xs(e,n),n}function Rf(e,t){const n=Ps(e,t);return Kf(e,n),xs(e,n),n}function rr(e,t,n){const r=Rf(e,F({result:t},n||{})),{proxyResult:o,status:s,renderInfo:c}=r;return[ve(t)?o.val:o,s,c]}function ks(e,t,n){if(t===null)return n;if(!P(t))return null;const{sharedState:r,forAtom:o}=e,s=o?r.val:r,c={};Rn.set(i=>c[i[0]]=1);const a=W(t,s);return Rn.del(),a.includes(s)?e.key2InsKeys:c}function Ls(e,t,n){const r=De(t),[o]=e.react.useState(()=>ks(r,n,null));return s=>{const{insCtxMap:c,key2InsKeys:a}=r,i=ks(r,s,a)||o||a,l={};if(Object.keys(i).forEach(u=>{(a[u]||[]).forEach(d=>l[d]=1)}),Object.keys(l).length){r.sn+=1;const u=r.sn;Object.keys(l).forEach(p=>{zn(c,Number(p),u)})}}}function Tf(e,t){ar(e);const n=Nn();return Hn(e,n,{collectType:"no",globalId:t}).renderInfo}var{ACTION:Ns,MUTATE:Vs}=j;function or(e,t){ar(e);const{target:n,from:r="Mutate"}=t||{};let o=qo();n&&(o=De(n));const{loadingProxy:s,loadingState:c}=ot(le,{apiCtx:e,internal:o,from:r});return{loadingProxy:s,loadingState:c,internal:o,from:r}}function Us(e,t){const{loadingProxy:n,internal:r,from:o}=or(e,t),{proxyState:s,extra:c,renderInfo:a}=Hn(e,n);return[Ke(c,s,o),r.setState,a]}function Mf(e,t){const{loadingProxy:n}=or(e,{target:t,from:Vs});return n}function bf(e,t){return Us(e,{target:t,from:Vs})}function wf(e,t){const{loadingProxy:n}=or(e,{target:t,from:Ns});return n}function If(e,t){return Us(e,{target:t,from:Ns})}function Bs(e){return e.hookImpl.useForceUpdate()}function Ys(e,t){const n=(r,o)=>{let s=null;if(P(r)){const c=sn(o),a=r(c);s=cn(c),X(a)&&Object.assign(s,a)}else X(r)&&(s=F(F({},o),r));return s};return e.hookImpl.useObjectLogic(t,n,!0)}function Ff(e,t,n){const{useRef:r,useMemo:o,useEffect:s}=e.react,c=r({fn:n,wrap:null});c.current.fn=o(()=>n,[n]),c.current.wrap||(c.current.wrap=(...a)=>{c.current.fn(...a)}),s(()=>{const a=oi(),i=c.current.wrap;return a.on(t,i),()=>a.off(t,i)},[t,c])}function sr(e,t,n={}){const r=xe(t),{insCtx:o}=Ft(e,t,G(F({},n),{forAtom:r,isReactive:!0}));return[o.proxyStateVal,o.proxyState,o.renderInfo]}function Hs(e,t,n={}){const[r,o,s]=sr(e,t,n);return G(F({},s),{state:r,stateRoot:o})}function Cf(e,t,n){const r=X(n)?n:{};e.react.useEffect(()=>{const{srvRef:o}=r;P(o)&&o(t)},[])}function Of(e,t,n){const r=e.hookImpl.useStable(t);return Cf(e,r,n),r}function Pf(e){return t=>e.current=t}var{HOOK:Gs}=ae;function js(e,t){e(()=>{var n,r;return t.mountStatus=vt,xo(t),(r=(n=t.extra).deferedWatch)==null||r.call(n),()=>{$n(t)}},[t])}function $s(e,t){const{useRef:n,useState:r,useMemo:o,useEffect:s}=e.react,{label:c,forEffect:a,watchFn:i,watchOptions:l}=t,f=n({fn:i,wrap:null,fnKey:"",isDeferMarked:!1}),[u]=r(()=>Ct());if(f.current.fn=o(()=>i,[i]),!f.current.wrap){const{deps:p,immediate:d}=hs(a,l);f.current.wrap=m=>{if(u.mountStatus===vt){f.current.fn(m);return}u.extra.deferedWatch=()=>{if(f.current.isDeferMarked){f.current.fn(m);return}f.current.isDeferMarked=!0,jn(f.current.fnKey,0),f.current.fn(m),Re()}};const{fnKey:E}=Lt(f.current.wrap,{scopeType:Gs,fnCtxBase:u,deps:p,immediate:d,label:c});f.current.fnKey=E}js(s,u)}function xf(e,t,n){const{useState:r,useEffect:o}=e.react,[s]=r(()=>Ct());if(s.fn===C){const{manualDepKeys:c=[]}=n;Lt(t,{scopeType:Gs,fnCtxBase:s,deps:()=>c.map(i=>{const{sharedKey:l,keyPath:f}=bo(i),u=hi(l);return he(u,f)}),isSimpleWatch:!0})}js(o,s)}function kf(e,t,n){$s(e,{label:"useWatch",forEffect:!1,watchFn:t,watchOptions:n})}function Lf(e,t,n){$s(e,{label:"useWatchEffect",forEffect:!0,watchFn:t,watchOptions:n})}function Nf(e){const{internal:t,setFactoryOpts:n}=e,{rawState:r,forAtom:o,stopDepth:s,sharedKey:c}=t,a=mn(n),i=F({},r),l=(d,E,m,y)=>{const v=Je(E,m,{parentType:Fo(d),parentKeyPath:y});is(v,{internal:t,mutateCtx:a}),gr(i,v.fullKeyPath,m)},f=(d,E,m)=>We(d,{set:(y,v,S)=>(l(y,v,S,m),!0),get:(y,v)=>{const S=y[v];if(mt.includes(v))return wt(E===1,o,c,v,S);const R=Je(v,S,{isChanged:!1,parentKeyPath:m,op:"get",parentType:Fo(y)});return E<s&&_e(S)?f(S,E+1,R.fullKeyPath):he(i,R.fullKeyPath)}}),u=f(i,1,[]);Tt.set(u,o),Mn.set(a);const p=o?u.val:u;return{draftRoot:u,draftNode:p,finishMutate(d,E={}){ds(a,E);const m=F({state:{},mutateCtx:a},e);ls(m,u,p,d)}}}function Vf(e){let t=e;if(e){e.persist&&e.persist();const{currentTarget:n}=e;n&&e.type?n.tagName==="INPUT"&&n.type==="checkbox"?t=n.checked:t=n.value:e.nativeEvent&&e.target&&(t=e.target.value)}return t}function Uf(e){let t=[];return{target:Ni(e,({fullKeyPath:r})=>{t=r}),getPath:()=>t}}function Ws(e,t,n){return o=>{let s=Vf(o);e(c=>{const{isAtom:a,draftRoot:i}=Tt.current(),l={draft:c,draftRoot:i,path:t,isAtom:a,UNDEFINED:Pa},f=n==null?void 0:n(s,l);gr(i,t,f!==void 0?f:s)},{from:j.SYNC})}}function cr(e,t){const{sharedKey:n,innerSetState:r}=t;let o=$(e,n),s=Xs.get(o);return s||(s=Ws(r,e),Xs.set(o,s)),s}var Xs=new Map;function zs(e){const{forAtom:t,rawState:n}=e;return t?yr(n.val)?We(n.val,{get:(r,o)=>cr(["val",o],e)}):cr(["val"],e):We(n,{get:(r,o)=>cr([o],e)})}var Js=new Map;function Zs(e){const{forAtom:t,sharedKey:n,innerSetState:r,rawState:o}=e,s=Uf(o);return(c,a)=>{let i=[];if(Array.isArray(c))i=t?["val",...c]:c;else{const{target:u,getPath:p}=s;c(t?u.val:u),i=p()}let l=$(i,n);a&&(l+=`${a.toString()}`);let f=Js.get(l);return f||(f=Ws(r,i,a),Js.set(l,f)),f}}function Bf(e,t,n){const{deep:r,forAtom:o,sharedKey:s}=n,c=qu(n),a=Gt(r),i=(v={})=>{const S={internal:y,setFactoryOpts:v},{finishMutate:R,draftRoot:T,draftNode:I}=a?Wu(S):Nf(S);return{finish:(b,M={})=>{const K=y.snap;if(b===K)return K;const h=Ui(o,b,I);return R(h,M),y.snap},draftRoot:T,draftNode:I}},l=(v={})=>i(v),f=(v,S={})=>i().finish(v,S),u=(v,S)=>{const[R,T,I]=S;return Un(e,qe.current(s)),i({handleCbReturn:R,enableDep:T}).finish(v,zu(I))},y=go(n,{sharedRoot:e,sharedState:t,setState:(v,S)=>u(v,[!0,!0,S]),setDraft:(v,S)=>u(v,[!1,!0,S]),insSetState:(v,S)=>u(v,[!0,!1,S]),insSetDraft:(v,S)=>u(v,[!1,!1,S]),setStateFactory:l,innerSetState:f,ruleConf:c,isDeep:a});return y.sync=Zs(y),y.syncer=zs(y),li(e,y),y}function Yf(e,t){const n=Zu(e,t),{sharedRoot:r,sharedState:o}=Wi(n),s=Bf(r,o,n);mi(r,n),Oi(),qn({target:r,dict:n.mutateFnDict});const{draft:c,draftRoot:a}=Bn(s,{isTop:!0});return s.reactive=c,s.reactiveRoot=a,fi(n.moduleName,s.loc),Cu(s.usefulName),ri(s),{sharedRoot:r,sharedState:o,internal:s,parsedOptions:n}}var{USER_STATE:qs}=ee,{MUTATE:Hf,ACTION:Qs}=j;function ar(e,t){qs===(t||qs)&&!Nn()&&(Xi(e,le),bu(e,le))}function ec(e,t){const{createFn:n,ldAction:r,actionDict:o,actionCreator:s,internal:c,apiCtx:a,forTp:i=!1}=e;ot(n,{internal:c,from:Qs,apiCtx:a});const l={},f={};return Object.keys(o).forEach(u=>{const p=o[u],d=i?p.__task:p,E=s(!1)(d,u,t);E.__fnName=u,f[u]=E;const m=(...y)=>{const v=E(...y);return of(d)?Promise.resolve(v).then(S=>S.result):v.result};m.__fnName=u,l[u]=m}),{actions:l,eActions:f,getLoading:()=>r.getLoading(l),useLoading:()=>r.useLoading(l)[0],useLoadingInfo:()=>r.useLoading(l)}}function tc(e,t,n){const{state:r,stateRoot:o,isAtom:s}=e,c=yn(n);return P(t)?t({state:r,stateRoot:o,isAtom:s,extraBound:c}):t}function nc(e){const{common:t,ldMutate:n,mutateFnDict:r,extra:o}=e,s=tc(t,r,o),c=tr(t.stateRoot,o)(s);return{witnessDict:c,getLoading:()=>n.getLoading(c),useLoading:()=>n.useLoading(c)[0],useLoadingInfo:()=>n.useLoading(c)}}function Gf(e){const{common:t,ldMutate:n,inital:r,mutateFnDict:o}=e,{stateRoot:s,useState:c,state:a,isAtom:i}=oc(t.apiCtx,r),l=G(F({},t),{stateRoot:s,state:a,isAtom:i,internal:Y(s)}),f=nc({common:l,ldMutate:n,mutateFnDict:o,extra:t.stateRoot});return F({derivedState:s,useDerivedState:c},f)}function jf(e){const{common:t,deriveFnDict:n,throwErr:r}=e,o=tc(t,n),{apiCtx:s,stateRoot:c}=t,a={},i={};return Object.keys(o).forEach(f=>{const u=Ts(o[f],c);a[f]=u,i[f]={runDerive:p=>Bu(u,p!=null?p:r),runDeriveTask:p=>Yu(u,p!=null?p:r),useDerived:p=>rr(s,u,p)[0],useDerivedInfo:p=>rr(s,u,p)}}),{result:new Proxy(a,{get:(f,u)=>a[u].val}),helper:i}}function $f(e,t){if(t.enableMutate=e,e){const{mutateFnDict:n}=t,r={};Object.keys(n).forEach(o=>{const s=n[o];s.enabled||(s.enabled=!0,r[o]=s)}),tr(t.sharedState)(r)}}function Wf(e){const{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:i}=e;return{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:i}}function le(e,t){const{stateType:n,apiCtx:r}=e;ar(r,n);const{sharedRoot:o,sharedState:s,internal:c}=Yf(e,t),{syncer:a,sync:i,forAtom:l,setState:f,setDraft:u,sharedKey:p,sharedKeyStr:d,rootValKey:E,reactive:m,reactiveRoot:y}=c,v=_s(o),S=v(),R={internal:c,from:Hf,apiCtx:r},T=le,I=ts(T,G(F({},R),{from:Qs})),b=ts(T,R),M={createFn:T,internal:c,apiCtx:r,state:s,stateRoot:o,isAtom:l},K=G(F({},M),{ldAction:I,actionCreator:v});return{state:s,stateVal:s,stateRoot:o,setState:f,setDraft:u,setEnableMutate:h=>$f(h,c),getOptions:()=>Wf(c),setOnReadHook:h=>c.onRead=h,defineActions:h=>g=>ec(G(F({},K),{actionDict:g}),h),defineTpActions:h=>g=>ec(G(F({},K),{actionDict:g,forTp:!0}),h),defineMutateDerive:h=>g=>Gf({common:M,ldMutate:b,inital:h,mutateFnDict:g}),defineMutateSelf:()=>h=>nc({common:M,ldMutate:b,mutateFnDict:h}),defineFullDerive:h=>g=>jf({common:M,deriveFnDict:g,throwErr:h}),mutate:Fs(o),runMutate:h=>ws(o,h),runMutateTask:h=>Is(o,h),action:v,call:(h,g,A,_)=>S(h,A,_)(g),useState:h=>Cs(r,o,h),useStateX:h=>Os(r,o,h),useForceUpdate:h=>Ls(r,o,h),useLocalState:h=>Ys(r,h),useLocalForceUpdate:()=>Bs(r),getMutateLoading:b.getLoading,useMutateLoading:b.useLoading,getActionLoading:I.getLoading,useActionLoading:I.useLoading,getSnap:h=>mo(o,h),sync:i,syncer:a,sharedKey:p,sharedKeyStr:d,rootValKey:E,reactive:m,reactiveRoot:y,reactiveDesc:h=>Bo(o,h),useReactive:h=>sr(r,o,h),useReactiveX:h=>Hs(r,o,h),flush:h=>Un(o,h),isAtom:l}}function rc(e,t,n){const r=le({apiCtx:e,rawState:t},n);return[r.stateRoot,r.setState,r]}function oc(e,t,n){return le({apiCtx:e,rawState:t},n)}function Xf(e,t,n){const r=le({apiCtx:e,rawState:t,forAtom:!0},n);return[r.stateRoot,r.setState,r]}function zf(e,t,n){return le({apiCtx:e,rawState:t,forAtom:!0},n)}function sc(e,t){const{label:n,isSyncer:r}=t,o=De(e,{label:n});return(r?zs:Zs)(o)}function Jf(e){return sc(e,{label:"sync"})}function Zf(e){return sc(e,{label:"syncer",isSyncer:!0})}var qf=100,Qf=5e3;function el(e,t){return{key:e,results:[],depKeys:[],enableStatus:t,collected:!1,mounted:!1,renderAtomOnce:!1,time:0,status:{loading:!1,err:null,ok:!0}}}function tl(e,t=!1){const n=te();e&&(n.initCount+=1);const r=Si(),o=el(r,t);return Lo(e).set(r,o),o}function nl(e){const t=te();e.mounted=!0,e.time=Date.now(),t.mountedCount+=1}function rl(e,t){const n=te(),r=Lo(t);if(r.delete(e),t&&r.size===qf&&n.initCount-n.mountedCount>2){n.initCount=0,n.mountedCount=0;const o=Date.now();r.forEach((s,c)=>{!s.mounted&&o-s.time>Qf&&r.delete(c)})}}function ol(e,t){const n=te();n.runningKey=e.key,n.isDynamic=t}function sl(e){const t=te();t.runningKey="",t.isDynamic=!1,e.collected=!0}function cl(e,t,n){xf(e,n,{manualDepKeys:t.depKeys})}function cc(e,t,n){let r={loading:!1,err:null,ok:!0};return cl(e,t,n),t.results.forEach(o=>{const s=nr(e,{result:o,forAtom:ve(o),showLoading:t.enableStatus});s.status.ok||(r=s.status)}),r}function ac(e,t,n){e.react.useEffect(()=>(t.mounted||nl(t),()=>{rl(t.key,n)}),[t])}var al=()=>!0,ir=e=>e;function il(e){const t=[];for(let n=1;n<=e.length;n++)t.push(e.slice(0,n));return t}function ur(e,t,n,r,o){const s=t;return s.displayName=n,r?e.react.memo(s,o):s}function ic(e,t){const{sharedState:n,depKey:r,keyPath:o,compare:s,sharedKey:c,format:a=ir}=t;return ur(e,function(){const l=Hn(e,n,{arrDep:!0});l.isFirstRender&&(o.length>=2?il(o).forEach(p=>{l.recordDep({sharedKey:c,depKey:$(p,c),keyPath:p,parentKeyPath:p.slice(0,p.length-1)},At)}):l.recordDep({sharedKey:c,depKey:r,keyPath:o}));const f=he(l.internal.rawState,o);return a(f)},"HeluxSignal",!0,s)}function fr(e,t){return ur(e,function(){const{result:r,format:o=ir}=t,s=nr(e,{result:r,forAtom:!0});return o(s.proxyResult.val)},"HeluxDerivedAtomSignal",!0,t.compare)}function ul(e,t){return ur(e,function(){const{result:r,keyPath:o,format:s=ir}=t;return nr(e,{result:r,forAtom:!1}),s(he(r,o))},"HeluxDerivedSignal",!0,t.compare)}function uc(e,t){const{isDynamic:n,cb:r,props:o,ref:s}=t,{collected:c,status:a}=e;c||ol(e,n);const l=r(o,{props:o,status:a,read:Kc,ref:s})||"";return c||sl(e),l}function fc(e,t,n){const r=ve(n);if(t.renderAtomOnce&&!r)throw new Error("block cb once returned derived atom but not keep to return it in new render period!");if(r){t.renderAtomOnce=!0;const o=fr(e,{result:n});return e.react.createElement(o,{status:{loading:!1,err:null,ok:!0}})}return eo(n)}function lc(e,t,n,r){const{memo:o=!0,compare:s}=r||{},{key:c}=t,{react:a}=e,i=a.forwardRef||C,l=n();let f=i(l);pe()&&(l.displayName="HeluxKeyedBlockForHMR",f=i((p,d)=>(d&&wc(d,"current")&&(t.ref=d),a.createElement(l,G(F({},p),{key:c})))));const u=o?a.memo(f,s):f;return u.displayName="HeluxBlock",u[fn]=!0,u}function fl(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,{useForceUpdate:c}=o.hookImpl,a=r?ac:C;return lc(o,s,()=>(i,l)=>{const f=s.ref||l,u=uc(s,{isDynamic:r,cb:n,props:i,ref:f}),p=c();return cc(o,s,p),a(o,s,r),fc(o,s,u)},t)}function ll(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,c=r?ac:C,{useForceUpdate:a}=o.hookImpl,{useEffect:i}=o.react;return lc(o,s,()=>(l,f)=>{const u=s.ref||f,p=uc(s,{isDynamic:r,cb:n,props:l,ref:u}),d=a(),E=cc(o,s,d);c(o,s,r);const m=s.status.loading,y=E.loading;return i(()=>{m!==y&&d()},[m,y]),s.status=E,fc(o,s,p)},t)}function dc(e,t){const n=ef(t),{enableStatus:r}=n,o=G(F({},e),{blockCtx:tl(e.isDynamic,r)});return r?ll(o,n):fl(o,n)}function dl(e,t,n){return dc({apiCtx:e,isDynamic:!1,cb:t},n)}function pc(e,t,n){return dc({apiCtx:e,isDynamic:!0,cb:t},n)}function yc(e,t,n){const{react:r}=e;if(t&&t[fn])return r.createElement(t);const o=al;if(P(t)){const p=pc(e,t,{compare:o});return r.createElement(p)}if(ve(t)){const p=fr(e,{result:t,compare:o,format:n});return r.createElement(p)}if(xe(t)){const p=ue(t),d=Ht("val",p),m=ic(e,{sharedKey:p,sharedState:t,depKey:d,keyPath:["val"],compare:o,format:n});return r.createElement(m)}const s=$i(),{sharedKey:c,val:a,stateOrResult:i,depKey:l,keyPath:f,isDerivedResult:u}=s;if(t===a&&i){if(s.isDerivedAtom){const d=fr(e,{result:i,compare:o,format:n});return r.createElement(d)}if(u){const d=ul(e,{result:i,keyPath:f,compare:o,format:n});return r.createElement(d)}const p=ic(e,{sharedKey:c,sharedState:i,depKey:l,keyPath:f,compare:o,format:n});return r.createElement(p)}return t}var{shallowCompare:pl,isDiff:yl,isDraft:hl}=Ur,ml=rc,gl=yc,El={EVENT_NAME:an,RECORD_LOADING:un,VER:jr,LIMU_VER:Ia};function hc(e,t,n){return t(e,n)}function vl(e,t){return hc(e,t)}function Sl(e,t){return{build:n=>hc(e,t,n)}}var Al=["atom","atomx","share","sharex","getMutateLoading","getActionLoading","$","signal","block","blockStatus","dynamicBlock","dynamicBlockStatus"];function _l(e){return e.startsWith("use")||Al.includes(e)}function Dl(e){return Object.assign({useSyncExternalStore:C},e)}function Kl(e,t){const n=Nc(e),r=F({},n),o={react:Dl(e),hookImpl:n,act:t};t&&(n.useForceUpdate=()=>{const[,a]=e.useState({});return()=>t(()=>a({}))});const s=Gr;return Object.keys(s).forEach(a=>{const i=s[a];_l(a)?r[a]=i.bind(null,o):r[a]=i}),Object.assign({model:a=>vl(r,a),modelFactory:a=>Sl(r,a)},r)}function Rl(e){const{inited:t,API:n}=za();if(t)return n;const{heluxCtxKey:r,standalone:o,transfer:s,reactLib:c,act:a}=e,i=Q[r],l=(f,u)=>{const p=u||no(),d=Kl(c,a);return co({ROOT:p,inited:!0,api:d}),Q[f]=p,d};if(!i)return l(r);if(o)return l(`${String(r)}_${Date.now()}`);if(s){const f=no();co({ROOT:f,inited:!0}),s(i,f)}return l(r,i)}var Tl=N(70079),Ml=N.t(Tl,2),mc=Rl({heluxCtxKey:"__HELUX__",reactLib:Ml}),bl=mc.share,{atom:wl,atomx:Il,share:Fl,sharex:Cl,derive:Ol,deriveDict:Pl,defineDeriveTask:xl,defineDeriveFnItem:kl,runDerive:Ll,runDeriveTask:Nl,watch:Vl,watchEffect:Ul,useAtom:Bl,useAtomX:Yl,useReactive:Hl,useReactiveX:Gl,useDerived:jl,useWatch:$l,useWatchEffect:Wl,useGlobalId:Xl,useService:zl,useOnEvent:Jl,useMutable:Zl,useMutateLoading:ql,useActionLoading:Ql,useEffect:ed,useLayoutEffect:td,useStable:nd,useObject:rd,useLocalForceUpdate:od,useGlobalForceUpdate:sd,action:cd,signal:ad,block:id,dynamicBlock:ud,$:fd,mutate:ld,mutateDict:dd,runMutate:pd,runMutateTask:yd,defineMutateFnItem:hd,sync:md,syncer:gd,model:Ed,modelFactory:vd,emit:Sd,on:Ad,init:_d,reactiveDesc:Dd,flush:Kd,isAtom:Rd,isSharedState:Td,isDerivedAtom:Md,isDerivedResult:bd,isDraft:wd,storeSrv:Id,shallowCompare:Fd,markRaw:Cd,isDiff:Od,produce:Pd,getMutateLoading:xd,getActionLoading:kd,getDeriveLoading:Ld,getRawState:Nd,getSnap:Vd,getAtom:Ud,addMiddleware:Bd,addPlugin:Yd,cst:Hd}=mc}}]);
}());