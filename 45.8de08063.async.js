!(function(){"use strict";var Md=Object.defineProperty,bd=Object.defineProperties;var Id=Object.getOwnPropertyDescriptors;var Nt=Object.getOwnPropertySymbols;var lc=Object.prototype.hasOwnProperty,fc=Object.prototype.propertyIsEnumerable;var uc=(k,x,P)=>x in k?Md(k,x,{enumerable:!0,configurable:!0,writable:!0,value:P}):k[x]=P,F=(k,x)=>{for(var P in x||(x={}))lc.call(x,P)&&uc(k,P,x[P]);if(Nt)for(var P of Nt(x))fc.call(x,P)&&uc(k,P,x[P]);return k},N=(k,x)=>bd(k,Id(x));var dc=(k,x)=>{var P={};for(var w in k)lc.call(k,w)&&x.indexOf(w)<0&&(P[w]=k[w]);if(k!=null&&Nt)for(var w of Nt(k))x.indexOf(w)<0&&fc.call(k,w)&&(P[w]=k[w]);return P};var pc=(k,x,P)=>new Promise((w,J)=>{var De=H=>{try{Ke(P.next(H))}catch(Z){J(Z)}},tt=H=>{try{Ke(P.throw(H))}catch(Z){J(Z)}},Ke=H=>H.done?w(H.value):Promise.resolve(H.value).then(De,tt);Ke((P=P.apply(k,x)).next())});(self.webpackChunkspeedform_docs=self.webpackChunkspeedform_docs||[]).push([[45],{91045:function(k,x,P){P.r(x),P.d(x,{$:function(){return Jf},action:function(){return jf},addMiddleware:function(){return Dd},addPlugin:function(){return Kd},atom:function(){return gf},atomx:function(){return Ef},block:function(){return Xf},createShared:function(){return mf},cst:function(){return Rd},defineDeriveFnItem:function(){return Kf},defineDeriveTask:function(){return Df},derive:function(){return _f},deriveDict:function(){return Af},dynamicBlock:function(){return zf},emit:function(){return sd},flush:function(){return ud},getActionLoading:function(){return Ed},getAtom:function(){return Ad},getDeriveLoading:function(){return vd},getMutateLoading:function(){return gd},getRawState:function(){return Sd},getSnap:function(){return _d},init:function(){return ad},isAtom:function(){return ld},isDerivedAtom:function(){return fd},isDiff:function(){return hd},markRaw:function(){return yd},model:function(){return rd},modelFactory:function(){return od},mutate:function(){return Zf},mutateDict:function(){return qf},on:function(){return cd},produce:function(){return md},reactiveDesc:function(){return id},runDerive:function(){return Rf},runDeriveTask:function(){return Tf},runMutate:function(){return Qf},runMutateTask:function(){return ed},shallowCompare:function(){return pd},share:function(){return vf},sharex:function(){return Sf},signal:function(){return Wf},storeSrv:function(){return dd},sync:function(){return td},syncer:function(){return nd},useActionLoading:function(){return Vf},useAtom:function(){return bf},useAtomX:function(){return If},useDerived:function(){return Cf},useEffect:function(){return Uf},useGlobalForceUpdate:function(){return $f},useGlobalId:function(){return Pf},useLayoutEffect:function(){return Bf},useLocalForceUpdate:function(){return Gf},useMutable:function(){return Lf},useMutateLoading:function(){return Nf},useObject:function(){return Hf},useOnEvent:function(){return xf},useReactive:function(){return wf},useReactiveX:function(){return Ff},useService:function(){return kf},useStable:function(){return Yf},useWatch:function(){return Of},watch:function(){return Mf}});function w(e,t){e.includes(t)||e.push(t)}function J(e,t){const n=e.indexOf(t);n>=0&&e.splice(n,1)}function De(e){return Array.from(new Set(e))}function tt(e,t){let n=!1;for(const r of e)if(t.includes(r)){n=!0;break}return n}function Ke(e,t){let n="";const r=e.length;for(let o=0;o<r;o++){const s=e[o];if(t.startsWith(s)){n=s;break}}return n}function H(e,t){if(!e)return[];const n=e(t);return Array.isArray(n)?n:[n]}var Z=function(){if(typeof globalThis!="undefined")return globalThis;if(typeof global!="undefined")return global;if(typeof window!="undefined")return window;if(this!==void 0)return this;throw new Error("no globalThis")}(),lr=!1;function C(...e){}var yc=C;function hc(...e){return e}function Re(...e){return[]}function wd(...e){}var mc=Object.prototype.toString,gc="[object Map]";function Fd(){return!(typeof window!="undefined"&&window.document)}function Vt(e){return mc.call(e)===gc}function fr(e){return e===Number.MAX_SAFE_INTEGER}function ue(){return!(!lr&&Z.name!=="previewFrame"&&!Z.BrowserFS)}function j(e){return e&&typeof e=="object"&&!Array.isArray(e)}function dr(e){return e&&typeof e=="object"}function O(e){return typeof e=="function"}function Cd(e){return lr?Object.prototype.toString.call(e)==="[object AsyncFunction]":!0}function Ut(e){return typeof e=="symbol"}function Bt(e){if(!e)return!1;const t=typeof e;return(t==="object"||t==="function")&&O(e.then)}function Od(e){try{return e.test,!1}catch(t){return!0}}function Fe(){return typeof Proxy=="function"}function le(e,t){var l;const{throwErr:n=!1,prefixLabel:r="",suffixLabel:o=", see details in console.",logErr:s=!0,alertErr:c}=t||{};let a=e,i=!1;if(e instanceof Error&&(i=!0,a=e.message),(c!=null?c:ue())&&e&&((l=Z.alert)==null||l.call(Z,`${r}${a}${o}`)),s&&console.error(e),n)throw i?e:new Error(String(e))}function Te(e,t=0){t===0?(console.error(e),ue()&&console.trace(e)):t===1?console.error(e):console.warn(e)}function Ce(e){return fr(e)?1:e+1}var Ec=!!Reflect,vc=Object.prototype.hasOwnProperty;function Sc(e,t){return Ec?Reflect.has(e,t):vc.call(e,t)}function Oe(e,t,n){let r=e[t];return r||(r=e[t]=n),r}function nt(e,t,n){let r=e.get(t);return r||(e.set(t,n),r=n),r}function pr(e,t){let n="";for(const r in e)if(t.startsWith(r)){n=r;break}return n}function yr(e,t){const n=e.get(t);if(n!==void 0)return n;const r=e.get(Number(t)||t);return r!==void 0?r:void 0}function fe(e,t){let n,r=e;return t.forEach(o=>{n=Vt(r)?yr(r,o):r[o],r=n}),n}function hr(e,t,n){let r=e;const o=t.length-1;t.forEach((s,c)=>{const a=Vt(r);if(c===o)return void(a?r.set(s,n):r[s]=n);r=a?yr(r,s):r[s]})}function _c(){return Te("changing shared state is invalid"),!0}function Pd(e){return e}function Yt(e,t){return`${t}/${e}`}function Ht(e){return e&&Fe()}var Ac=Object.defineProperty,Gt={};((e,t)=>{for(var n in t)Ac(e,n,{get:t[n],enumerable:!0})})(Gt,{useEffect:()=>Tc,useEffectLogic:()=>jt,useForceUpdate:()=>mr,useLayoutEffect:()=>Rc,useObject:()=>bc,useObjectLogic:()=>Er,useStable:()=>gr});var Dc=0,rt=new Map,$t=0;function Kc(e,t){const n=()=>{const r=t();return()=>{rt.delete(e),r&&r()}};if(function(r){$t||($t=r)}(e),function(r){const o=rt.get(r);o?o.count+=1:rt.set(r,{count:1})}(e),$t%2!=0)return n();{const r=function(o){return rt.get(o)}(e);if(r&&r.count>1)return n()}}function jt(e,t,n){const{useState:r,useLayoutEffect:o,useEffect:s}=e.react,{isLayout:c,deps:a}=n,[i]=r(()=>++Dc);(c?o:s)(()=>Kc(i,t),a)}function Rc(e,t,n){jt(e,t,{isLayout:!0,deps:n})}function Tc(e,t,n){jt(e,t,{deps:n})}function mr(e){const[,t]=e.react.useState({});return()=>t({})}function Mc(e){const{data:t}=e.current;O(t)?e.current.wrap=(...n)=>e.current.data(...n):j(t)?e.current.wrap=function(n,r){if(!Fe()){const s={};return Object.keys(n).forEach(c=>{const a=n[c];O(a)?s[c]=(...i)=>r.current.data[c](...i):Object.defineProperty(s,c,{get:()=>r.current.data[c],set(i){r.current.data[c]=i}})}),s}const o={};return new Proxy(n,{get(s,c){const a=s[c];return O(a)?Oe(o,c,(...i)=>r.current.data[c](...i)):a}})}(t,e):e.current.wrap=t}function gr(e,t){const{useRef:n,useMemo:r}=e.react,o=n({data:t,wrap:{},inited:!1});return o.current.data=r(()=>t,[t]),o.current.inited||(Mc(o),o.current.inited=!0),o.current.wrap}function Er(e,t,n,r){const{useState:o,useRef:s,useEffect:c}=e.react,[a]=o(t),i=mr(e),l=s({state:null,unmount:!1,shouldCopy:!0}),f=gr(e,{setState(u){const d=l.current;if(d.unmount)return;let p;const{state:E}=d;n?(p=n(u,d.state||a),r&&p?(d.state=p,d.shouldCopy=!1):d.shouldCopy=!0):(p=(O(u)?u(E):u)||{},d.shouldCopy=!0),Object.assign(a,p||{}),i()},getLatestState(){const u=l.current;return u.shouldCopy&&(u.state=F({},a),u.shouldCopy=!1),u.state}});return c(()=>{const u=l.current;return u.unmount=!1,()=>{u.unmount=!0}},[l]),[a,f.setState,f]}function bc(e,t){return Er(e,t)}function Ic(e){const t={},n={react:e},r=Gt;return Object.keys(Gt).forEach(o=>{t[o]=r[o].bind(null,n)}),t}const kd=3,wc="3.12.1",ot=Symbol("M"),vr=Symbol("V"),Sr=Symbol("IMMUT_BASE"),Wt=Symbol("IS_RAW"),W="Map",z="Set",X="Array",Fc="Object",Cc=[Symbol.iterator,Symbol.toStringTag],Oc={Map:W,Set:z,Array:X},Xt="[object Object]",st="[object Map]",ct="[object Set]",zt="[object Array]",Jt="[object Function]",Pc={[st]:W,[ct]:z,[zt]:X,[Xt]:Fc},kc=["push","pop","shift","splice","unshift","reverse","copyWithin","delete","fill"],xc=["set","clear","delete"],Lc=["add","clear","delete"],Nc=["splice","sort","unshift","shift"],Vc=["concat","copyWithin","entries","every","fill","filter","find","findIndex","flat","flatMap","forEach","includes","indexOf","join","keys","lastIndexOf","map","pop","push","reduce","reduceRight","reverse","shift","unshift","slice","some","sort","splice","values","valueOf"],Uc=["clear","delete","entries","forEach","get","has","keys","set","values"],Bc=["add","clear","delete","entries","forEach","has","keys","values"],_r={[W]:Uc,[z]:Bc,[X]:Vc},Yc={[W]:["clear","set","delete"],[z]:["clear","add","delete"],[X]:["pop","push","shift","unshift","splice","sort","copyWithin"]},Hc={[W]:["forEach","get"],[z]:["forEach"],[X]:["forEach","map"]},Pe={value:0,usablePrefix:1},Ar={autoFreeze:!1,fastModeRange:"array"},Gc=Object.prototype.toString,$c=!!Reflect,jc=Object.prototype.hasOwnProperty;function Dr(e,t){return $c?Reflect.has(e,t):jc.call(e,t)}function Wc(e,t,n,r){const o=(s,c,a)=>{ee(s)||(r(s,c,a),Array.isArray(s)&&s.forEach((i,l)=>{o(i,s,l)}),at(s)&&s.forEach((i,l)=>{o(i,s,l)}),ke(s)&&Object.keys(s).forEach(i=>{o(s[i],s,i)}))};o(e,t,n)}function de(e){return Gc.call(e)}function Me(...e){return e}function ke(e){return de(e)===Xt}function at(e){return de(e)===st}function Zt(e){return de(e)===ct}function pe(e){return de(e)===Jt}function Kr(e){var t=de(e);return Pc[t]}function ee(e){const t=de(e);return![Xt,zt,st,ct,Jt].includes(t)}function Rr(e){return e.constructor.name==="AsyncFunction"||typeof e.then=="function"}function Tr(e){return typeof Promise!="undefined"&&e instanceof Promise}function qt(e){var t=typeof e;return t==="number"?!0:t==="string"?/^[0-9]*$/.test(e):!1}function Xc(e){return typeof e=="symbol"}function zc(e){var t;return e&&(t=e[Wt])!==null&&t!==void 0?t:!1}const Jc={[zt]:Array.prototype,[st]:Map.prototype,[ct]:Set.prototype,[Jt]:Function.prototype};function Zc(e){const t=de(e),n=Jc[t]||Object.prototype,r=Object.create(null);return Object.setPrototypeOf(r,n),Object.setPrototypeOf(e,r),e}const Qt=new Map;function xe(e){e.rootMeta.modified=!0;const t=n=>{n&&!n.modified&&(n.modified=!0,t(n.parentMeta))};t(e)}function en(e,t,n){if(n.apiCtx.debug){const{fast:r}=n;r?e[ot]=t:(Zc(e),e.__proto__[ot]=t)}return e}function qc(e,t,n){const r=[t],o=te(e,n);if(o&&o.level>0){const{keyPath:s}=o;return[...s,t]}return r}function Qc(e,t,n){const{ver:r,parentMeta:o=null,immutBase:s,compareVer:c,apiCtx:a,hasOnOperate:i}=n,l=Kr(t);let f=[],u=0,d=null;o&&(d=o.copy,u=ta(d,a),f=qc(d,e,a));const p={rootMeta:null,parentMeta:o,parent:d,selfType:l,self:t,copy:null,key:e,keyPath:f,level:u,proxyVal:null,proxyItems:null,modified:!1,scopes:[],isImmutBase:s,isDel:!1,isFast:!1,isArrOrderChanged:!1,newNodeStats:{},newNodeMap:new Map,newNodes:[],ver:r,compareVer:c,revoke:Me,hasOnOperate:i,execOnOperate:Me};return u===0?p.rootMeta=p:p.rootMeta=o.rootMeta,p}function Mr(e){const t=tn(e);return t?!t.isImmutBase:!1}function ea(){Pe.value>=Number.MAX_SAFE_INTEGER?(Pe.value=1,Pe.usablePrefix+=1):Pe.value+=1;const{value:e,usablePrefix:t}=Pe;return`${t}_${e}`}function ta(e,t){const n=ye(e,t);return n?n.level+1:1}function te(e,t){return t.metaMap.get(e)}function ye(e,t){let n=t||Ir(e);return(n==null?void 0:n.metaMap.get(e))||null}function br(e){return e&&e[vr]||""}function Ir(e){const t=br(e);return Qt.get(t)||null}function tn(e){const t=Ir(e);return t&&t.metaMap.get(e)||null}function wr(e,t){const n=tn(e),r=tn(t);if(!n&&!r)return!Object.is(e,t);const{self:o,modified:s,compareVer:c,ver:a,level:i}=n||{self:e,modified:!1,compareVer:!1,ver:"0",level:0},{self:l,modified:f,compareVer:u,ver:d,level:p}=r||{self:t,modified:!1,compareVer:!1,ver:"0",level:0};return o!==l||(c||u)&&(i===0||p===0)&&a!==d?!0:s||f}function na(e,t,n=!0){const r=n?wr:Object.is;return!((c,a)=>{for(let i in c)if(!(i in a))return!0;for(let i in a)if(r(c[i],a[i]))return!0;return!1})(e,t)}function xd(e){const t=n=>{if(isPrimitive(n))return n;let r=n;if(Array.isArray(n)&&(r=n.slice(),r.forEach((o,s)=>{r[s]=t(o)})),isSet(n)){const o=Array.from(n);o.forEach((s,c)=>{o[c]=t(s)}),r=new Set(o)}return isMap(n)&&(r=new Map(n),r.forEach((o,s)=>{r.set(s,t(o))})),isObject(n)&&(r={},Object.keys(n).forEach(o=>{r[o]=t(n[o])})),r};return t(e)}function ra(e,t){const{parentType:n,fastModeRange:r}=t;if(Array.isArray(e))return{copy:e.slice(),fast:!1};const o=r==="array"&&n===X||r==="all";let s=e;return e&&ke(e)&&(s=Object.assign({},e)),at(e)&&(s=new Map(e)),Zt(e)&&(s=new Set(e)),{copy:s,fast:o}}function oa(e,t,n){const{apiCtx:r,immutBase:o}=n;if(o)return{copy:e,fast:!1};const{copy:s,fast:c}=ra(e,n);return en(s,t,{apiCtx:r,fast:c}),{copy:s,fast:c}}function sa(e,t,n){const{copy:r,isArrOrderChanged:o}=e,{targetNode:s,key:c}=n;if(o){const a=r.findIndex(i=>i===t.copy);a>=0&&(r[a]=s);return}r[c]=s}function ca(e,t){return ke(e)?br(e)===t:!0}function aa(e,t){const{debug:n}=t,r=new Map;t.newNodeMap.forEach(o=>{const{node:s,parent:c,key:a}=o,i=r.get(s);if(i){c[a]=i;return}const l=o;Wc(s,c,a,(f,u,d)=>{const p=ye(f,t);if(p){const{modified:E,copy:y,self:g}=p,v=E?y:g;u[d]=v}}),l.target=c[a],r.set(s,l.target)}),e.scopes.forEach(o=>{const{modified:s,copy:c,parentMeta:a,key:i,self:l,revoke:f,proxyVal:u,isDel:d,isFast:p}=o;if(!c||(n&&(p?delete c[ot]:delete c.__proto__[ot]),!a))return f();const E=s?c:l,y=a.copy,g=a.selfType;if(g===W)return y.set(i,E),f();if(g===z)return y.delete(u),y.add(E),f();if(g===X)return sa(a,o,{targetNode:E,key:i}),f();if(d!==!0)return y[i]=E,f()}),e.scopes.length=0}function ia(e,t){const{self:n,copy:r,modified:o}=e;let s=n;return r&&o&&(s=e.copy),aa(e,t),s}function Fr(e){e.rootMeta.scopes.push(e)}function Cr(e,t,n){const{traps:r,parentType:o,fastModeRange:s,immutBase:c,apiCtx:a}=n,i=Qc(e,t,n),{copy:l,fast:f}=oa(t,i,{immutBase:c,parentType:o,fastModeRange:s,apiCtx:a});if(i.copy=l,i.isFast=f,c){const u=new Proxy(l,r);i.proxyVal=u,i.revoke=Me}else{const u=Proxy.revocable(l,r);i.proxyVal=u.proxy,i.revoke=u.revoke}return a.metaMap.set(l,i),a.metaMap.set(i.proxyVal,i),i}function ua(e,t){return e===X?!0:(Hc[e]||[]).includes(t)}function la(e,t){const{key:n,parentMeta:r,parent:o,parentType:s,fastModeRange:c,readOnly:a,apiCtx:i}=t;let l=e;if(a&&r&&!pe(e)){const{copy:u,self:d}=r,p=d[n];if(l!==p){const E=i.metaMap.get(l);E&&(i.metaMap.delete(l),i.metaMap.delete(E.proxyVal)),u[n]=p,l=p}}const f=(u,d)=>{const p=d||"";if(ee(u)||!u)return u;if(!r)throw new Error("[[ createMeta ]]: meta should not be null");if(!pe(u)){if(r.newNodeStats[p]||u[Wt])return u;let y=te(u,i);return y||(y=Cr(p,u,t),Fr(y),r.selfType===W?o.set(p,y.copy):o[p]=y.copy),y.proxyVal}if(!ua(s,p)||r.proxyItems)return u;let E=[];if(s===z){const y=new Set;o.forEach(g=>y.add(f(g))),Pr(y,r,{dataType:z,apiCtx:i}),E=en(y,r,{fast:c,apiCtx:i}),r.copy=E}else if(s===W){const y=new Map;o.forEach((g,v)=>y.set(v,f(g,v))),Pr(y,r,{dataType:W,apiCtx:i}),E=en(y,r,{fast:c,apiCtx:i}),r.copy=E}else s===X&&p!=="sort"&&(r.copy=r.copy||o.slice(),E=r.proxyVal);return r.proxyItems=E,u};return f(l,n)}function Or(e,t){if(!ke(e))return e;const n=te(e,t);return n?n.copy:e}function Pr(e,t,n){const{dataType:r,apiCtx:o}=n,s=e.delete.bind(e),c=e.clear.bind(e);if(e.delete=function(...i){return xe(t),s(...i)},e.clear=function(...i){return xe(t),c(...i)},r===z){const a=e.add.bind(e);e.add=function(...l){return xe(t),a(...l)}}if(r===W){const a=e.set.bind(e),i=e.get.bind(e);e.set=function(...f){if(xe(t),t.hasOnOperate){const u=f[1];t.rootMeta.execOnOperate("set",f[0],{mayProxyVal:u,value:u,parentMeta:t})}return a(...f)},e.get=function(...f){const u=i(...f);if(t.hasOnOperate){const d=ye(u,o),p=d?d.copy||d.self:u;t.rootMeta.execOnOperate("get",f[0],{mayProxyVal:u,value:p,parentMeta:t,isChanged:!1})}return u}}}function fa(e){const{calledBy:t,parentMeta:n,op:r,parentType:o}=e;(["deleteProperty","set"].includes(t)||t==="get"&&(o===z&&Lc.includes(r)||o===X&&kc.includes(r)||o===W&&xc.includes(r)))&&xe(n)}function kr(e,t){const n=e.keyPath.slice();return n.push(t),n.join("|")}function nn(e,t){const{op:n,key:r,value:o,calledBy:s,parentType:c,parentMeta:a,apiCtx:i}=t,l=Or(o,i);if(!a){e[r]=l;return}const{self:f,copy:u}=a;fa({calledBy:s,parentMeta:a,op:n,key:r,parentType:c});const d=_r[c]||[];if(pe(o)&&d.includes(n))return n==="slice"?f.slice:(Nc.includes(n)&&(a.isArrOrderChanged=!0),u?c===z||c===W?u[n].bind(u):u[n]:f[n].bind(f));if(!u)return l;const p=u[r],E=()=>{const g=ye(p,i);g&&(g.isDel=!0)},y=()=>{const g=ye(o,i);g&&g.isDel&&(g.isDel=!1,g.key=r,g.keyPath=a.keyPath.concat([r]),g.level=a.level+1,g.parent=a.copy,g.parentMeta=a)};if(s==="deleteProperty"){const g=ye(o,i);g?g.isDel=!0:E();const v=u[r];ee(v)||i.newNodeMap.delete(kr(a,r)),delete u[r];return}ee(l)||(a.newNodeStats[r]=!0,i.newNodeMap.set(kr(a,r),{parent:u,node:l,key:r,target:null})),u[r]=l,E(),y()}function rn(e){if(ee(e))return e;if(Array.isArray(e)&&e.length>0)return e.forEach(rn),Object.freeze(e);if(Zt(e)){const n=e;n.add=()=>n,n.delete=()=>!1,n.clear=Me;for(const r of n.values())Object.freeze(r);return Object.freeze(e)}if(at(e)){const n=e;n.set=()=>n,n.delete=()=>!1,n.clear=Me;for(const r of n.values())Object.freeze(r);return Object.freeze(e)}return Object.getOwnPropertyNames(e).forEach(n=>{const r=e[n];rn(r)}),Object.freeze(e)}const da=["length","constructor","asymmetricMatch","nodeType","size"],xr={};da.forEach(e=>xr[e]=1);const pa={[X]:1,[z]:1,[W]:1},on=new Map;function Lr(e){var t,n,r,o,s;const c=e||{},a=c.onOperate,i=!!a,l=c.customKeys||[],f=c.fastModeRange||Ar.fastModeRange,u=(t=c[Sr])!==null&&t!==void 0?t:!1,d=(n=c.readOnly)!==null&&n!==void 0?n:!1,p=c.disableWarn,E=(r=c.compareVer)!==null&&r!==void 0?r:!1,y=(o=c.debug)!==null&&o!==void 0?o:!1,g=(s=c.autoFreeze)!==null&&s!==void 0?s:Ar.autoFreeze,v=ea(),_={metaMap:new Map,newNodeMap:new Map,debug:y,metaVer:v};Qt.set(v,_);const K=()=>(p||console.warn("can not mutate state at readOnly mode!"),!0),M=(A,T,R)=>{const{mayProxyVal:h,parentMeta:D,value:S,isCustom:m=!1}=R;let I=!1;if(!a)return{isChanged:I,mayProxyVal:h};const Y=D||{},{selfType:U="",keyPath:xt=[],copy:qe,self:Qe,modified:Lt,proxyVal:Ae}=Y||{};let et=!1;R.isChanged!==void 0?I=R.isChanged:(_r[U]||[]).includes(T)?(et=!0,I=(Yc[U]||[]).includes(T)):A!=="get"&&(I=D?(Lt?qe:Qe)[T]!==S:!0);let ie=null,ur=!1;return a({immutBase:u,parent:Qe,parentType:U,parentProxy:Ae,op:A,replaceValue:ic=>{ur=!0,ie=ic},getReplaced:()=>({isReplaced:ur,replacedValue:ie}),isBuiltInFnKey:et,isChanged:I,isCustom:m,key:T,keyPath:xt,fullKeyPath:xt.concat(T),value:S,proxyValue:h}),{mayProxyVal:ur?ie:h,isChanged:I}},b=(()=>{let A=!0;const T={get:(R,h)=>{if(vr===h)return v;const D=R[h];if(Cc.includes(h))return pe(D)?D.bind(R):D;if(h==="__proto__"||h==="toJSON"&&!Dr(R,h))return D;let S=D;const m=te(R,_);if(l.includes(h))return M("get",h,{parentMeta:m,mayProxyVal:S,value:D,isChanged:!1,isCustom:!0}).mayProxyVal;const I=m==null?void 0:m.selfType;return pa[I]&&xr[h]?m.copy[h]:(S=la(D,{key:h,compareVer:E,parentMeta:m,parentType:I,ver:v,traps:T,parent:R,fastModeRange:f,immutBase:u,readOnly:d,apiCtx:_,hasOnOperate:i}),I===X&&qt(h)?M("get",h,{parentMeta:m,mayProxyVal:S,value:D}).mayProxyVal:Oc[I]?(S=nn(R,{op:h,key:h,value:D,metaVer:v,calledBy:"get",parentType:I,parentMeta:m,apiCtx:_}),M("get",h,{parentMeta:m,mayProxyVal:S,value:D}).mayProxyVal):M("get",h,{parentMeta:m,mayProxyVal:S,value:D}).mayProxyVal)},set:(R,h,D)=>{let S=D;const m=te(R,_);if(Mr(D))if(ca(D,v)){if(S=Or(D,_),S===R[h])return!0}else A=!1;if(d)return M("set",h,{parentMeta:m,isChanged:!1,value:S}),K();if(m&&m.selfType===X){if(m.copy&&m.__callSet&&qt(h))return M("set",h,{parentMeta:m,value:S}),m.copy[h]=S,!0;m.__callSet=!0}let I=!1;return a?I=M("set",h,{parentMeta:m,value:S}).isChanged:I=(m.modified?m.copy:m.self)[h]!==D,I&&nn(R,{parentMeta:m,key:h,value:S,metaVer:v,calledBy:"set",apiCtx:_}),!0},deleteProperty:(R,h)=>{const D=te(R,_),S=R[h];return d?(M("del",h,{parentMeta:D,isChanged:!1,value:S}),K()):(M("del",h,{parentMeta:D,isChanged:!0,value:S}),nn(R,{parentMeta:D,op:"del",key:h,value:"",metaVer:v,calledBy:"deleteProperty",apiCtx:_}),!0)},apply:function(R,h,D){return R.apply(h,D)}};return{createDraft:R=>{if(ee(R))throw new Error("base state can not be primitive");let h=R;const D=te(R,_);if(D){if(u&&D.isImmutBase)return D.proxyVal;h=D.self}const S=Cr("",h,{ver:v,traps:T,immutBase:u,readOnly:d,compareVer:E,apiCtx:_,hasOnOperate:i});return Fr(S),S.execOnOperate=M,on.set(S.proxyVal,b.finishDraft),S.proxyVal},finishDraft:R=>{const h=te(R,_);if(!h)throw new Error("rootMeta should not be null!");if(h.level!==0)throw new Error("can not finish sub draft node!");if(h.isImmutBase)return R;let D=ia(h,_);return g&&A&&(D=rn(D)),Qt.delete(v),D}}})();return b}function Ld(e){const t=getDraftMeta(e);return t?t.self:e}function Nd(e){const t=getDraftMeta(e);return t?deepCopy(t.copy||t.self):e}function ya(e){return!e||ee(e)||(e[Wt]=!0),e}const Nr={has:Dr,noop:Me,isObject:ke,isMap:at,isSet:Zt,isFn:pe,isPrimitive:ee,isPromiseFn:Rr,isPromiseResult:Tr,isSymbol:Xc,isMardedRaw:zc,canBeNum:qt,isDraft:Mr,isDiff:wr,shallowCompare:na,getDraftMeta:ye,getDataType:Kr},Vr=wc;function sn(e,t){return Lr(t).createDraft(e)}function cn(e){const t=on.get(e);if(!t)throw new Error("Not a Limu root draft or draft has been finished!");return on.delete(e),t(e)}function Ur(e){if(!pe(e))throw new Error("produce callback is not a function")}function ha(e,t){if(Rr(e)||Tr(t))throw new Error("produce callback can not be a promise function or result")}function Br(e,t,n){Ur(t);const r=sn(e,n),o=t(r);return ha(t,o),cn(r)}function ma(e,t,n){if(!t||!pe(t)){const r=e,o=t;return Ur(e),s=>Br(s,r,o)}return Br(e,t,n)}const ga=ma,Yd=null;function Hd(e){return deepCopyFn(e)}function it(e,t){return Lr(Object.assign(Object.assign({},t||{}),{readOnly:!0,[Sr]:!0})).createDraft(e)}function Gd(e){conf.autoFreeze=e}function $d(){return conf.autoFreeze}const jd=null,Ea=ya,Wd=null;var va=Object.defineProperty,Sa=(e,t)=>{for(var n in t)va(e,n,{get:t[n],enumerable:!0})},Yr={};Sa(Yr,{$:()=>of,action:()=>gs,addMiddleware:()=>Ba,addPlugin:()=>$a,atom:()=>xl,atomx:()=>Ll,block:()=>ef,createShared:()=>rf,cst:()=>sf,currentDraftRoot:()=>vi,defineDeriveFnItem:()=>rl,defineDeriveTask:()=>nl,derive:()=>_s,deriveDict:()=>tl,dynamicBlock:()=>oc,emit:()=>za,flush:()=>Nn,getActionLoading:()=>gl,getAtom:()=>Zr,getDeriveLoading:()=>Ou,getMutateLoading:()=>hl,getRawState:()=>ni,getSnap:()=>po,init:()=>Ua,isAtom:()=>Ve,isDerivedAtom:()=>he,isDiff:()=>nf,markRaw:()=>Ea,mutate:()=>Ts,mutateDict:()=>qn,on:()=>Ja,produce:()=>ga,reactiveDesc:()=>No,runDerive:()=>Iu,runDeriveTask:()=>wu,runMutate:()=>Ks,runMutateTask:()=>Rs,shallowCompare:()=>tf,share:()=>sr,sharex:()=>kl,signal:()=>sc,storeSrv:()=>Al,sync:()=>Nl,syncer:()=>Vl,useActionLoading:()=>El,useAtom:()=>Ms,useAtomX:()=>bs,useDerived:()=>er,useGlobalForceUpdate:()=>Cs,useGlobalId:()=>yl,useLocalForceUpdate:()=>xs,useMutable:()=>Ls,useMutateLoading:()=>ml,useOnEvent:()=>vl,useReactive:()=>nr,useReactiveX:()=>Ns,useService:()=>_l,useWatch:()=>Kl,watch:()=>Wu});var Hr="4.0.1",_a=Vr,an={ON_DATA_CHANGED:"ON_DATA_CHANGED",ON_SHARE_CREATED:"ON_SHARE_CREATED",ON_ERROR_OCCURED:"ON_ERROR_OCCURED"},un={NO:"no",PRIVATE:"private",GLOBAL:"global"},Gr=0,$r=Symbol,Aa=typeof $r=="function";function ne(e){return Aa?$r(e):(Gr+=1,`__HELUX_SYMBOL_${Gr}__`)}var Da="__proto__",Ka=Fe(),Ra=ne("HeluxUndefined"),jr=ne("HeluxMutateFnItem"),ut=ne("HeluxFnKey"),lt=ne("HeluxSharedKey"),Wr=ne("HeluxReactiveMeta"),ln=ne("HeluxIsBlock"),Le=ne("HeluxIsAtom"),ft=ne("HeluxIsDerivedAtom"),dt=[lt,Le,ft,ln],pt="SingleMutate",Ta="HeluxGlobalLoading",Ma=6,ba=!0,Xr=2e3,Ia=20,Ne="1",fn="2",yt=1,ht=2,zr=3,be="|",mt={TASK:"task",MAY_TRANSFER:"may_transfer"},re={STATIC:"static",HOOK:"hook"},q={USER_STATE:"user_state",GLOGAL_EMPTY:"global_empty",GLOGAL_LOADING:"global_loading",PRIVATE_LOADING:"private_loading"},wa="derive",Jr="watch",gt="Object",Fa="Map",Ca="Array",Oa="Other",G={SET_STATE:"SetState",MUTATE:"Mutate",ACTION:"Action",REACTIVE:"Reactive",LOADING:"Loading",SYNC:"Sync"};function Ve(e){var t;return e&&(t=e[Le])!=null?t:!1}function he(e){return e&&e[ft]||!1}function Zr(e){return Ve(e)||he(e)?e.val:e}function Pa(){return{keySeed:{static:0,hook:0,Reactive:0,Mutate:0},runningFnKey:"",runningSharedKey:0,isIgnore:!1,depKeys:[],GID_INSKEYS_MAP:new Map,FNKEY_STATIC_CTX_MAP:new Map,FNKEY_HOOK_CTX_MAP:new Map,DEPKEY_FNKEYS_MAP:new Map,UNMOUNT_INFO_MAP:new Map,DEPKEY_COMPUTING_FNKEYS_MAP:new Map}}function ka(){return{keySeed:0,keyPrefix:0,initCount:0,mountedCount:0,latest:{val:null,stateOrResult:null,sharedKey:0,depKey:"",keyPath:[],isDerivedResult:!1,isDerivedAtom:!1},runningKey:"",isDynamic:!1,KEY_CTX_MAP:new Map,KEY_DYNAMIC_CTX_MAP:new Map}}function xa(){return{keySeed:0,UNMOUNT_INFO_MAP:new Map}}function La(){return{keySeed:0,SHARED_KEY_STATE_MAP:new Map,STATE_SHARED_KEY_MAP:new Map,INTERMAL_MAP:new Map,COMPARE_MAP:new Map,isStateChanged:!1}}function qr(){const e={};return{on:(t,n)=>{Oe(e,t,[]).push(n)},emit:(t,...n)=>{(e[t]||[]).slice().forEach(o=>o(...n))},off:(t,n)=>{const r=e[t]||[],o=r.findIndex(s=>s===n);o>=0&&r.splice(o,1)},canEmit:t=>e[t]}}function Qr(){const e={VER:Hr,LIMU_VER:Vr,rootState:{},setState:(t,n)=>{const r=e.ctx.mod[t];if(!r)throw new Error(`moduleName ${t} not found`);r.setState(n)},ctx:{bus:qr(),userBus:qr(),mod:{},middlewares:[],plugins:[],sharedScope:La(),fnScope:Pa(),insScope:xa(),blockScope:ka(),markAtomMap:new Map,renderSN:0,globalLoading:null,globalLoadingInternal:null,globalEmpty:null,globalEmptyInternal:null,isRootRender:!0},legacyRoot:{}};return e}var Et={},eo=!1,to=null,no=!1;function V(){return Et.ctx||{}}function Na(){return Et}function ro(e){Et=e.ROOT,to=e.api,eo=e.inited}function Va(){return{ROOT:Et,inited:eo,API:to}}function Ua(e){if(no)return!1;no=!0;const{isRootRender:t=!0}=e;return V().isRootRender=t,!0}function Ba(e){const{middlewares:t}=V();t.push(e)}function Ya(e,t,n,r){const{middlewares:o}=V();if(!o.length)return;const s={},{sharedKey:c,moduleName:a,forAtom:i}=e,f={forAtom:i,draftRoot:t,draft:n,sharedKey:c,moduleName:a,setData:(u,d)=>s[u]=d,data:s,idx:0,sn:r};o.forEach((u,d)=>{u(N(F({},f),{idx:d}))})}var{ON_DATA_CHANGED:dn,ON_SHARE_CREATED:oo,ON_ERROR_OCCURED:Ha}=an,Ga=[q.GLOGAL_LOADING,q.PRIVATE_LOADING];function $a(e){const{plugins:t,bus:n}=V();t.push(e);const r={on:(o,s)=>n.on(o,s),onStateChanged:o=>n.on(dn,o)};e.install(r)}function ja(e,t){const{bus:n}=V();if(n.canEmit(dn)){const{from:r,desc:o}=t,{sharedKey:s,moduleName:c,snap:a,usefulName:i,stateType:l}=e;let f;Ga.includes(l)?f=`${i}/setState`:f=`${i}@${r||"Api"}/${o}`,n.emit(dn,{snap:a,sharedKey:s,moduleName:c,type:f})}}function Wa(e){const{bus:t}=V();if(t.canEmit(oo)){const{snap:n,sharedKey:r,moduleName:o,usefulName:s}=e,c=`${s}@FactoryApi/createShared`;t.emit(oo,{snap:n,sharedKey:r,moduleName:o,type:c})}}function so(e,t,n){const{bus:r}=V();if(!r.canEmit(t))return!1;const{sharedKey:o,moduleName:s}=e;return r.emit(t,{moduleName:s,sharedKey:o,data:n}),!0}function co(e,t){so(e,Ha,{err:t})||(console.warn("found uncaught error, sugguest add a plugin to handle this error"),console.error(t))}function Xa(){const{userBus:e}=V();return e}function za(e,...t){const{userBus:n}=V();n.emit(e,...t)}function Ja(e,t){const{userBus:n}=V();return n.on(e,t),()=>n.off(e,t)}function Za(e,t){return e.__proto__=t,e}function qa(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(e,n)||(e[n]=t[n]);return e}var pn=Object.setPrototypeOf||({__proto__:[]}instanceof Array?Za:qa);function Qa(e){const t=Object.create(null);return pn(t,F({},Object.prototype)),e&&Object.assign(t,e),t}function ao(e){if(O(e))return;const t=Object.create(null);return pn(t,Object.prototype),pn(e,t),e}function io(e,t,n){return e[t]=n,!0}function uo(e,t){return e[t]}function Ue(e,t){const{set:n=io,get:r=uo,obj:o={}}=t||{};return Object.keys(e).forEach(s=>{Object.defineProperty(o,s,{enumerable:!0,configurable:!1,set:function(c){return n(e,s,c)},get:function(){return r(e,s)}})}),o}function me(e,t){const{set:n=io,get:r=uo}=t||{};if(Fe())return new Proxy(e,{set(c,a,i){return n(c,a,i)},get(c,a){return r(c,a)}});const o=Qa();return Ue(o,{obj:o,set:n,get:r})}var Be=V();function vt(e){const n=V()[e];return Be[e]=n,n}function Q(){return Be.blockScope||vt("blockScope")}function L(){return Be.fnScope||vt("fnScope")}function oe(){return Be.sharedScope||vt("sharedScope")}function lo(){return Be.insScope||vt("insScope")}function fo(){const{INTERMAL_MAP:e}=oe();return e}function ei(e,t){if(!e||!ue()||!t)return;const{INTERMAL_MAP:n,SHARED_KEY_STATE_MAP:r,STATE_SHARED_KEY_MAP:o}=oe();let s=[],c=!1;if(n.forEach(a=>{a.moduleName===e&&a.loc===t&&a.stateType===q.USER_STATE&&s.push(a.sharedKey)}),s.length>1){const a=s[0],i=n.get(a);n.delete(a),i&&(r.delete(i.sharedKey),o.delete(i.rawState))}return c}function Ye(e){return fo().get(e)}function B(e){const t=se(e);return Ye(t)}function ti(e,t){const n=fo(),r=se(e);n.set(r,t)}function ni(e){return B(e).rawState}function po(e,t=!0){const n=B(e);return t?n.prevSnap:n.snap}function se(e){return e&&(e[lt]||oe().STATE_SHARED_KEY_MAP.get(e))||0}function ri(e){const t=oe(),{STATE_SHARED_KEY_MAP:n}=t,r=Ce(t.keySeed);return n.set(e,r),t.keySeed=r,r}function oi(e,t){const{SHARED_KEY_STATE_MAP:n,STATE_SHARED_KEY_MAP:r}=oe();n.set(e,t),r.set(t,e)}function si(e){return oe().SHARED_KEY_STATE_MAP.get(e)}function ci(e,t){const{rootState:n,ctx:r}=Na(),{moduleName:o,usefulName:s}=t,c=n[s],a=B(c);if(o&&a&&a.loc!==t.loc){const i=`
loc1:${a.loc} 
loc2:${t.loc}`;return Te(`only-dev-mode tip: moduleName ${o} duplicate! this does not effect helux but the duplicated module will be ignored by devtool`+i)}n[s]=e,r.mod[s]=B(e)}var ai={innerSetState:C};function yo(e,t){const{rawState:n,forAtom:r}=e,o=new Map,s={},c={},a=[],i=F({},n);let l=i;return r&&(l=n.val),N(F(F({ver:0,sn:0,reactive:n,reactiveRoot:n,sync:C,syncer:C,snap:i,prevSnap:i,rawStateVal:l},e),t),{insCtxMap:o,key2InsKeys:s,id2InsKeys:c,recordId(f,u){if(!f)return;const d=Oe(c,f,[]);w(d,u)},delId(f,u){f&&J(c[f]||[],u)},recordDep(f,u){const d=Oe(s,f,[]);w(d,u)},delDep(f,u){J(s[f]||[],u)},mapInsCtx(f,u){o.set(u,f)},delInsCtx(f){o.delete(f)},extra:{},loadingInternal:ai,level1ArrKeys:a})}var ii={Mutate:"",Reactive:"r",[re.STATIC]:"s",[re.HOOK]:"h"};function ui(){const e=lo(),t=Ce(e.keySeed);return e.keySeed=t,t}function li(){const e=Q(),{keySeed:t,keyPrefix:n}=e,r=Ce(t);e.keySeed=r;let o=n;return fr(t)&&(o=Ce(n),e.keyPrefix=o),`${o}_${r}`}function fi(){const e=V(),t=e.renderSN,n=t===Number.MAX_VALUE?1:t+1;return e.renderSN=n,n}function yn(e){const t=ii[e],r=L().keySeed,o=Ce(r[e]);return r[e]=o,`${t}${o}`}function di(){return yn("Reactive")}var{MAY_TRANSFER:pi}=mt,{SET_STATE:yi,REACTIVE:hi}=G,mi=()=>({isReplaced:!1,replacedValue:null}),gi=()=>{},Ei=mn({isFake:!0});function ho(e,t,n=C){const{desc:r="",onRead:o,from:s=hi,depKeys:c=[],isTop:a=!1,expired:i=!1,insKey:l=0}=t;return{draft:e,finish:n,modified:!1,expired:i,sharedKey:0,moduleName:"",hasFlushTask:!1,nextTickFlush:C,data:[],isTop:a,key:"",fnKey:"",depKeys:c,writeKeys:[],desc:r,onRead:o,from:s,insKey:l}}function hn(e){const{ids:t=[],globalIds:n=[],isReactive:r=!1,from:o=yi,enableDep:s=!1,handleCbReturn:c=!0,sn:a=fi(),isFirstCall:i=!1,desc:l="",onRead:f}=e;return{fnKey:"",depKeys:[],forcedDepKeys:[],triggerReasons:[],ids:t,globalIds:n,readKeys:{},writeKeys:{},arrKeyDict:{},writeKeyPathInfo:{},handleCbReturn:c,draftVal:null,from:o,isReactive:r,enableDep:s,sn:a,isFirstCall:i,desc:l,onRead:f}}function He(e,t,n){const{isChanged:r=!0,parentKeyPath:o=[],op:s="set",parentType:c="Object"}=n,a=o.slice();return a.push(e),{isChanged:r,isCustom:!1,op:s,immutBase:!1,key:e,value:t,proxyValue:t,parentType:c,keyPath:o,fullKeyPath:a,isBuiltInFnKey:!1,replaceValue:C,getReplaced:mi}}function mn(e){const u=e||{},{desc:t="",fn:n=C,task:r=gi,depKeys:o=[],writeKeys:s=[],deps:c=Re,isFake:a=!1,onlyDeps:i=!1}=u,l=dc(u,["desc","fn","task","depKeys","writeKeys","deps","isFake","onlyDeps"]);return F({fn:n,task:r,deps:c,oriDesc:"",onlyDeps:i,desc:t,depKeys:o,writeKeys:s,checkDeadCycle:void 0,watchKey:"",isFake:a,enabled:!0},l)}function mo(){const e={fnKey:"",fn:C,subFnInfo:Ei,checkDeadCycle:!0,isFirstLevel:!0,isExpired:!1,task:C,deps:Re,status:{loading:!1,err:null,ok:!0},forAtom:!1,remainRunCount:0,showLoading:!1,nextLevelFnKeys:[],prevLevelFnKeys:[],mountStatus:yt,depKeys:[],depSharedKeys:[],result:{},fnType:"watch",returnUpstreamResult:!1,scopeType:"static",renderStatus:Ne,proxyResult:{},updater:C,createTime:Date.now(),shouldReplaceResult:!1,isAsync:!1,isAsyncTransfer:!1,isSimpleWatch:!1,isRunning:!1,dcErrorInfo:{err:null,tipFn:C},asyncType:pi,subscribe:t=>{t()},extra:{},setLoading:(t,n=null)=>{const r=!t&&!n;e.status={loading:t,err:n,ok:r}},renderInfo:{time:0,insKey:0,sn:0,getDeps:()=>e.depKeys.slice()}};return e}var go={draftRoot:{val:null},isFake:!0,isAtom:!0},Eo=hn({}),St=ho(!0,{expired:!0}),Xd=mn(),vo=yo({rawState:{},forAtom:!1,usefulName:""},{}),So=mo(),_t=go,gn=Eo,_o="",En=new Map,vn=new Map,Sn=new Map,_n=C,An=[],Dn="";function vi(){return _t}var Ge={current:()=>Dn,set:e=>Dn=e,del:()=>Dn=""},Kn={current:()=>_n,set:e=>_n=e,del:()=>_n=C},$e={current:e=>vn.get(e)||"SetState",set:(e,t)=>vn.set(e,t),del:e=>vn.delete(e)},je={current:()=>An,set:e=>An=e,del:()=>An=[]},ce={current:()=>Sn.get(_o)||St,markUsing:e=>_o=e,set:(e,t)=>Sn.set(e,t),del:e=>Sn.delete(e)},Rn={current:e=>En.get(e),set:(e,t)=>En.set(e,t),del:e=>En.delete(e)},At={current:()=>_t,set:(e,t)=>{Object.assign(_t,{draftRoot:e,isAtom:t,isFake:!1})},del:()=>_t=go},Tn={current:()=>gn,set:e=>gn=e,del:()=>gn=Eo};function Mn(e){const{FNKEY_STATIC_CTX_MAP:t,FNKEY_HOOK_CTX_MAP:n}=L();return e[0]==="s"?t:n}function Si(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=L();nt(n,e,[]).push(t)}function _i(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=L(),r=n.get(e);r&&J(r,t)}function Ai(e){const{DEPKEY_FNKEYS_MAP:t}=L(),{depKeys:n,fnKey:r}=e;n.forEach(o=>{const s=t.get(o)||[];J(s,r)})}function Ao(e,t){const{FNKEY_STATIC_CTX_MAP:n}=L(),{fnKey:r,prevLevelFnKeys:o}=e;o.forEach(s=>{var a;const c=(a=n.get(s))==null?void 0:a.nextLevelFnKeys;c&&(t?w(c,r):J(c,r))})}function Di(){const{FNKEY_HOOK_CTX_MAP:e}=L();ue()&&e.forEach(t=>{t.isExpired=!0})}function Do(e,t,n){const r=n||yn(t);return O(e)?e[ut]=r:(ao(e),e.__proto__[ut]=r),r}function Ko(e){return O(e)?e[ut]||"":j(e)&&e.__proto__[ut]||""}function ge(e){return Mn(e).get(e)}function bn(e){return Mn(e).get(e)||So}function We(e){const t=Ko(e);return ge(t)||null}function Dt(){const{runningFnKey:e,depKeys:t,runningSharedKey:n,isIgnore:r}=L();return{fnCtx:e?ge(e):null,depKeys:t,isIgnore:r,runningSharedKey:n}}function Ki(){return L().runningFnKey}var{USER_STATE:Ri}=q;function Ti(e,t=8){let n="";if(ue()&&e)try{throw new Error("loc")}catch(r){const o=r.stack.split(`
`),s=o[1]||"";s.includes("webpack-internal")||s.includes("/node_modules/")?n=o.slice(0,16).join(" -> "):n=o.map(a=>a.substring(0,a.indexOf("(")).trim()).slice(4,t).join(" -> ")}return n}function Ro(e){const[t,n]=e.split("/"),r=n.split(be);return{sharedKey:Number(t),keyPath:r,depKey:e}}function To(e){const{sharedKey:t,forAtom:n}=e,r=n?"/val":"",o=n?["val"]:[];return{depKey:`${t}${r}`,keyPath:o,sharedKey:t}}function $(e,t){try{return Yt(e.join(be),t)}catch(n){return console.warn("found Symbol key in your path :",e),`${t}`}}function Mi(e,t){const{snap:n,prevSnap:r,stateType:o}=e;if(Ri!==o)return!0;const{keyPath:s}=Ro(t);try{const c=fe(n,s),a=fe(r,s);return c!==a}catch(c){return!0}}function bi(e,t){return Fe()?it(e,{onOperate:t,compareVer:!0}):me(e,{get(n,r){const o=n[r],s=He(r,o,{isChanged:!1,parentKeyPath:[]});return t(s),o}})}function Ii(e,t){if(t!==void 0){if(e)return{val:t};if(j(t))return t}}function wi(e,t,n){const r=O(t)?t(n):t;return Ii(e,r)}function Kt(e,t){let{value:n}=e;if(t){t(e);const{replacedValue:r,isReplaced:o}=e.getReplaced();o&&(n=r)}return n}function Mo(e){return[Ca,Fa].includes(e)}function Fi(e){return Array.isArray(e)||Vt(e)}var{isObject:Ee,getDataType:bo}=Nr;function Io(e,t){if(e===t)return e;const r=t.substring(e.length+1).split(be);return`${e}${be}${r[0]}`}function Ci(e,t){Ke(e,t)||w(e,t)}var In=new Map;function wo(e,t){let n=!1;const{depKey:r,keyPath:o,sharedKey:s}=e,{stopDepInfo:c,level1ArrKeys:a,recordCb:i}=t,l=In.get(r);if(l)return i(l),!0;const{keys:f,isArrDict:u,depth:d,arrKeyStopDcit:p,stopArrDep:E}=c,y=Ke(a,r),g=o.length>d;if(g||y){let _="",K=d;return y&&(K=d+1,p[y]===!1||E&&(g?_=$(o.slice(0,K),s):_=Io(y,r))),_||(_=$(o.slice(0,K),s)),y||In.set(r,_),i(_),!0}const v=String(s);for(const _ of f){if(!r.startsWith(_)||_===v)continue;const K=u[_],M=K?Io(_,r):_;K||In.set(r,M),i(M),n=!0;break}return n}function wn(e,t){const n=Q(),{runningKey:r}=n;if(r){const{KEY_DYNAMIC_CTX_MAP:o,KEY_CTX_MAP:s,isDynamic:c}=n,i=(c?o:s).get(r);if(i){const{results:l,depKeys:f}=i;t?w(l,t):e.forEach(u=>w(f,u))}}}function Rt(e,t){const n=oe(),{COMPARE_MAP:r}=n;let o=r.get(t);return o!==void 0?o:e.sharedKeyStr===t?n.isStateChanged:(o=Mi(e,t),r.set(t,o),o&&(n.isStateChanged=!0),o)}function Fo(e,t,n){if(t.includes(n)&&Rt(e,n))return!0;let r=!1;for(const o of t)o.startsWith(n)&&Rt(e,o)&&(r=!0);return r}function Oi(){const e=oe();e.COMPARE_MAP.clear(),e.isStateChanged=!1}function Fn(e=!0){const t=L();t.isIgnore=e}function Ie(e,t){const{fnCtx:n,depKeys:r,isIgnore:o}=Dt(),s=t.specificCtx||n;if(!s){Kn.current()(e);return}const{DEPKEY_FNKEYS_MAP:c}=L(),{belongCtx:a,sharedKey:i}=t;if(i&&w(s.depSharedKeys,i),n&&a){n.isFirstLevel=!1,a.isAsync&&(n.isAsync=!0);const f=a.fnKey;w(s.prevLevelFnKeys,f),w(a.nextLevelFnKeys,n.fnKey)}const{fnKey:l}=s;e.forEach(f=>{if(Da===f||o)return;n&&w(r,f);const u=nt(c,f,[]);w(u,l)})}function Cn(e){e&&e.depKeys.forEach(t=>Ie([t],{specificCtx:e}))}function Co(e){const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=L(),{fnKey:r}=e;t.set(r,e),Ao(e,!0);let o=n.get(r);o?o.c=2:(o={c:1,t:Date.now(),prev:0},n.set(r,o));const{c:s}=o;if(s===2){const c=ge(r);Cn(c)}}function Oo(e){let t="";return e.depSharedKeys.forEach(n=>{var o;const r=((o=Ye(n))==null?void 0:o.ver)||0;t+=`${r}_`}),t}function Pi(e,t,n){const{DEPKEY_FNKEYS_MAP:r}=L(),o=r.get(t)||[],s=[],c=[];return o.forEach(a=>{const i=ge(a);if(i&&Fo(e,i.depKeys,t)){i.isFirstLevel&&s.push(a),i.isAsync&&c.push(a);const l=n[a];n[a]=l===void 0?1:l+1}}),{firstLevelFnKeys:s,asyncFnKeys:c}}function On(e){Ai(e),Ao(e)}function ki(){const{FNKEY_HOOK_CTX_MAP:e}=L();if(e.size>=Ia){const t=Date.now();e.forEach(n=>{const{mountStatus:r,createTime:o,fnKey:s}=n;[yt,zr].includes(r)&&t-o>Xr&&(On(n),e.delete(s))})}}function Pn(e,t,n,r,o,s=!1,c=!1){const a=Q();a.latest={sharedKey:e,val:t,stateOrResult:n,depKey:r,keyPath:o,isDerivedResult:s,isDerivedAtom:c}}function xi(){return Q().latest}function Po(e){const{KEY_DYNAMIC_CTX_MAP:t,KEY_CTX_MAP:n}=Q();return e?t:n}function ko(){return Te("changing shared state is invalid"),!0}function Tt(e,t,n,r,o){return r===Le?e?t:!1:r===lt?n:o}function kn(e,t,n){e.replaceValue(Tt(e.keyPath.length===0,t,n,e.key,e.value))}function Li(e){let t={};const{rawState:n,sharedKey:r,forAtom:o,onRead:s,isPrimitive:c,stopDepth:a}=e,i=(f,u)=>{const d=$(f,r);Ie([d],{sharedKey:r}),wn([d]),Pn(r,u,t,d,f)};if(Ka)t=it(n,{customKeys:dt,onOperate:f=>{const{isBuiltInFnKey:u,isCustom:d}=f;if(d)return kn(f,o,r);if(!u){const{fullKeyPath:p}=f,E=Kt(f,s);i(p,E)}},compareVer:!0});else{const f=(u,d,p)=>Ue(u,{set:ko,get:(E,y)=>{const g=E[y];if(dt.includes(y))return Tt(d===1,o,r,y,g);const v=He(y,g,{isChanged:!1,parentKeyPath:p});if(d<a&&Ee(g))return f(g,d+1,v.fullKeyPath);const _=Kt(v,s);return i(v.fullKeyPath,_),_}});t=f(n,1,[])}let l=t;return o&&(c?l=n.val:l=me(n,{set:ko,get:(f,u)=>t.val[u]})),oi(r,t),{sharedRoot:t,sharedState:l}}var xo=null;function xn(){return xo}function Ni(e,t){const n=V();let r=n.globalEmpty;if(!r){const{stateRoot:o}=t({apiCtx:e,rawState:{},forGlobal:!0,stateType:q.GLOGAL_EMPTY}),s=B(o);n.globalEmpty=o,n.globalEmptyInternal=s}return xo=r,r}function Ln(e){const{GID_INSKEYS_MAP:t}=L();return nt(t,e,[])}function Vi(){return V().globalEmptyInternal}function Lo(e,t){if(!e)return;const n=Ln(e);w(n,t)}function Ui(e,t){if(!e)return;const n=Ln(e);J(n,t)}var{REACTIVE:Bi}=G,Xe=new Map;function Yi(e){return!!(e&&!e.expired&&e.modified)}function Hi(e){const{sharedKey:t}=e;e.expired=!0,ce.del(e.key);const n=$e.current(t);return $e.del(t),e.finish(null,{desc:n})}function No(e,t){const n=se(e);return t&&$e.set(n,t),n}function Nn(e,t){const n=se(e);ze(n,t)}function Gi(){const e=ce.current();e.isTop&&ze(e.sharedKey,e.desc)}function ze(e,t){const n=Xe.get(e);Yi(n)&&(t&&$e.set(e,t),Hi(n))}function $i(e){const t=Xe.get(e)||St;t.expired=!0}function ji(e,t){const n=Xe.get(e)||St;n.modified=!0,n.nextTickFlush(t)}function Wi(e,t){const{from:n=Bi,onRead:r}=t,{finish:o,draftRoot:s}=e.setStateFactory({isReactive:!0,from:n,handleCbReturn:!1,enableDep:!0,onRead:r}),c=ho(s,t,o);return c.key=di(),c.sharedKey=e.sharedKey,c.nextTickFlush=a=>{const{expired:i,hasFlushTask:l}=c;i||(c.data=[a]),l||(c.hasFlushTask=!0,Promise.resolve().then(()=>{const[f]=c.data;ze(e.sharedKey,f)}))},c}function Vo(e,t,n){const{sharedKey:r}=e,{insKey:o=0,from:s}=t;let c=Xe.get(r)||St;c.expired&&(c=Wi(e,{isTop:!0,from:s}),Xe.set(r,c),ce.set(c.key,c),ce.markUsing(c.key),c.fnKey=Ge.current()),c.onRead=o?t.onRead:void 0;const{draft:a}=c;return{val:n?a.val:a,meta:c}}function Vn(e,t){let n={},r={};const{rawState:o,deep:s,forAtom:c,isPrimitive:a,sharedKey:i}=e;if(Ht(s)){const l={[lt]:i,[Le]:c},f=(d,p,E)=>{const{val:y}=Vo(e,t,d);return y[p]=E,!0},u=(d,p,E)=>{const y=E[p];if(y!==void 0)return y;const{val:g,meta:v}=Vo(e,t,d);return Wr===p?v:g[p]};if(n=new Proxy(o,{set:(d,p,E)=>f(!1,p,E),get:(d,p)=>u(!1,p,l)}),r=n,c){const d=N(F({},l),{[Le]:!1});r=a?o.val:new Proxy(o.val,{set:(p,E,y)=>f(!0,E,y),get:(p,E)=>u(!0,E,d)})}}else n=o,r=o.val;return{draftRoot:n,draft:r}}function Xi(e){const{UNMOUNT_INFO_MAP:t}=lo(),{insKey:n,readMap:r,internal:o}=e;o.mapInsCtx(e,n);let s=t.get(n);s?(s.c=2,s.prev=n-1):(s={c:1,t:Date.now(),prev:0},t.set(n,s));const{c}=s;c===2&&Object.keys(r).forEach(a=>{o.recordDep(a,n)})}function Uo(e){const{readMap:t,insKey:n,internal:r}=e;Object.keys(t).forEach(o=>r.delDep(o,n)),r.delInsCtx(n)}function zi(e){const{canCollect:t,isFirstRender:n,currentDepKeys:r}=e;if(!t){n&&(e.depKeys=r.slice());return}e.depKeys=r.slice()}function Ji(e){const{canCollect:t}=e;t&&(e.readMap={},e.delReadMap={},e.depKeys=e.currentDepKeys.slice(),e.currentDepKeys.length=0)}function Bo(e,t,n){if(!e.canCollect)return;const{parentType:r,rawVal:o}=n,s=Fi(o);s&&Ci(e.internal.level1ArrKeys,t.depKey),e.recordDep(t,r,s)}function Un(e,t){const{depKeys:n,currentDepKeys:r,fixedDepKeys:o}=e;return(t?r:n).concat(o)}function Zi(e){if(!e)return;const{updater:t,mountStatus:n,createTime:r}=e;if(n===yt){Date.now()-r>Xr?Uo(e):e.needEFUpdate=!0;return}t()}function Yo(e){const{internal:t,isReactive:n,insKey:r}=e,{rawState:o,isDeep:s,sharedKey:c,onRead:a,forAtom:i}=t;if(s){const l=f=>{const{isBuiltInFnKey:u,key:d}=f;if(u)return;if(Ut(d))return kn(f,i,c);const{fullKeyPath:p,keyPath:E,parentType:y}=f,g=Kt(f,a),_={depKey:$(p,c),keyPath:p,parentKeyPath:E,sharedKey:c};Bo(e,_,{parentType:y,rawVal:g})};if(n){const{draft:f,draftRoot:u}=Vn(t,{onRead:l,insKey:r});e.proxyState=u,e.proxyStateVal=f}else e.proxyState=it(o,{onOperate:l,compareVer:!0})}else e.proxyState=me(o,{set:()=>(Te("changing shared state is invalid"),!0),get:(l,f)=>{const u=l[f];if(Ut(f))return Tt(!0,i,c,f,u);const d=Kt(He(f,u,{isChanged:!1,parentKeyPath:[]}),a),p=Yt(f,c),E=Ee(l)?gt:Oa;return Bo(e,{depKey:p,keyPath:[f],sharedKey:c},{parentType:E,rawVal:d}),d}})}function qi(e){var R;const{updater:t,sharedState:n,id:r="",globalId:o="",collectType:s="every",deps:c,pure:a=!0,arrDep:i=!0,isReactive:l=!1}=e,f=i&&(R=e.arrIndexDep)!=null?R:!0,u=B(n);if(!u)throw new Error("ERR_OBJ_NOT_SHARED: input object is not a result returned by share api");const d=ui(),{rawState:p,isDeep:E,ver:y,ruleConf:g,level1ArrKeys:v,forAtom:_,sharedKey:K,sharedKeyStr:M,snap:b}=u,{stopDepInfo:A}=g,T={readMap:{},delReadMap:{},pure:a,depKeys:[],fixedDepKeys:[],currentDepKeys:[],isDeep:E,isReactive:l,insKey:d,internal:u,rawState:p,sharedState:n,sharedKey:K,proxyState:{},proxyStateVal:{},updater:t,mountStatus:yt,renderStatus:Ne,needEFUpdate:!1,createTime:Date.now(),rootVal:null,ver:y,id:r,globalId:o,collectType:s,canCollect:s!=="no",isFirstRender:!0,subscribe:h=>{h()},extra:{},getDeps:()=>Un(T,!0),renderInfo:{setDraft:u.insSetDraft,time:Date.now(),sn:0,snap:b,insKey:d,getDeps:()=>Un(T,!0),getPrevDeps:()=>Un(T,!1)},recordDep:(h,D,S)=>{let m=h.depKey;wo(h,{stopDepInfo:A,level1ArrKeys:v,recordCb:Ae=>{m=Ae}});const{renderStatus:I,fixedDepKeys:Y}=T;if(I===fn)return;const{readMap:U,insKey:xt,currentDepKeys:qe,delReadMap:Qe}=T;Ie([m],{}),Ki()&&(J(qe,m),w(T.fixedDepKeys,m));const Lt=()=>{U[m]=1,u.recordDep(m,xt),Y.includes(m)||w(qe,m)};if(!U[m]&&!Qe[m]){const{parentKeyPath:Ae}=h;if(a&&D===gt&&Ae){const ie=Ae.length?$(Ae,K):M;U[ie]&&(delete U[ie],Qe[ie]=1,J(qe,ie))}const et=Mo(D);if(et){f&&Lt();return}(!S||!et&&i)&&Lt()}}};if(o&&Lo(o,d),Yo(T),u.mapInsCtx(T,d),u.recordId(r,d),O(c)){const h=_?T.proxyState.val:T.proxyState,D=H(c,h),S=T.getDeps().slice();D.includes(h)&&S.push(u.rootValKey),T.fixedDepKeys=S}return T}function Ho(e){const{result:t,forAtom:n}=e;e.proxyResult=me(t,{set:()=>(Te("changing derived result is invalid"),!1),get:(r,o)=>ft===o?n:(Ne===e.renderStatus&&Cn(e),t[o])})}function Qi(e){const{proxyState:t,internal:n,renderInfo:r,canCollect:o,isReactive:s}=e,{sharedKey:c,sharedKeyStr:a,insSetState:i,forAtom:l}=n;r.snap=n.snap,r.time=Date.now();const f=l?t.val:t;return e.isFirstRender&&(e.rootVal=f,Rn.set(e.rootVal,e)),!l&&o&&e.recordDep({depKey:a,keyPath:[],sharedKey:c},gt),[s?t:f,i,r]}function eu(e,t){if(t&&!Ve(e))throw new Error("useAtom only accept atom")}function tu(e){const{ver:t,internal:{ver:n}}=e;t!==n&&(e.ver=n,Yo(e))}function nu(e){e.mountStatus=ht;const{id:t,globalId:n,insKey:r}=e;e.internal.recordId(t,r),Lo(n,r),Xi(e)}function ru(e){e.mountStatus=zr;const{id:t,globalId:n,insKey:r}=e;e.internal.delId(t,r),Ui(n,r),Uo(e)}function ou(e,t){const n=B(t).sharedKey;return e.internal.sharedKey!==n}function Mt(e,t,n,r){if(V().isRootRender)try{const o=r||n;e.react.useSyncExternalStore(t,n,o)}catch(o){console.error(o)}}var su=null;function Go(e,t,n){const{hookImpl:r,react:o}=e,s=r.useForceUpdate(),c=o.useRef({ctx:su});let a=c.current.ctx;return(!a||ou(a,t))&&(a=qi(F({updater:s,sharedState:t},n)),c.current.ctx=a),a}function $o(e,t){e.react.useEffect(()=>(t.isFirstRender=!1,Rn.del(t.rootVal),t.collectType==="first"&&(t.canCollect=!1),t.needEFUpdate&&(t.needEFUpdate=!1,t.updater()),nu(t),()=>{ru(t)}),[t])}function cu(e,t,n,r){n.renderStatus=Ne,Ji(n),Mt(e,n.subscribe,()=>B(t).snap),e.react.useEffect(()=>{n.renderStatus=fn,n.isFirstRender=!1,zi(n)})}function Bn(e,t,n={}){const r=Go(e,t,n);return Mt(e,r.subscribe,()=>B(t).snap),$o(e,r),r}function bt(e,t,n={}){const{forAtom:r}=n;eu(t,r);const o=Go(e,t,n);return cu(e,t,o,n),$o(e,o),tu(o),{tuple:Qi(o),insCtx:o}}function jo(e,t){const{forAtom:n,label:r,strict:o=!1}=t||{};let s;if(typeof e=="number"?s=Ye(e):s=B(e),!s&&e){const a=e[Wr];s=Ye(a==null?void 0:a.sharedKey)}let c=r?`[[${r}]] err:`:"err:";if(!s)if(o)le(`${c} not a valid shared or atom`,{throwErr:!0});else return null;return n!==void 0&&(n&&!s.forAtom&&le(`${c} expect a shared but recived a atom`,{throwErr:!0}),!n&&s.forAtom&&le(`${c} expect a atom but recived a shared`,{throwErr:!0})),s}function ve(e,t){return jo(e,N(F({},t||{}),{strict:!0}))}var{MUTATE:au,LOADING:iu}=G,{GLOGAL_LOADING:uu,PRIVATE_LOADING:lu}=q,{PRIVATE:fu,GLOBAL:du}=un,Wo={},pu={},yu={time:0,sn:0,getDeps:Re,getPrevDeps:Re,insKey:0,setDraft:C},hu=[Se(Wo,pu,au),C,yu];function mu(e,t){const{internal:n,apiCtx:r}=t,{mutateFnDict:o,moduleName:s}=n,c={};Object.keys(o).forEach(l=>{c[l]={loading:!1,err:null,ok:!0}});const a=s?`${s}@Loading`:"";return e({apiCtx:r,rawState:c,isLoading:!0,stateType:lu},{moduleName:a}).state}var Xo=null;function gu(){return Xo}function zo(){return V().globalLoadingInternal}function Eu(e,t){const n=V();let r=n.globalLoading;if(!r){const{stateRoot:o}=t({apiCtx:e,rawState:{},stateType:uu},{moduleName:Ta}),s=B(o);n.globalLoadingInternal=s,n.globalLoading=o}return Xo=r,r}function Yn(e,t){let n=t;return Ut(t)&&(n=t.toString()),`${e}>${n}`}function Jo(e,t,n){if(!t)return;const{loadingInternal:r}=e;r.innerSetState(o=>{o[t]=n},{from:iu}),n.err&&(so(e,an.ON_ERROR_OCCURED,{err:n.err}),console.error(n.err))}function Se(e,t,n){let r=e[n];return r||(r=me(t,{get(o,s){const c=Yn(n,s);return o[c]||{loading:!1,ok:!0,err:null}}}),e[n]=r),r}function Je(e,t){const{internal:n,from:r}=t,{stateType:o,recordLoading:s}=n,c=q.USER_STATE===o;let a=Se(Wo,{},r),i={};if(c)if(fu===s)i=n.extra.loadingProxy,i||(i=mu(e,t),n.extra.loadingProxy=i,n.loadingInternal=B(i)),a=Se(n.extra,i,r);else if(du===s){const l=zo();i=gu(),n.loadingInternal=l,a=Se(l.extra,i,r)}else i=xn();else i=n.sharedState,a=Se(n.extra,i,r);return{loadingState:a,loadingProxy:i}}function Zo(e,t){if(!Ee(t))return e;const n=Object.keys(t);if(!n.length)return e;const r=t[n[0]];return r.__sharedKey?N(F({},e),{internal:ve(r.__sharedKey)}):e}function qo(e,t){const{internal:n,from:r,apiCtx:o}=t,{stateType:s}=n,c=q.USER_STATE===s;Je(e,t);let a=()=>hu;return c&&(a=i=>{const l=Zo(t,i),f=Je(e,l).loadingProxy,{insCtx:{proxyState:u,internal:d,extra:p,renderInfo:E}}=bt(o,f);return[Se(p,u,r),d.setState,E]}),{useLoading:a,getLoading:i=>{const l=Zo(t,i);return Je(e,l).loadingState}}}function It(e){const t=mo();return Object.assign(t,e||{})}function we(){const e=L(),{runningFnKey:t}=e;if(!t)return[];const n=ge(t);let r=[];if(n){const{depKeys:o}=e,{depKeys:s}=n,c={};o.forEach(i=>c[i]=1),o.forEach(i=>{const l=pr(c,i);l&&l!==i&&delete c[l]}),Object.keys(c).forEach(i=>w(s,i)),r=s.slice()}return e.runningFnKey="",e.depKeys=[],e.runningSharedKey=0,r}function Qo(e,t){const n=L();n.runningFnKey=e,n.runningSharedKey=t,n.isIgnore=!1}function es(e,t){const{specificProps:n,fnCtxBase:r}=t,{scopeType:o}=n,s=Do(e,o),c=F({fn:e,fnKey:s},n),a=r?Object.assign(r,c):It(c);return Mn(o).set(s,a),a}function Hn(e){var o;const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=L(),{fnKey:r}=e;On(e),e.extra.deferedWatch=null,t.delete(r),((o=n.get(r))==null?void 0:o.c)===2&&n.delete(r),ki()}function ts(e){const{DEPKEY_COMPUTING_FNKEYS_MAP:t}=L(),{prevLevelFnKeys:n,depKeys:r}=e;let o=!1;for(const s of r){const c=t.get(s)||[];if(tt(c,n)){o=!0;break}}return o}function vu(e,t=!0,n=be){return e.map(r=>{const[o,s]=r.split("/"),c=s.split(be);return`${t?`${Ye(Number(o)).usefulName}/`:""}${c.join(n)}`})}var wt=new Map,Ft={WATCH:"1",MUTATE:"2"},Su={[Ft.WATCH]:"watch",[Ft.MUTATE]:"mutate fn or task"};function _u(e=0){return{sn:e,descs:[],errs:[],timer:null,cycle:[]}}function ns(e,t,n){const r=new Error(`DEAD_CYCLE: module(${e}) found mutate fn(${n}) in these dead cycle fns [${t.join(",")}]`);return r.cause="DeadCycle",r.data=t,r}function Au(e){wt.delete(e)}function Du(e,t,n,r){const o=Su[r],{desc:s,task:c,fn:a,isFake:i}=t.subFnInfo,l=s?`(${s})`:"",f=`DEAD_CYCLE: found reactive object in ${o}${l} cb is changing module(${e.usefulName})'s some of these dep keys(${vu(n,!1,".")}), it will cause a infinity loop call!`,u=i?t.fn:c||a;return{err:new Error(`[only-dev-mode alert] ${f}`),tipFn:()=>console.error(` ${f} open the stack to find the below fn: 
`,u)}}function Ku(e,t,n){if(e&&n){const{usefulName:r}=e,o=nt(wt,r,_u(t));o.sn!==t&&(o.descs=[],o.errs=[]);const{descs:s}=o;if(s.length>1&&s[0]===n){const c=s.slice();throw o.cycle=c,s.length=0,ns(r,c,n)}w(s,n)}}function Gn(e,t){t.tipFn(),le(t.err,{logErr:!1,throwErr:!1,alertErr:e.alertDeadCycleErr})}function _e(e,t,n){const{depKeys:r,subFnInfo:o}=t;let s=t.depKeys,c=n;r.length>n.length&&(s=n,c=r);let a=!1;if(tt(s,c)){const i=o.desc?Ft.MUTATE:Ft.WATCH,l=Du(e,t,n,i);Gn(e,l),t.dcErrorInfo=l,a=!0}return a}function Ru(e,t){const n=wt.get(e);return!n||!n.cycle.includes(t)?{isIn:!1,cycle:[]}:{isIn:!0,cycle:n.cycle}}function Tu(e,t,n=!0){const r=wt.get(e);if(!r)return;const{timer:o,errs:s}=r;s.push(t),o&&clearTimeout(o),r.timer=setTimeout(()=>{let c=null;for(const a of s)c?a.data.length>c.data.length&&(c=a):c=a;c&&le(c,{alertErr:n}),s.length=0},0)}function $n(e,t=0){const n=ge(e);n&&(n.showLoading&&(n.setLoading(!0),n.updater()),t&&(n.remainRunCount+=t))}var{MAY_TRANSFER:Mu}=mt;function bu(e,t){const{isFirstCall:n=!1,triggerReasons:r=[],sn:o=0,from:s,internal:c=vo,desc:a,fromFnKey:i}=t;if(e.dcErrorInfo.err){Gn(c,e.dcErrorInfo);return}if(e.fnKey===i){_e(c,e,e.depKeys);return}if(e.isSimpleWatch||!e.checkDeadCycle)return e.fn({isFirstCall:n,triggerReasons:r,sn:o});if(G.MUTATE===s&&Ku(c,o,a),e.isRunning&&_e(c,e,t.depKeys||[]))return;const l=ce.current();if(l.fnKey===e.fnKey&&_e(c,e,l.writeKeys)||(ze(l.sharedKey,l.desc),e.isRunning===!0&&l.isTop&&_e(c,e,l.writeKeys)))return;e.isRunning=!0,Ge.set(e.fnKey);const u=e.fn({isFirstCall:n,triggerReasons:r,sn:o});Ge.del();const d=ce.current();if(!(d.isTop&&d.fnKey===e.fnKey&&_e(c,e,d.writeKeys))&&!(u&&u.task&&d.from===G.MUTATE&&_e(c,e,e.subFnInfo.writeKeys)))return e.isRunning=!1,u}function Ze(e,t={}){const{isFirstCall:n=!1,forceFn:r=!1,forceTask:o=!1,throwErr:s=!1,triggerReasons:c=[],sn:a=0,err:i,unbox:l=!1,internal:f=vo}=t,u=ge(e),d=(S=null)=>{if(S&&s)throw S;const m=u||So;return l?[m.result.val,S]:[m.result,S]};if(!u)return d(new Error(`not a valid watch or derive cb for key ${e}`));if(u.fnType===Jr)return bu(u,t);const{isAsync:p,fn:E,task:y,isAsyncTransfer:g,forAtom:v,result:_,depKeys:K}=u;u.remainRunCount>0&&(u.remainRunCount-=1);const M=S=>{const m=v?{val:S}:S;!u.returnUpstreamResult&&m&&Object.assign(u.result,m),u.shouldReplaceResult=!0},b=()=>{u.renderInfo.sn=a,u.updater()},A=S=>{const{data:m,err:I=null}=S;I?u.setLoading(!1,I):(M(m),n?p&&u.status.loading&&!ts(u)&&u.setLoading(!1,I):u.remainRunCount===0&&u.setLoading(!1,I)),b(),u.nextLevelFnKeys.forEach(Y=>{Ze(Y,{isFirstCall:n,sn:a,triggerReasons:c,err:I})})},T=v?_.val:_,R=H(u.deps),h={isFirstCall:n,prevResult:T,triggerReasons:c,input:R,sn:a};if(!p||r||p&&!y){const S=E(h);return A({data:S}),d()}if(p&&n&&u.nextLevelFnKeys.forEach(S=>$n(S,0)),g)return A({err:i}),d();if(u.asyncType===Mu){const S=E(h);return A({data:S}),d()}if(y){let S=yc;return n?(K.forEach(m=>Si(m,e)),S=()=>K.forEach(m=>_i(m,e))):o&&u.nextLevelFnKeys.forEach(m=>$n(m)),Promise.resolve(()=>{const m=y(h);return Bt(m)?m:(le("ERR_NON_FN: derive task arg should be async function!",{throwErr:s}),null)}).then(m=>m()).then(m=>(S(),A({data:m}),d())).catch(m=>{if(S(),A({err:m}),s)throw m;return co(f,m),d(m)})}return d(i)}function Ct(e,t){const n=We(e);if(!n)throw new Error("[Helux]: not a derived result");return Ze(n.fnKey,F({},t||{}))}function Iu(e,t){return Ct(e,{forceFn:!0,throwErr:t})}function wu(e,t){return Promise.resolve(Ct(e,{forceTask:!0,throwErr:t}))}function Fu(e,t){return Ct(e,{forceFn:!0,throwErr:t,unbox:!0})}function Cu(e,t){return Promise.resolve(Ct(e,{forceTask:!0,throwErr:t,unbox:!0}))}function Ou(e){const t=We(e);return t?t.status:{loading:!1,err:null,ok:!0}}function jn(e,t,n){const r=e.get(t);r&&(r.renderInfo.sn=n,Zi(r))}function Pu(e){const{mutateCtx:t,internal:n}=e,{ids:r,globalIds:o,depKeys:s,triggerReasons:c,isFirstCall:a,from:i,sn:l,desc:f,fnKey:u}=t,{key2InsKeys:d,id2InsKeys:p,insCtxMap:E,rootValKey:y}=n;let g=[],v=[],_=[],K=[];const M={};if(a){const A=we();je.set(A)}const b=A=>{if(!Rt(n,A))return;const T=d[A]||[],R=[];for(const S of T){if(g.includes(S))continue;const m=E.get(S);if(!m)continue;const I=m.getDeps();if(I[0]===y){Rt(n,y)&&R.push(S);continue}Fo(n,I,A)&&R.push(S)}g=g.concat(R);const{firstLevelFnKeys:h,asyncFnKeys:D}=Pi(n,A,M);_=_.concat(h),K=K.concat(D)};if(s.forEach(A=>b(A)),s.includes(y)||b(y),Oi(),r.forEach(A=>{g=g.concat(p[A]||[])}),o.forEach(A=>{Ln(A).forEach(T=>w(v,T))}),g=De(g),_=De(_),K=De(K),K.forEach(A=>$n(A,M[A])),_.forEach(A=>Ze(A,{depKeys:s,sn:l,from:i,triggerReasons:c,internal:n,desc:f,isFirstCall:a,fromFnKey:u})),g.forEach(A=>jn(E,A,l)),v.length){const A=Vi().insCtxMap;v.forEach(T=>jn(A,T,l))}}function ku(e){const{state:t,internal:n,mutateCtx:r}=e,{rawState:o,isDeep:s,ver:c,snap:a}=n;s?(n.prevSnap=c===0?F({},a):a,n.snap=t,Object.assign(o,t)):n.snap=F({},o),n.ver+=1,n.sn=r.sn,Pu(e)}var{MUTATE:xu}=G;function rs(e,t){const{writeKey:n,ids:r,internal:o,opParams:s}=t,{snap:c}=o,{fullKeyPath:a,value:i}=s;Object.keys(e).forEach(l=>{n.startsWith(l)&&fe(c,a)!==i&&e[l].forEach(f=>w(r,f))})}function os(e,t){const{isChanged:n,fullKeyPath:r,keyPath:o,parentType:s,value:c}=e,{internal:a,mutateCtx:i}=t,{arrKeyDict:l,isReactive:f,readKeys:u}=i,{sharedKey:d}=a,p=Mo(s),E=ce.current();if(e.op==="get"){p&&(l[$(o,d)]=1);const m=$(r,d);u[m]=1,i.enableDep&&(i.onRead&&i.onRead(e),E.onRead?E.onRead(e):(Dt().fnCtx&&Ie([m],{sharedKey:d}),f&&(wn([m]),Pn(d,c,a.sharedState,m,r))));return}if(!n)return;const{moduleName:y,ruleConf:g,level1ArrKeys:v}=a,{writeKeyPathInfo:_,ids:K,globalIds:M,writeKeys:b}=i,A=$(r,d);if(E.key&&(E.isTop?w(E.writeKeys,A):E.from===xu&&w(bn(E.fnKey).subFnInfo.writeKeys||[],A)),p){const m=$(o,d);_[m]={sharedKey:d,moduleName:y,keyPath:o},b[m]=1}const{hasIds:T,hasGlobalIds:R,stopDepInfo:h}=g;_[A]={sharedKey:d,moduleName:y,keyPath:r};const D=pr(l,A);D&&(b[D]=1),wo({sharedKey:d,keyPath:r,depKey:A},{stopDepInfo:h,level1ArrKeys:v,recordCb:m=>{b[m]=1}})||(b[A]=1),T&&rs(g.idsDict,{ids:K,writeKey:A,internal:a,opParams:e}),R&&rs(g.globalIdsDict,{ids:M,writeKey:A,internal:a,opParams:e}),f?ji(d,E.desc):$i(d)}function ss(e,t){Object.keys(t).forEach(n=>{e[n]=t[n]})}function Ot(e,t){if(!t)return e;Fn(!0);const n=e.val;return Fn(!1),n}function cs(e){const{partial:t,forAtom:n,draftRoot:r,draftNode:o}=e;if(!t)return;if(!n){Ee(t)&&ss(o,t);return}const s=t.val;if(Ee(o)){Ee(s)?ss(o,s):console.warn("dict atom deny to handle a non-dict returned value!");return}r.val=s}function Lu(e,t){const{internal:n,mutateCtx:r}=e,o=Ot(t,n.forAtom),{from:s,sn:c,desc:a}=r;n.before({from:s,draftRoot:t,draft:o,desc:a,sn:c}),Ya(n,t,o,c)}function as(e,t,n,r){const{mutateCtx:o,internal:s}=e,{writeKeys:c,writeKeyPathInfo:a,handleCbReturn:i}=o,{forAtom:l}=s;i&&cs({partial:r,forAtom:l,draftRoot:t,draftNode:n}),Lu(e,t),o.depKeys=Object.keys(c),At.del(),Tn.del(),e.state=cn(t),e.state!==s.rawState&&(o.triggerReasons=Object.values(a),ku(e),ja(s,o))}function is(e,t){const{ids:n,globalIds:r,from:o,desc:s,fnKey:c}=t;n&&n.forEach(a=>w(e.ids,a)),r&&r.forEach(a=>w(e.globalIds,a)),o&&(e.from=o),s&&(e.desc=s),c&&(e.fnKey=c)}function Nu(e){const{internal:t,setFactoryOpts:n}=e,{forAtom:r,rawState:o}=t,s=hn(n),c=sn(o,{customKeys:dt,onOperate:i=>{if(i.isCustom)return kn(i,r,t.sharedKey);os(i,{internal:t,mutateCtx:s})}});At.set(c,r),Tn.set(s);const a=Ot(c,r);return r&&(s.readKeys={}),{draftRoot:c,draftNode:a,finishMutate(i,l={}){is(s,l),as({state:{},mutateCtx:s,internal:t},c,a,i)}}}function Vu(e){return ao(e),ri(e)}function Uu(e){if(!e)return{};const{desc:t,ids:n,globalIds:r}=e;return{desc:t,ids:n,globalIds:r}}function Bu(e){const{forAtom:t=!1}=e;let n=e.rawState;const r=O(n);let o=!1;if(t)n=r?{val:n()}:{val:n},o=!n.val||!dr(n.val);else{if(n=r?n():n,!j(n))throw new Error("ERR_NON_OBJ: pass an non-object to createShared!");if(se(n))throw new Error("ERR_ALREADY_SHARED: pass a shared object to createShared!")}return{isPrimitive:o,rawState:n}}function us(e,t,n){let r=null,o=t||"";if(O(e)&&e!==C)r={[jr]:1,fn:e,deps:Re,oriDesc:o,onlyDeps:!1,desc:o,depKeys:[],writeKeys:[],checkDeadCycle:void 0,watchKey:"",isFake:!1,enabled:!0};else if(j(e)){const{fn:s,desc:c,deps:a,task:i,immediate:l,checkDeadCycle:f,onlyDeps:u=!1}=e,d=t||c||"",p=O(s)?s:void 0,E=O(i)?i:void 0,y=O(a)?a:Re;(s||i)&&(r={[jr]:1,checkDeadCycle:f,fn:p,watchKey:"",desc:d,oriDesc:d,deps:y,task:E,onlyDeps:u,immediate:l,depKeys:[],writeKeys:[],isFake:!1,enabled:!0})}if(r&&n){const{oriDesc:s}=r;(!s||n[s])&&(r.desc=yn(G.MUTATE))}return r}function ls(e,t,n=!0){const r={},o=t||{};if(!e)return r;const s=(c,a)=>{const i=us(c,a,o);i&&(i.enabled=n,r[i.desc]=i,o[i.desc]=i)};if(Array.isArray(e))if(e.length===1){const c=e[0],a=(j(c)?c.desc:"")||pt;s(e[0],a)}else e.forEach(c=>s(c));else O(e)?s(e,pt):j(e)&&Object.keys(e).forEach(c=>{s(e[c],c)});return r}function Yu(e,t={}){var R,h,D,S,m;const{forAtom:n=!1,forGlobal:r=!1,stateType:o=q.USER_STATE}=e,{rawState:s,isPrimitive:c}=Bu(e),a=Vu(s),i=t.moduleName||"",l=(R=t.alertDeadCycleErr)!=null?R:ue(),f=(h=t.deep)!=null?h:!0,u=(D=t.checkDeadCycle)!=null?D:!0,d=(S=t.enableMutate)!=null?S:!0,p=t.recordLoading||un.PRIVATE,E=t.rules||[],y=t.before||C,g=t.mutate||C,v=(m=t.stopArrDep)!=null?m:!0,_=t.stopDepth||Ma,K=`${a}`,M=n?`${a}/val`:K,b=i||K,A=Ti(i),T=ls(g,{},d);return{isDestroyed:!1,alertDeadCycleErr:l,checkDeadCycle:u,rawState:s,sharedKey:a,sharedKeyStr:K,rootValKey:M,moduleName:i,usefulName:b,forAtom:n,forGlobal:r,loc:A,deep:f,rules:E,before:y,mutate:g,mutateFnDict:T,onRead:null,enableMutate:d,stateType:o,recordLoading:p,stopArrDep:v,stopDepth:_,isPrimitive:c}}function Hu(e){const{rawState:t,sharedKey:n,rootValKey:r,deep:o,rules:s,stopDepth:c,stopArrDep:a,forAtom:i}=e,l={},f={},u={keys:[],isArrDict:{},arrKeyStopDcit:{},depth:c,stopArrDep:a},d={},p=Ht(o);s.forEach(g=>{const v=[],{when:_,ids:K=[],globalIds:M=[],stopDep:b}=g;let A;if(p){let S="";A=it(t,{onOperate:({fullKeyPath:m,value:I,isBuiltInFnKey:Y})=>{if(Y)return;const U=$(m,n);S&&U.includes(S)&&v.pop(),v.push(U),d[U]=Array.isArray(I),S=U}})}else A=me(t,{set:_c,get:(S,m)=>{const I=$([m],n);v.push(I);const Y=S[m];return d[I]=Array.isArray(Y),Y}});const T=i?A.val:A,R=H(_,T),h=(S,m,I)=>{const Y=Oe(S,I,[]);m.forEach(U=>w(Y,U))},D=S=>{h(l,K,S),h(f,M,S);let m;d[S]?(m=b!=null?b:ba,u.arrKeyStopDcit[S]=m,u.isArrDict[S]=d[S]):m=b!=null?b:!1,m&&w(u.keys,S)};v.forEach(D),R.includes(T)&&D(r)});const E=Object.keys(l).length>0,y=Object.keys(f).length>0;return{hasIds:E,idsDict:l,hasGlobalIds:y,globalIdsDict:f,stopDepInfo:u}}function Gu(e){const{desc:t=pt,strict:n=!1,throwErr:r=!1}={};return typeof e=="string"?{desc:e,strict:n,throwErr:r}:N(F({desc:t,strict:n},e),{throwErr:r})}function fs(e){var r;let t=C,n=!1;return O(e)?t=e:j(e)&&(t=e.deps||C,n=(r=e.immediate)!=null?r:!1),{immediate:n,deps:t}}function $u(e){return e?typeof e=="boolean"?{enableStatus:e}:j(e)?e:{}:{}}function ju(e){Array.isArray(e)&&e.forEach(t=>{const n=Rn.current(t),r=B(t)||(n==null?void 0:n.internal);if(r){const{depKey:o,sharedKey:s}=To(r);Ie([o],{sharedKey:s})}n&&n.recordDep(To(r))})}function Pt(e,t){const{scopeType:n,fnCtxBase:r,immediate:o,deps:s=C,label:c="watch",sharedState:a,isSimpleWatch:i}=t;if(!O(e))throw new Error(`ERR_NON_FN: pass an non-function to ${c}!`);const l=es(e,{specificProps:{scopeType:n,fnType:Jr,isSimpleWatch:i},fnCtxBase:r});Qo(l.fnKey,se(a));const f=s()||[];return ju(f),o&&e({isFirstCall:!0}),we(),l}function Wu(e,t){const{deps:n,immediate:r}=fs(t),o=Pt(e,{scopeType:re.STATIC,deps:n,immediate:r});return{run:s=>Ze(o.fnKey,{throwErr:s}),unwatch:()=>On(o)}}var ds=()=>{},Wn=new Map;function ps(e,t){const{forAtom:n,rawState:r}=e;return n?H(t.deps,r.val):H(t.deps,r)}function Xu(e){var t;return(t=Wn.get(e))!=null?t:!1}function Xn(e,t){const{sn:n,getArgs:r=C,from:o,throwErr:s,isFirstCall:c,fnItem:a,mergeReturn:i}=t,{desc:l="",depKeys:f,task:u=ds}=a,d=B(e),{sharedKey:p}=d,E={desc:l,sn:n,from:o},y=Yn(o,l),{draft:g,draftRoot:v}=Vn(d,{depKeys:f,desc:l,from:o}),_=m=>{ze(p,m)},K=m=>{_(l);const{finish:I}=d.setStateFactory(E);return I(m)},M=G.MUTATE===o?ps(d,a):[],b={isFirstCall:c,desc:l,setState:K,input:M,draft:g,draftRoot:v,flush:_},A=r(b)||[b],T=Wn.get(u),R=T===void 0,h=(m,I,Y)=>{(R||T)&&Jo(d,y,{loading:m,err:I,ok:Y})};h(!0,null,!1);const D=m=>{if(je.del(),h(!1,m,!1),s)throw m;return{snap:d.snap,err:m,result:null}},S=m=>(i&&m&&K(m),h(!1,null,!0),_(l),{snap:d.snap,err:null,result:m});try{const m=u(...A),I=Bt(m);return Wn.set(u,I),I?Promise.resolve(m).then(S).catch(D):S(m)}catch(m){return D(m)}}function ys(e,t){const{sn:n,getArgs:r=C,from:o,throwErr:s,isFirstCall:c=!1,fnItem:a}=t,{desc:i="",watchKey:l,fn:f=ds}=a,u=G.MUTATE===o;u&&Ge.set(l);const d=B(e),{setStateFactory:p,forAtom:E,sharedState:y}=d,v={desc:i,sn:n,from:o,isFirstCall:c,enableDep:u&&c},_=h=>{const{finish:D}=p(v);return D(h)},K=Ot(y,E),M=u?ps(d,a):[],{draftNode:b,draftRoot:A,finish:T}=p(v),R=r({isFirstCall:c,draft:b,draftRoot:A,setState:_,desc:i,input:M})||[b,{input:M,state:K,draftRoot:A,isFirstCall:c}];try{const h=bn(a.watchKey);if(h.dcErrorInfo.err)return Gn(d,h.dcErrorInfo),{snap:d.snap,err:null,result:null};const D=f(...R);return T(D,{fnKey:h.fnKey}),hs(d,a,c),{snap:d.snap,err:null,result:null}}catch(h){if(hs(d,a,c),s)throw h;return{snap:d.snap,err:h,result:null}}}function hs(e,t,n){n&&!t.onlyDeps&&(Dt().fnCtx?t.depKeys=we():t.depKeys=je.current(),je.del());const r=ce.current();r.isTop&&r.fnKey===t.watchKey&&_e(e,bn(t.watchKey),r.writeKeys),Ge.del()}function zu(e,t){var r;Gi(),je.del(),Fn(!1);const n=Dt().fnCtx;n&&(n.subFnInfo=t,n.checkDeadCycle=(r=t.checkDeadCycle)!=null?r:e.checkDeadCycle,t.watchKey=n.fnKey),t.onlyDeps&&(t.depKeys=we())}function zn(e){const{target:t,dict:n}=e,r=Object.keys(n);if(!r.length)return;const o=B(t),{mutateFnDict:s,usefulName:c,forAtom:a,sharedState:i}=o,l=f=>co(o,f);r.forEach(f=>{const u=s[f];Pt(({sn:d,isFirstCall:p})=>{if(p&&zu(o,u),!o.enableMutate)return;const{desc:E,fn:y,task:g,immediate:v}=u,_=Ru(c,E);try{if(_.isIn)throw ns(c,_.cycle,E);const K={sn:d,throwErr:!0,isFirstCall:p,fnItem:u,from:G.MUTATE};if(y&&(p||!g)&&ys(t,K),g){p&&(u.depKeys=we());const M=p&&(v!=null?v:!y);(!p||M)&&Xn(t,K).catch(l)}return u}catch(K){K.cause==="DeadCycle"&&Tu(c,K,o.alertDeadCycleErr),l(K)}},{deps:()=>u.deps?u.deps(Ot(i,a))||[]:[],sharedState:t,scopeType:re.STATIC,immediate:!0})})}var{ACTION:ms}=G;function Ju(e,t){const{label:n,throwErr:r,desc:o="",task:s,mergeReturn:c=!0}=t,a=ve(e,{label:n}),{forAtom:i}=a,l=(f,u)=>{const d=u!=null?u:r,p=mn({desc:o,task:s,depKeys:[]}),E=(y,g)=>y.__action?y.__action(g):y(g);return Xn(e,{fnItem:p,from:ms,mergeReturn:c,throwErr:d,getArgs:({draft:y,draftRoot:g,setState:v,desc:_,flush:K})=>[{draft:y,draftRoot:g,setState:v,desc:_,payload:f,flush:K,merge:b=>{cs({partial:b,forAtom:i,draftRoot:g,draftNode:y})},dispatch:E}]})};return Jo(a,Yn(ms,o),{loading:!1,ok:!0,err:null}),l.__sharedKey=a.sharedKey,l.__fnName=o,l.__task=s,s.__action=l,l}function gs(e){return t=>(n,r="",o)=>Ju(e,{task:n,desc:r,label:"action",mergeReturn:t,throwErr:o})}var{TASK:Es}=mt,{STATIC:Zu,HOOK:qu}=re;function vs(e,t,n){if(!n&&(!j(t)||Bt(t)))throw new Error("ERR_NON_OBJ: derive,deriveAsync expect result to be a plain object");const{isAsync:r,isAsyncTransfer:o}=e;if(r&&!o){const s=Ko(t),c=se(t);if(s&&e.fnKey!==s||c)throw new Error("ERR_INVALID_CALL: derive,deriveAsync can not transfer another derived result or shared state, it will cause wrong result")}}function Qu(e,t){const n=me(e.result,{set:()=>(Te("changing derived result is invalid"),!1),get:(r,o)=>{if(o===ft)return t;const s=r[o];return Ie(e.depKeys,{belongCtx:e}),wn(e.depKeys,n),Pn(0,s,n,"",[o],!0,t),s}});return e.proxyResult=n,n}function Ss(e,t){const{result:n,isUpstream:r}=t,o=We(n);o&&(e.depKeys=De(e.depKeys.concat(o.depKeys)),w(o.nextLevelFnKeys,e.fnKey),w(e.prevLevelFnKeys,o.fnKey),e.isFirstLevel=!1,r==null||r())}function el(e){var M,b;const{scopeType:t=Zu,fnCtxBase:n,isAsyncTransfer:r=!1,asyncType:o=Es,returnUpstreamResult:s,runAsync:c=!0,forAtom:a=!1,immediate:i}=e;if(!O(e.fn))throw new Error("ERR_NON_FN: derive need fn arg!");const{fn:l=C,deps:f=C,task:u}=e,d=A=>{const T=H(f);return A.isFirstCall&&T.forEach(R=>Ss(y,{result:R})),l(N(F({},A),{input:T}))},p=(M=e.isAsync)!=null?M:O(u),E=(b=e.showLoading)!=null?b:p,y=es(d,{specificProps:{forAtom:a,scopeType:t,fnType:wa,task:u,deps:f,isAsync:p,asyncType:o,isAsyncTransfer:r,showLoading:E},fnCtxBase:n});Qo(y.fnKey,0);let g=d({isFirstCall:!0,prevResult:null,triggerReasons:[]});we();const v=We(g);a&&!v&&(g={val:g,z__is_atom_result__:!0});const _=y.fnKey;vs(y,g),Ss(y,{result:g,isUpstream:()=>{y.returnUpstreamResult=s!=null?s:!p}}),Cn(y),y.returnUpstreamResult||Do(g,t,_);const K=c&&o===Es&&(i!=null?i:!e.fn);return u&&K&&Ze(_,{isFirstCall:!0,sn:y.renderInfo.sn+1}).then(A=>{vs(y,A[0],a)}).catch(A=>le(A)),y.result=g,t===qu&&ts(y)&&y.setLoading(!0),y.returnUpstreamResult?y.proxyResult=g:Qu(y,a),y}function Jn(e,t){const n=O(e)?{fn:e}:e||{};return el(F(F({},t||{}),n))}function _s(e){return Jn(e,{forAtom:!0}).proxyResult}function tl(e){return Jn(e).proxyResult}function nl(e){return t=>N(F({},t),{deps:e})}function rl(e){return e}var kt=e=>[e.snap,e.err];function Zn(e){const{target:t,desc:n="",forTask:r=!1,throwErr:o}=e,{mutateFnDict:s,snap:c}=B(t),a=n||pt,i=s[a];if(!i)return{snap:c,err:new Error(`mutate fn ${a} not defined`),result:null};if(r&&!i.task)return{snap:c,err:new Error(`mutate task ${a} not defined`),result:null};const l={sn:0,fnItem:i,from:G.MUTATE,throwErr:o};return r?Xn(t,l):ys(t,l)}function As(e,t,n,r){return{run:o=>{const s=Zn({target:e,desc:t,throwErr:o});return kt(s)},runTask:o=>Promise.resolve(Zn({target:e,desc:t,forTask:!0,throwErr:o})).then(kt),desc:t,oriDesc:n,getSnap:()=>r.snap,snap:r.snap,__sharedKey:r.sharedKey}}function ol(e){const{target:t,fnItem:n,label:r}=e,o=ve(t,{label:r}),s=us(n,"",o.mutateFnDict);if(!s)throw new Error("not a fn or fnItem { fn }");o.mutateFnDict[s.desc]=s,s.enabled=o.enableMutate;const c={[s.desc]:s};return o.enableMutate&&zn({target:t,dict:c}),As(t,s.desc,s.oriDesc,o)}function sl(e){const{target:t,fnDict:n,label:r}=e,o=ve(t,{label:r}),s=ls(n,o.mutateFnDict,o.enableMutate);o.enableMutate&&zn({target:t,dict:s});const c={};return Object.keys(s).forEach(a=>{c[a]=As(t,a,a,o)}),c}function cl(e,t){const{label:n,descOrOptions:r,forTask:o=!1}=t,{desc:s,strict:c,throwErr:a}=Gu(r);return s?jo(e,{label:n,strict:c})?{ok:!0,desc:s,forTask:o,throwErr:a,err:null}:{ok:!1,desc:s,forTask:o,throwErr:a,err:new Error("not a valid atom or shared result")}:{ok:!1,desc:s,forTask:o,throwErr:a,err:new Error("miss desc")}}function Ds(e,t){const{ok:n,desc:r,forTask:o,err:s,throwErr:c}=cl(e,t);if(!n){if(c)throw s;return o?Promise.resolve([e,s]):[e,s]}const a=Zn({target:e,desc:r,forTask:o,throwErr:c});return o?Promise.resolve(a).then(kt):kt(a)}function Ks(e,t){return Ds(e,{descOrOptions:t,label:"runMutate"})}function Rs(e,t){return Ds(e,{descOrOptions:t,label:"runMutateTask",forTask:!0})}function Ts(e){return t=>ol({target:e,fnItem:t,label:"mutate"})}function qn(e){return t=>sl({target:e,fnDict:t,label:"mutateDict"})}function Ms(e,t,n={}){const{tuple:r}=bt(e,t,n);return r}function bs(e,t,n={}){const{tuple:r}=bt(e,t,n),[o,s,c]=r;return N(F({},c),{state:o,setState:s})}var al="ERR_NOT_DERIVED_RESULT: useDerived only accept derived result",il="ERR_NOT_ATOM_RESULT: useDerivedAtom only accept derived atom";function ul(e,t,n){return e.isExpired?(e.isExpired=!1,!0):O(n)?!1:n!==t}function ll(e){Hn(e),e.depKeys.length=0,e.prevLevelFnKeys.length=0,e.renderInfo.sn+=1}function fl(e,t){const{result:n,forAtom:r,showLoading:o}=t,{fnCtx:s,input:c,deriveFn:a}=e;let i=!1;if(a)if(ul(s,c,n))i=!0,ll(s);else return;e.input=n;const l=We(n);if(!l)throw new Error(al);if(r&&!he(n))throw new Error(il);e.deriveFn=()=>l.result,Jn({fn:()=>l.result,deps:()=>[],task:()=>pc(this,null,function*(){return l.result})},{isAsync:l.isAsync,scopeType:re.HOOK,fnCtxBase:s,isAsyncTransfer:!0,runAsync:!1,returnUpstreamResult:!0,forAtom:r,asyncType:mt.MAY_TRANSFER,showLoading:o}),Ho(s),i&&s.updater()}function Is(e,t){const{result:n,forAtom:r}=t,{hookImpl:o,react:s}=e,c=o.useForceUpdate(),{current:a}=s.useRef({input:n,deriveFn:null,fnCtx:null});a.fnCtx||(a.fnCtx=It({updater:c,scopeType:re.HOOK,forAtom:r}));const i=a.fnCtx;return i.renderStatus=Ne,fl(a,t),i}function dl(e,t){t.shouldReplaceResult&&(Ho(t),t.shouldReplaceResult=!1),Mt(e,t.subscribe,()=>Oo(t)),e.react.useEffect(()=>{t.renderStatus=fn})}function ws(e,t){e.react.useEffect(()=>(t.mountStatus=ht,Co(t),()=>{Hn(t)}),[t])}function Qn(e,t){const n=Is(e,t);return Mt(e,n.subscribe,()=>Oo(n)),ws(e,n),n}function pl(e,t){const n=Is(e,t);return dl(e,n),ws(e,n),n}function er(e,t,n){const r=pl(e,F({result:t},n||{})),{proxyResult:o,status:s,renderInfo:c}=r;return[he(t)?o.val:o,s,c]}function Fs(e,t,n){if(t===null)return n;if(!O(t))return null;const{sharedState:r,forAtom:o}=e,s=o?r.val:r,c={};Kn.set(i=>c[i[0]]=1);const a=H(t,s);return Kn.del(),a.includes(s)?e.key2InsKeys:c}function Cs(e,t,n){const r=ve(t),[o]=e.react.useState(()=>Fs(r,n,null));return s=>{const{insCtxMap:c,key2InsKeys:a}=r,i=Fs(r,s,a)||o||a,l={};if(Object.keys(i).forEach(u=>{(a[u]||[]).forEach(p=>l[p]=1)}),Object.keys(l).length){r.sn+=1;const u=r.sn;Object.keys(l).forEach(d=>{jn(c,Number(d),u)})}}}function yl(e,t){or(e);const n=xn();return Bn(e,n,{collectType:"no",globalId:t}).renderInfo}var{ACTION:Os,MUTATE:Ps}=G;function tr(e,t){or(e);const{target:n,from:r="Mutate"}=t||{};let o=zo();n&&(o=ve(n));const{loadingProxy:s,loadingState:c}=Je(ae,{apiCtx:e,internal:o,from:r});return{loadingProxy:s,loadingState:c,internal:o,from:r}}function ks(e,t){const{loadingProxy:n,internal:r,from:o}=tr(e,t),{proxyState:s,extra:c,renderInfo:a}=Bn(e,n);return[Se(c,s,o),r.setState,a]}function hl(e,t){const{loadingProxy:n}=tr(e,{target:t,from:Ps});return n}function ml(e,t){return ks(e,{target:t,from:Ps})}function gl(e,t){const{loadingProxy:n}=tr(e,{target:t,from:Os});return n}function El(e,t){return ks(e,{target:t,from:Os})}function xs(e){return e.hookImpl.useForceUpdate()}function Ls(e,t){const n=(r,o)=>{let s=null;if(O(r)){const c=sn(o),a=r(c);s=cn(c),j(a)&&Object.assign(s,a)}else j(r)&&(s=F(F({},o),r));return s};return e.hookImpl.useObjectLogic(t,n,!0)}function vl(e,t,n){const{useRef:r,useMemo:o,useEffect:s}=e.react,c=r({fn:n,wrap:null});c.current.fn=o(()=>n,[n]),c.current.wrap||(c.current.wrap=(...a)=>{c.current.fn(...a)}),s(()=>{const a=Xa(),i=c.current.wrap;return a.on(t,i),()=>a.off(t,i)},[t,c])}function nr(e,t,n={}){const r=Ve(t),{insCtx:o}=bt(e,t,N(F({},n),{forAtom:r,isReactive:!0}));return[o.proxyStateVal,o.proxyState,o.renderInfo]}function Ns(e,t,n={}){const[r,o,s]=nr(e,t,n);return N(F({},s),{state:r,stateRoot:o})}function Sl(e,t,n){const r=j(n)?n:{};e.react.useEffect(()=>{const{srvRef:o}=r;O(o)&&o(t)},[])}function _l(e,t,n){const r=e.hookImpl.useStable(t);return Sl(e,r,n),r}function Al(e){return t=>e.current=t}var{HOOK:Vs}=re;function Us(e,t){e(()=>{var n,r;return t.mountStatus=ht,Co(t),(r=(n=t.extra).deferedWatch)==null||r.call(n),()=>{Hn(t)}},[t])}function Dl(e,t,n){const{useState:r,useEffect:o}=e.react,[s]=r(()=>It());if(s.fn===C){const{manualDepKeys:c=[]}=n;Pt(t,{scopeType:Vs,fnCtxBase:s,deps:()=>c.map(i=>{const{sharedKey:l,keyPath:f}=Ro(i),u=si(l);return fe(u,f)}),isSimpleWatch:!0})}Us(o,s)}function Kl(e,t,n){const{useRef:r,useState:o,useMemo:s,useEffect:c}=e.react,a=r({fn:t,wrap:null}),[i]=o(()=>It());if(a.current.fn=s(()=>t,[t]),!a.current.wrap){const{deps:l,immediate:f}=fs(n);a.current.wrap=u=>{i.mountStatus===ht?a.current.fn(u):i.extra.deferedWatch=()=>a.current.fn(u)},Pt(a.current.wrap,{scopeType:Vs,fnCtxBase:i,deps:l,immediate:f,label:"useWatch"})}Us(c,i)}function Rl(e){const{internal:t,setFactoryOpts:n}=e,{rawState:r,forAtom:o,stopDepth:s,sharedKey:c}=t,a=hn(n),i=F({},r),l=(p,E,y,g)=>{const v=He(E,y,{parentType:bo(p),parentKeyPath:g});os(v,{internal:t,mutateCtx:a}),hr(i,v.fullKeyPath,y)},f=(p,E,y)=>Ue(p,{set:(g,v,_)=>(l(g,v,_,y),!0),get:(g,v)=>{const _=g[v];if(dt.includes(v))return Tt(E===1,o,c,v,_);const K=He(v,_,{isChanged:!1,parentKeyPath:y,op:"get",parentType:bo(g)});return E<s&&Ee(_)?f(_,E+1,K.fullKeyPath):fe(i,K.fullKeyPath)}}),u=f(i,1,[]);At.set(u,o),Tn.set(a);const d=o?u.val:u;return{draftRoot:u,draftNode:d,finishMutate(p,E={}){is(a,E);const y=F({state:{},mutateCtx:a},e);as(y,u,d,p)}}}function Tl(e){let t=e;if(e){e.persist&&e.persist();const{currentTarget:n}=e;n&&e.type?n.tagName==="INPUT"&&n.type==="checkbox"?t=n.checked:t=n.value:e.nativeEvent&&e.target&&(t=e.target.value)}return t}function Ml(e){let t=[];return{target:bi(e,({fullKeyPath:r})=>{t=r}),getPath:()=>t}}function Bs(e,t,n){return o=>{let s=Tl(o);e(c=>{const{isAtom:a,draftRoot:i}=At.current(),l={draft:c,draftRoot:i,path:t,isAtom:a,UNDEFINED:Ra},f=n==null?void 0:n(s,l);hr(i,t,f!==void 0?f:s)},{from:G.SYNC})}}function rr(e,t){const{sharedKey:n,innerSetState:r}=t;let o=$(e,n),s=Ys.get(o);return s||(s=Bs(r,e),Ys.set(o,s)),s}var Ys=new Map;function Hs(e){const{forAtom:t,rawState:n}=e;return t?dr(n.val)?Ue(n.val,{get:(r,o)=>rr(["val",o],e)}):rr(["val"],e):Ue(n,{get:(r,o)=>rr([o],e)})}var Gs=new Map;function $s(e){const{forAtom:t,sharedKey:n,innerSetState:r,rawState:o}=e,s=Ml(o);return(c,a)=>{let i=[];if(Array.isArray(c))i=t?["val",...c]:c;else{const{target:u,getPath:d}=s;c(t?u.val:u),i=d()}let l=$(i,n);a&&(l+=`${a.toString()}`);let f=Gs.get(l);return f||(f=Bs(r,i,a),Gs.set(l,f)),f}}function bl(e,t){const{deep:n,forAtom:r,sharedKey:o}=t,s=Hu(t),c=Ht(n),a=(g={})=>{const v={internal:y,setFactoryOpts:g},{finishMutate:_,draftRoot:K,draftNode:M}=c?Nu(v):Rl(v);return{finish:(b,A={})=>{const T=y.snap;if(b===T)return T;const R=wi(r,b,M);return _(R,A),y.snap},draftRoot:K,draftNode:M}},i=(g={})=>a(g),l=(g,v={})=>a().finish(g,v),f=(g,v)=>{const[_,K,M]=v;return Nn(e,$e.current(o)),a({handleCbReturn:_,enableDep:K}).finish(g,Uu(M))},y=yo(t,{sharedState:e,setState:(g,v)=>f(g,[!0,!0,v]),setDraft:(g,v)=>f(g,[!1,!0,v]),insSetState:(g,v)=>f(g,[!0,!1,v]),insSetDraft:(g,v)=>f(g,[!1,!1,v]),setStateFactory:i,innerSetState:l,ruleConf:s,isDeep:c});return y.sync=$s(y),y.syncer=Hs(y),ti(e,y),y}function Il(e,t){const n=Yu(e,t),{sharedRoot:r,sharedState:o}=Li(n),s=bl(r,n);ci(r,n),Di(),zn({target:r,dict:n.mutateFnDict});const{draft:c,draftRoot:a}=Vn(s,{isTop:!0});return s.reactive=c,s.reactiveRoot=a,ei(n.moduleName,s.loc),Au(s.usefulName),Wa(s),{sharedRoot:r,sharedState:o,internal:s,parsedOptions:n}}var{USER_STATE:js}=q,{MUTATE:wl,ACTION:Ws}=G;function or(e,t){js===(t||js)&&!xn()&&(Ni(e,ae),Eu(e,ae))}function Xs(e,t){const{createFn:n,ldAction:r,actionDict:o,actionCreator:s,internal:c,apiCtx:a,forTp:i=!1}=e;Je(n,{internal:c,from:Ws,apiCtx:a});const l={},f={};return Object.keys(o).forEach(u=>{const d=o[u],p=i?d.__task:d,E=s(!1)(p,u,t);E.__fnName=u,f[u]=E;const y=(...g)=>{const v=E(...g);return Xu(p)?Promise.resolve(v).then(_=>_.result):v.result};y.__fnName=u,l[u]=y}),{actions:l,eActions:f,getLoading:()=>r.getLoading(l),useLoading:()=>r.useLoading(l)[0],useLoadingInfo:()=>r.useLoading(l)}}function zs(e){const{state:t,ldMutate:n,mutateFnDict:r}=e,o=qn(t)(r);return{witnessDict:o,getLoading:()=>n.getLoading(o),useLoading:()=>n.useLoading(o)[0],useLoadingInfo:()=>n.useLoading(o)}}function Fl(e){const{apiCtx:t,ldMutate:n,inital:r,mutateFnDict:o}=e,[s,,c]=sr(t,r),a=zs({state:s,ldMutate:n,mutateFnDict:o});return F({derivedState:s,useDerivedState:l=>{const[f,,u]=c.useState(l);return[f,u]}},a)}function Cl(e){const{apiCtx:t,deriveFnDict:n,throwErr:r}=e,o={},s={};return Object.keys(n).forEach(a=>{const i=_s(n[a]);o[a]=i,s[a]={runDerive:l=>Fu(i,l!=null?l:r),runDeriveTask:l=>Cu(i,l!=null?l:r),useDerived:l=>er(t,i,l)[0],useDerivedInfo:l=>er(t,i,l)}}),{result:new Proxy(o,{get:(a,i)=>o[i].val}),helper:s}}function Ol(e,t){if(t.enableMutate=e,e){const{mutateFnDict:n}=t,r={};Object.keys(n).forEach(o=>{const s=n[o];s.enabled||(s.enabled=!0,r[o]=s)}),qn(t.sharedState)(r)}}function Pl(e){const{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:i}=e;return{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:i}}function ae(e,t){const{stateType:n,apiCtx:r}=e;or(r,n);const{sharedRoot:o,sharedState:s,internal:c}=Il(e,t),{syncer:a,sync:i,forAtom:l,setState:f,setDraft:u,sharedKey:d,sharedKeyStr:p,rootValKey:E,reactive:y,reactiveRoot:g}=c,v=gs(o),_=v(),K={internal:c,from:wl,apiCtx:r},M=ae,b=qo(M,N(F({},K),{from:Ws})),A=qo(M,K),T={createFn:M,internal:c,apiCtx:r},R=N(F({},T),{ldAction:b,actionCreator:v});return{state:o,stateRoot:o,stateVal:s,setState:f,setDraft:u,setEnableMutate:h=>Ol(h,c),getOptions:()=>Pl(c),setOnReadHook:h=>c.onRead=h,defineActions:h=>D=>Xs(N(F({},R),{actionDict:D}),h),defineTpActions:h=>D=>Xs(N(F({},R),{actionDict:D,forTp:!0}),h),defineMutateDerive:h=>D=>Fl(N(F({},T),{ldMutate:A,inital:h,mutateFnDict:D})),defineMutateSelf:()=>h=>zs({ldMutate:A,state:o,mutateFnDict:h}),defineFullDerive:h=>D=>Cl({apiCtx:r,deriveFnDict:D,throwErr:h}),mutate:Ts(o),runMutate:h=>Ks(o,h),runMutateTask:h=>Rs(o,h),action:v,call:(h,D,S,m)=>_(h,S,m)(D),useState:h=>Ms(r,o,h),useStateX:h=>bs(r,o,h),useForceUpdate:h=>Cs(r,o,h),useLocalState:h=>Ls(r,h),useLocalForceUpdate:()=>xs(r),getMutateLoading:A.getLoading,useMutateLoading:A.useLoading,getActionLoading:b.getLoading,useActionLoading:b.useLoading,getSnap:h=>po(o,h),sync:i,syncer:a,sharedKey:d,sharedKeyStr:p,rootValKey:E,reactive:y,reactiveRoot:g,reactiveDesc:h=>No(o,h),useReactive:h=>nr(r,o,h),useReactiveX:h=>Ns(r,o,h),flush:h=>Nn(o,h),isAtom:l}}function sr(e,t,n){const r=ae({apiCtx:e,rawState:t},n);return[r.state,r.setState,r]}function kl(e,t,n){return ae({apiCtx:e,rawState:t},n)}function xl(e,t,n){const r=ae({apiCtx:e,rawState:t,forAtom:!0},n);return[r.state,r.setState,r]}function Ll(e,t,n){return ae({apiCtx:e,rawState:t,forAtom:!0},n)}function Js(e,t){const{label:n,isSyncer:r}=t,o=ve(e,{label:n});return(r?Hs:$s)(o)}function Nl(e){return Js(e,{label:"sync"})}function Vl(e){return Js(e,{label:"syncer",isSyncer:!0})}var Ul=100,Bl=5e3;function Yl(e,t){return{key:e,results:[],depKeys:[],enableStatus:t,collected:!1,mounted:!1,renderAtomOnce:!1,time:0,status:{loading:!1,err:null,ok:!0}}}function Hl(e,t=!1){const n=Q();e&&(n.initCount+=1);const r=li(),o=Yl(r,t);return Po(e).set(r,o),o}function Gl(e){const t=Q();e.mounted=!0,e.time=Date.now(),t.mountedCount+=1}function $l(e,t){const n=Q(),r=Po(t);if(r.delete(e),t&&r.size===Ul&&n.initCount-n.mountedCount>2){n.initCount=0,n.mountedCount=0;const o=Date.now();r.forEach((s,c)=>{!s.mounted&&o-s.time>Bl&&r.delete(c)})}}function jl(e,t){const n=Q();n.runningKey=e.key,n.isDynamic=t}function Wl(e){const t=Q();t.runningKey="",t.isDynamic=!1,e.collected=!0}function Xl(e,t,n){Dl(e,n,{manualDepKeys:t.depKeys})}function Zs(e,t,n){let r={loading:!1,err:null,ok:!0};return Xl(e,t,n),t.results.forEach(o=>{const s=Qn(e,{result:o,forAtom:he(o),showLoading:t.enableStatus});s.status.ok||(r=s.status)}),r}function qs(e,t,n){e.react.useEffect(()=>(t.mounted||Gl(t),()=>{$l(t.key,n)}),[t])}var zl=()=>!0,cr=e=>e;function Jl(e){const t=[];for(let n=1;n<=e.length;n++)t.push(e.slice(0,n));return t}function ar(e,t,n,r,o){const s=t;return s.displayName=n,r?e.react.memo(s,o):s}function Qs(e,t){const{sharedState:n,depKey:r,keyPath:o,compare:s,sharedKey:c,format:a=cr}=t;return ar(e,function(){const l=Bn(e,n,{arrDep:!0});l.isFirstRender&&(o.length>=2?Jl(o).forEach(d=>{l.recordDep({sharedKey:c,depKey:$(d,c),keyPath:d,parentKeyPath:d.slice(0,d.length-1)},gt)}):l.recordDep({sharedKey:c,depKey:r,keyPath:o}));const f=fe(l.internal.rawState,o);return a(f)},"HeluxSignal",!0,s)}function ir(e,t){return ar(e,function(){const{result:r,format:o=cr}=t,s=Qn(e,{result:r,forAtom:!0});return o(s.proxyResult.val)},"HeluxDerivedAtomSignal",!0,t.compare)}function Zl(e,t){return ar(e,function(){const{result:r,keyPath:o,format:s=cr}=t;return Qn(e,{result:r,forAtom:!1}),s(fe(r,o))},"HeluxDerivedSignal",!0,t.compare)}function ec(e,t){const{isDynamic:n,cb:r,props:o,ref:s}=t,{collected:c,status:a}=e;c||jl(e,n);const l=r(o,{props:o,status:a,read:hc,ref:s})||"";return c||Wl(e),l}function tc(e,t,n){const r=he(n);if(t.renderAtomOnce&&!r)throw new Error("block cb once returned derived atom but not keep to return it in new render period!");if(r){t.renderAtomOnce=!0;const o=ir(e,{result:n});return e.react.createElement(o,{status:{loading:!1,err:null,ok:!0}})}return Zr(n)}function nc(e,t,n,r){const{memo:o=!0,compare:s}=r||{},{key:c}=t,{react:a}=e,i=a.forwardRef||C,l=n();let f=i(l);ue()&&(l.displayName="HeluxKeyedBlockForHMR",f=i((d,p)=>(p&&Sc(p,"current")&&(t.ref=p),a.createElement(l,N(F({},d),{key:c})))));const u=o?a.memo(f,s):f;return u.displayName="HeluxBlock",u[ln]=!0,u}function ql(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,{useForceUpdate:c}=o.hookImpl,a=r?qs:C;return nc(o,s,()=>(i,l)=>{const f=s.ref||l,u=ec(s,{isDynamic:r,cb:n,props:i,ref:f}),d=c();return Zs(o,s,d),a(o,s,r),tc(o,s,u)},t)}function Ql(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,c=r?qs:C,{useForceUpdate:a}=o.hookImpl,{useEffect:i}=o.react;return nc(o,s,()=>(l,f)=>{const u=s.ref||f,d=ec(s,{isDynamic:r,cb:n,props:l,ref:u}),p=a(),E=Zs(o,s,p);c(o,s,r);const y=s.status.loading,g=E.loading;return i(()=>{y!==g&&p()},[y,g]),s.status=E,tc(o,s,d)},t)}function rc(e,t){const n=$u(t),{enableStatus:r}=n,o=N(F({},e),{blockCtx:Hl(e.isDynamic,r)});return r?Ql(o,n):ql(o,n)}function ef(e,t,n){return rc({apiCtx:e,isDynamic:!1,cb:t},n)}function oc(e,t,n){return rc({apiCtx:e,isDynamic:!0,cb:t},n)}function sc(e,t,n){const{react:r}=e;if(t&&t[ln])return r.createElement(t);const o=zl;if(O(t)){const d=oc(e,t,{compare:o});return r.createElement(d)}if(he(t)){const d=ir(e,{result:t,compare:o,format:n});return r.createElement(d)}if(Ve(t)){const d=se(t),p=Yt("val",d),y=Qs(e,{sharedKey:d,sharedState:t,depKey:p,keyPath:["val"],compare:o,format:n});return r.createElement(y)}const s=xi(),{sharedKey:c,val:a,stateOrResult:i,depKey:l,keyPath:f,isDerivedResult:u}=s;if(t===a&&i){if(s.isDerivedAtom){const p=ir(e,{result:i,compare:o,format:n});return r.createElement(p)}if(u){const p=Zl(e,{result:i,keyPath:f,compare:o,format:n});return r.createElement(p)}const d=Qs(e,{sharedKey:c,sharedState:i,depKey:l,keyPath:f,compare:o,format:n});return r.createElement(d)}return t}var{shallowCompare:tf,isDiff:nf}=Nr,rf=sr,of=sc,sf={EVENT_NAME:an,RECORD_LOADING:un,VER:Hr,LIMU_VER:_a};function cc(e,t,n){return t(e,n)}function cf(e,t){return cc(e,t)}function af(e,t){return{build:n=>cc(e,t,n)}}var uf=["atom","atomx","share","sharex","getMutateLoading","getActionLoading","$","signal","block","blockStatus","dynamicBlock","dynamicBlockStatus"];function lf(e){return e.startsWith("use")||uf.includes(e)}function ff(e){return Object.assign({useSyncExternalStore:C},e)}function df(e,t){const n=Ic(e),r=F({},n),o={react:ff(e),hookImpl:n,act:t};t&&(n.useForceUpdate=()=>{const[,a]=e.useState({});return()=>t(()=>a({}))});const s=Yr;return Object.keys(s).forEach(a=>{const i=s[a];lf(a)?r[a]=i.bind(null,o):r[a]=i}),Object.assign({model:a=>cf(r,a),modelFactory:a=>af(r,a)},r)}function pf(e){const{inited:t,API:n}=Va();if(t)return n;const{heluxCtxKey:r,standalone:o,transfer:s,reactLib:c,act:a}=e,i=Z[r],l=(f,u)=>{const d=u||Qr(),p=df(c,a);return ro({ROOT:d,inited:!0,api:p}),Z[f]=d,p};if(!i)return l(r);if(o)return l(`${String(r)}_${Date.now()}`);if(s){const f=Qr();ro({ROOT:f,inited:!0}),s(i,f)}return l(r,i)}var yf=P(70079),hf=P.t(yf,2),ac=pf({heluxCtxKey:"__HELUX__",reactLib:hf}),mf=ac.share,{atom:gf,atomx:Ef,share:vf,sharex:Sf,derive:_f,deriveDict:Af,defineDeriveTask:Df,defineDeriveFnItem:Kf,runDerive:Rf,runDeriveTask:Tf,watch:Mf,useAtom:bf,useAtomX:If,useReactive:wf,useReactiveX:Ff,useDerived:Cf,useWatch:Of,useGlobalId:Pf,useService:kf,useOnEvent:xf,useMutable:Lf,useMutateLoading:Nf,useActionLoading:Vf,useEffect:Uf,useLayoutEffect:Bf,useStable:Yf,useObject:Hf,useLocalForceUpdate:Gf,useGlobalForceUpdate:$f,action:jf,signal:Wf,block:Xf,dynamicBlock:zf,$:Jf,mutate:Zf,mutateDict:qf,runMutate:Qf,runMutateTask:ed,sync:td,syncer:nd,model:rd,modelFactory:od,emit:sd,on:cd,init:ad,reactiveDesc:id,flush:ud,isAtom:ld,isDerivedAtom:fd,storeSrv:dd,shallowCompare:pd,markRaw:yd,isDiff:hd,produce:md,getMutateLoading:gd,getActionLoading:Ed,getDeriveLoading:vd,getRawState:Sd,getSnap:_d,getAtom:Ad,addMiddleware:Dd,addPlugin:Kd,cst:Rd}=ac}}]);
}());