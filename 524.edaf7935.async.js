!(function(){"use strict";var jd=Object.defineProperty,$d=Object.defineProperties;var Wd=Object.getOwnPropertyDescriptors;var Vt=Object.getOwnPropertySymbols;var vc=Object.prototype.hasOwnProperty,Sc=Object.prototype.propertyIsEnumerable;var Ec=(V,U,N)=>U in V?jd(V,U,{enumerable:!0,configurable:!0,writable:!0,value:N}):V[U]=N,C=(V,U)=>{for(var N in U||(U={}))vc.call(U,N)&&Ec(V,N,U[N]);if(Vt)for(var N of Vt(U))Sc.call(U,N)&&Ec(V,N,U[N]);return V},G=(V,U)=>$d(V,Wd(U));var Ac=(V,U)=>{var N={};for(var w in V)vc.call(V,w)&&U.indexOf(w)<0&&(N[w]=V[w]);if(V!=null&&Vt)for(var w of Vt(V))U.indexOf(w)<0&&Sc.call(V,w)&&(N[w]=V[w]);return N};var _c=(V,U,N)=>new Promise((w,Z)=>{var we=W=>{try{Ie(N.next(W))}catch(Q){Z(Q)}},ct=W=>{try{Ie(N.throw(W))}catch(Q){Z(Q)}},Ie=W=>W.done?w(W.value):Promise.resolve(W.value).then(we,ct);Ie((N=N.apply(V,U)).next())});(self.webpackChunkspeedform_docs=self.webpackChunkspeedform_docs||[]).push([[524],{23524:function(V,U,N){N.r(U),N.d(U,{$:function(){return fd},action:function(){return cd},addMiddleware:function(){return Bd},addPlugin:function(){return Yd},atom:function(){return wl},atomx:function(){return Il},block:function(){return id},createShared:function(){return bl},cst:function(){return Hd},defineDeriveFnItem:function(){return kl},defineDeriveTask:function(){return xl},defineMutateFnItem:function(){return hd},derive:function(){return Ol},deriveDict:function(){return Pl},dynamicBlock:function(){return ud},emit:function(){return Sd},flush:function(){return Kd},getActionLoading:function(){return kd},getAtom:function(){return Ud},getDeriveLoading:function(){return Ld},getMutateLoading:function(){return xd},getRawState:function(){return Nd},getSnap:function(){return Vd},init:function(){return _d},isAtom:function(){return Rd},isDerivedAtom:function(){return Md},isDerivedResult:function(){return bd},isDiff:function(){return Od},isDraft:function(){return wd},isSharedState:function(){return Td},markRaw:function(){return Cd},model:function(){return Ed},modelFactory:function(){return vd},mutate:function(){return ld},mutateDict:function(){return dd},on:function(){return Ad},produce:function(){return Pd},reactiveDesc:function(){return Dd},runDerive:function(){return Ll},runDeriveTask:function(){return Nl},runMutate:function(){return pd},runMutateTask:function(){return yd},shallowCompare:function(){return Fd},share:function(){return Fl},sharex:function(){return Cl},signal:function(){return ad},storeSrv:function(){return Id},sync:function(){return md},syncer:function(){return gd},useActionLoading:function(){return Ql},useAtom:function(){return Bl},useAtomX:function(){return Yl},useDerived:function(){return jl},useEffect:function(){return ed},useGlobalForceUpdate:function(){return sd},useGlobalId:function(){return Xl},useLayoutEffect:function(){return td},useLocalForceUpdate:function(){return od},useMutable:function(){return Zl},useMutateLoading:function(){return ql},useObject:function(){return rd},useOnEvent:function(){return Jl},useReactive:function(){return Hl},useReactiveX:function(){return Gl},useService:function(){return zl},useStable:function(){return nd},useWatch:function(){return $l},useWatchEffect:function(){return Wl},watch:function(){return Vl},watchEffect:function(){return Ul}});function w(e,t){e.includes(t)||e.push(t)}function Z(e,t){const n=e.indexOf(t);n>=0&&e.splice(n,1)}function we(e){return Array.from(new Set(e))}function ct(e,t){let n=!1;for(const r of e)if(t.includes(r)){n=!0;break}return n}function Ie(e,t){let n="";const r=e.length;for(let o=0;o<r;o++){const s=e[o];if(t.startsWith(s)){n=s;break}}return n}function W(e,t,n){if(!e)return[];const r=e(t,n);return Array.isArray(r)?r:[r]}var Q=function(){if(typeof globalThis!="undefined")return globalThis;if(typeof global!="undefined")return global;if(typeof window!="undefined")return window;if(this!==void 0)return this;throw new Error("no globalThis")}(),dr=!1;function P(...e){}var Dc=P;function Kc(...e){return e}function Fe(...e){return[]}function Xd(...e){}var Rc=Object.prototype.toString,Tc="[object Map]";function zd(){return!(typeof window!="undefined"&&window.document)}function Ut(e){return Rc.call(e)===Tc}function pr(e){return e===Number.MAX_SAFE_INTEGER}function pe(){return!(!dr&&Q.name!=="previewFrame"&&!Q.BrowserFS)}function X(e){return e&&typeof e=="object"&&!Array.isArray(e)}function yr(e){return e&&typeof e=="object"}function k(e){return typeof e=="function"}function Jd(e){return dr?Object.prototype.toString.call(e)==="[object AsyncFunction]":!0}function Bt(e){return typeof e=="symbol"}function Yt(e){if(!e)return!1;const t=typeof e;return(t==="object"||t==="function")&&k(e.then)}function Zd(e){try{return e.test,!1}catch(t){return!0}}function Ve(){return typeof Proxy=="function"}function ye(e,t){const{throwErr:n=!1,prefixLabel:r="",suffixLabel:o=", see details in console.",logErr:s=!0,alertErr:c}=t||{};let a=e,i=!1;if(e instanceof Error&&(i=!0,a=e.message),(typeof c=="boolean"?c:pe())&&Q.alert&&e&&Q.alert(`${r}${a}${o}`),s&&console.error(e),n)throw i?e:new Error(String(e))}function Ce(e,t=0){t===0?(console.error(e),pe()&&console.trace(e)):t===1?console.error(e):console.warn(e)}function Ue(e){return pr(e)?1:e+1}var Mc=!!Reflect,bc=Object.prototype.hasOwnProperty;function wc(e,t){return Mc?Reflect.has(e,t):bc.call(e,t)}function Be(e,t,n){let r=e[t];return r||(r=e[t]=n),r}function Ye(e,t,n){let r=e.get(t);return r||(e.set(t,n),r=n),r}function hr(e,t){let n="";for(const r in e)if(t.startsWith(r)){n=r;break}return n}function mr(e,t){const n=e.get(t);if(n!==void 0)return n;const r=e.get(Number(t)||t);return r!==void 0?r:void 0}function he(e,t){let n,r=e;return t.forEach(o=>{n=Ut(r)?mr(r,o):r[o],r=n}),n}function gr(e,t,n){let r=e;const o=t.length-1;t.forEach((s,c)=>{const a=Ut(r);if(c===o)return void(a?r.set(s,n):r[s]=n);r=a?mr(r,s):r[s]})}function Ic(){return Ce("changing shared state is invalid"),!0}function qd(e){return e}function Ht(e,t){return`${t}/${e}`}function Gt(e){return e&&Ve()}var Fc=Object.defineProperty,jt={};((e,t)=>{for(var n in t)Fc(e,n,{get:t[n],enumerable:!0})})(jt,{useEffect:()=>xc,useEffectLogic:()=>Wt,useForceUpdate:()=>Er,useLayoutEffect:()=>Pc,useObject:()=>Lc,useObjectLogic:()=>Sr,useStable:()=>vr});var Cc=0,at=new Map,$t=0;function Oc(e,t){const n=()=>{const r=t();return()=>{at.delete(e),r&&r()}};if(function(r){$t||($t=r)}(e),function(r){const o=at.get(r);o?o.count+=1:at.set(r,{count:1})}(e),$t%2!=0)return n();{const r=function(o){return at.get(o)}(e);if(r&&r.count>1)return n()}}function Wt(e,t,n){const{useState:r,useLayoutEffect:o,useEffect:s}=e.react,{isLayout:c,deps:a}=n,[i]=r(()=>++Cc);(c?o:s)(()=>Oc(i,t),a)}function Pc(e,t,n){Wt(e,t,{isLayout:!0,deps:n})}function xc(e,t,n){Wt(e,t,{deps:n})}function Er(e){const[,t]=e.react.useState({});return()=>t({})}function kc(e){const{data:t}=e.current;k(t)?e.current.wrap=(...n)=>e.current.data(...n):X(t)?e.current.wrap=function(n,r){if(!Ve()){const s={};return Object.keys(n).forEach(c=>{const a=n[c];k(a)?s[c]=(...i)=>r.current.data[c](...i):Object.defineProperty(s,c,{get:()=>r.current.data[c],set(i){r.current.data[c]=i}})}),s}const o={};return new Proxy(n,{get(s,c){const a=s[c];return k(a)?Be(o,c,(...i)=>r.current.data[c](...i)):a}})}(t,e):e.current.wrap=t}function vr(e,t){const{useRef:n,useMemo:r}=e.react,o=n({data:t,wrap:{},inited:!1});return o.current.data=r(()=>t,[t]),o.current.inited||(kc(o),o.current.inited=!0),o.current.wrap}function Sr(e,t,n,r){const{useState:o,useRef:s,useEffect:c}=e.react,[a]=o(t),i=Er(e),l=s({state:null,unmount:!1,shouldCopy:!0}),f=vr(e,{setState(u){const d=l.current;if(d.unmount)return;let p;const{state:y}=d;n?(p=n(u,d.state||a),r&&p?(d.state=p,d.shouldCopy=!1):d.shouldCopy=!0):(p=(k(u)?u(y):u)||{},d.shouldCopy=!0),Object.assign(a,p||{}),i()},getLatestState(){const u=l.current;return u.shouldCopy&&(u.state=C({},a),u.shouldCopy=!1),u.state}});return c(()=>{const u=l.current;return u.unmount=!1,()=>{u.unmount=!0}},[l]),[a,f.setState,f]}function Lc(e,t){return Sr(e,t)}function Nc(e){const t={},n={react:e},r=jt;return Object.keys(jt).forEach(o=>{t[o]=r[o].bind(null,n)}),t}const Qd=3,Vc="3.12.3",it=Symbol("M"),Ar=Symbol("V"),_r=Symbol("IMMUT_BASE"),ut=Symbol("IS_RAW"),z="Map",q="Set",J="Array",Uc="Object",Bc=[Symbol.iterator,Symbol.toStringTag,ut],Yc={Map:z,Set:q,Array:J},Xt="[object Object]",ft="[object Map]",lt="[object Set]",zt="[object Array]",Jt="[object Function]",Hc={[ft]:z,[lt]:q,[zt]:J,[Xt]:Uc},Gc=["push","pop","shift","splice","unshift","reverse","copyWithin","delete","fill"],jc=["set","clear","delete"],$c=["add","clear","delete"],Wc=["splice","sort","unshift","shift"],Xc=["concat","copyWithin","entries","every","fill","filter","find","findIndex","flat","flatMap","forEach","includes","indexOf","join","keys","lastIndexOf","map","pop","push","reduce","reduceRight","reverse","shift","unshift","slice","some","sort","splice","values","valueOf"],zc=["clear","delete","entries","forEach","get","has","keys","set","values"],Jc=["add","clear","delete","entries","forEach","has","keys","values"],Dr={[z]:zc,[q]:Jc,[J]:Xc},Zc={[z]:["clear","set","delete"],[q]:["clear","add","delete"],[J]:["pop","push","shift","unshift","splice","sort","copyWithin"]},qc={[z]:["forEach","get"],[q]:["forEach"],[J]:["forEach","map"]},He={value:0,usablePrefix:1},Kr={autoFreeze:!1,fastModeRange:"array"},Qc=Object.prototype.toString,ea=!!Reflect,ta=Object.prototype.hasOwnProperty;function Rr(e,t){return ea?Reflect.has(e,t):ta.call(e,t)}function na(e,t,n,r){const o=(s,c,a)=>{oe(s)||(r(s,c,a),Array.isArray(s)&&s.forEach((i,l)=>{o(i,s,l)}),dt(s)&&s.forEach((i,l)=>{o(i,s,l)}),Ge(s)&&Object.keys(s).forEach(i=>{o(s[i],s,i)}))};o(e,t,n)}function me(e){return Qc.call(e)}function Oe(...e){return e}function Ge(e){return me(e)===Xt}function dt(e){return me(e)===ft}function Zt(e){return me(e)===lt}function ge(e){return me(e)===Jt}function Tr(e){var t=me(e);return Hc[t]}function oe(e){const t=me(e);return![Xt,zt,ft,lt,Jt].includes(t)}function Mr(e){return e.constructor.name==="AsyncFunction"||typeof e.then=="function"}function br(e){return typeof Promise!="undefined"&&e instanceof Promise}function qt(e){var t=typeof e;return t==="number"?!0:t==="string"?/^[0-9]*$/.test(e):!1}function ra(e){return typeof e=="symbol"}function oa(e){var t;return e&&(t=e[ut])!==null&&t!==void 0?t:!1}const sa={[zt]:Array.prototype,[ft]:Map.prototype,[lt]:Set.prototype,[Jt]:Function.prototype};function ca(e){const t=me(e),n=sa[t]||Object.prototype,r=Object.create(null);return Object.setPrototypeOf(r,n),Object.setPrototypeOf(e,r),e}const Qt=new Map;function je(e){e.rootMeta.modified=!0;const t=n=>{n&&!n.modified&&(n.modified=!0,t(n.parentMeta))};t(e)}function en(e,t,n){if(n.apiCtx.debug){const{fast:r}=n;r?e[it]=t:(ca(e),e.__proto__[it]=t)}return e}function aa(e,t,n){const r=[t],o=se(e,n);if(o&&o.level>0){const{keyPath:s}=o;return[...s,t]}return r}function ia(e,t,n){const{ver:r,parentMeta:o=null,immutBase:s,compareVer:c,apiCtx:a,hasOnOperate:i}=n,l=Tr(t);let f=[],u=0,d=null;o&&(d=o.copy,u=fa(d,a),f=aa(d,e,a));const p={rootMeta:null,parentMeta:o,parent:d,selfType:l,self:t,copy:null,key:e,keyPath:f,level:u,proxyVal:null,proxyItems:null,modified:!1,scopes:[],isImmutBase:s,isDel:!1,isFast:!1,isArrOrderChanged:!1,newNodeStats:{},newNodeMap:new Map,newNodes:[],ver:r,compareVer:c,revoke:Oe,hasOnOperate:i,execOnOperate:Oe};return u===0?p.rootMeta=p:p.rootMeta=o.rootMeta,p}function wr(e){const t=tn(e);return t?!t.isImmutBase:!1}function ua(){He.value>=Number.MAX_SAFE_INTEGER?(He.value=1,He.usablePrefix+=1):He.value+=1;const{value:e,usablePrefix:t}=He;return`${t}_${e}`}function fa(e,t){const n=Ee(e,t);return n?n.level+1:1}function se(e,t){return t.metaMap.get(e)}function Ee(e,t){let n=t||Fr(e);return(n==null?void 0:n.metaMap.get(e))||null}function Ir(e){return e&&e[Ar]||""}function Fr(e){const t=Ir(e);return Qt.get(t)||null}function tn(e){const t=Fr(e);return t&&t.metaMap.get(e)||null}function Cr(e,t){const n=tn(e),r=tn(t);if(!n&&!r)return!Object.is(e,t);const{self:o,modified:s,compareVer:c,ver:a,level:i}=n||{self:e,modified:!1,compareVer:!1,ver:"0",level:0},{self:l,modified:f,compareVer:u,ver:d,level:p}=r||{self:t,modified:!1,compareVer:!1,ver:"0",level:0};return o!==l||(c||u)&&(i===0||p===0)&&a!==d?!0:s||f}function la(e,t,n=!0){const r=n?Cr:Object.is;return!((c,a)=>{for(let i in c)if(!(i in a))return!0;for(let i in a)if(r(c[i],a[i]))return!0;return!1})(e,t)}function ep(e){const t=n=>{if(isPrimitive(n))return n;let r=n;if(Array.isArray(n)&&(r=n.slice(),r.forEach((o,s)=>{r[s]=t(o)})),isSet(n)){const o=Array.from(n);o.forEach((s,c)=>{o[c]=t(s)}),r=new Set(o)}return isMap(n)&&(r=new Map(n),r.forEach((o,s)=>{r.set(s,t(o))})),isObject(n)&&(r={},Object.keys(n).forEach(o=>{r[o]=t(n[o])})),r};return t(e)}function da(e,t){const{parentType:n,fastModeRange:r}=t;if(Array.isArray(e))return{copy:e.slice(),fast:!1};const o=r==="array"&&n===J||r==="all";let s=e;return e&&Ge(e)&&(s=Object.assign({},e)),dt(e)&&(s=new Map(e)),Zt(e)&&(s=new Set(e)),{copy:s,fast:o}}function pa(e,t,n){const{apiCtx:r,immutBase:o}=n;if(o)return{copy:e,fast:!1};const{copy:s,fast:c}=da(e,n);return en(s,t,{apiCtx:r,fast:c}),{copy:s,fast:c}}function ya(e,t,n){const{copy:r,isArrOrderChanged:o}=e,{targetNode:s,key:c}=n;if(o){const a=r.findIndex(i=>i===t.copy);a>=0&&(r[a]=s);return}r[c]=s}function ha(e,t){return Ge(e)?Ir(e)===t:!0}function ma(e,t){const{debug:n}=t,r=new Map;t.newNodeMap.forEach(o=>{const{node:s,parent:c,key:a}=o,i=r.get(s);if(i){c[a]=i;return}const l=o;na(s,c,a,(f,u,d)=>{const p=Ee(f,t);if(p){const{modified:y,copy:g,self:m}=p,E=y?g:m;u[d]=E}}),l.target=c[a],r.set(s,l.target)}),e.scopes.forEach(o=>{const{modified:s,copy:c,parentMeta:a,key:i,self:l,revoke:f,proxyVal:u,isDel:d,isFast:p}=o;if(!c||(n&&(p?delete c[it]:delete c.__proto__[it]),!a))return f();const y=s?c:l,g=a.copy,m=a.selfType;if(m===z)return g.set(i,y),f();if(m===q)return g.delete(u),g.add(y),f();if(m===J)return ya(a,o,{targetNode:y,key:i}),f();if(d!==!0)return g[i]=y,f()}),e.scopes.length=0}function ga(e,t){const{self:n,copy:r,modified:o}=e;let s=n;return r&&o&&(s=e.copy),ma(e,t),s}function Or(e){e.rootMeta.scopes.push(e)}function Pr(e,t,n){const{traps:r,parentType:o,fastModeRange:s,immutBase:c,apiCtx:a}=n,i=ia(e,t,n),{copy:l,fast:f}=pa(t,i,{immutBase:c,parentType:o,fastModeRange:s,apiCtx:a});if(i.copy=l,i.isFast=f,c){const u=new Proxy(l,r);i.proxyVal=u,i.revoke=Oe}else{const u=Proxy.revocable(l,r);i.proxyVal=u.proxy,i.revoke=u.revoke}return a.metaMap.set(l,i),a.metaMap.set(i.proxyVal,i),i}function Ea(e,t){return e===J?!0:(qc[e]||[]).includes(t)}function va(e,t){const{key:n,parentMeta:r,parent:o,parentType:s,fastModeRange:c,readOnly:a,apiCtx:i}=t;let l=e;if(a&&r&&!ge(e)){const{copy:u,self:d}=r,p=d[n];if(l!==p){const y=i.metaMap.get(l);y&&(i.metaMap.delete(l),i.metaMap.delete(y.proxyVal)),u[n]=p,l=p}}const f=(u,d)=>{const p=d||"";if(oe(u)||!u)return u;if(!r)throw new Error("[[ createMeta ]]: meta should not be null");if(!ge(u)){if(r.newNodeStats[p]||u[ut])return u;let g=se(u,i);return g||(g=Pr(p,u,t),Or(g),r.selfType===z?o.set(p,g.copy):o[p]=g.copy),g.proxyVal}if(!Ea(s,p)||r.proxyItems)return u;let y=[];if(s===q){const g=new Set;o.forEach(m=>g.add(f(m))),kr(g,r,{dataType:q,apiCtx:i}),y=en(g,r,{fast:c,apiCtx:i}),r.copy=y}else if(s===z){const g=new Map;o.forEach((m,E)=>g.set(E,f(m,E))),kr(g,r,{dataType:z,apiCtx:i}),y=en(g,r,{fast:c,apiCtx:i}),r.copy=y}else s===J&&p!=="sort"&&(r.copy=r.copy||o.slice(),y=r.proxyVal);return r.proxyItems=y,u};return f(l,n)}function xr(e,t){if(!Ge(e))return e;const n=se(e,t);return n?n.copy:e}function kr(e,t,n){const{dataType:r,apiCtx:o}=n,s=e.delete.bind(e),c=e.clear.bind(e);if(e.delete=function(...i){return je(t),s(...i)},e.clear=function(...i){return je(t),c(...i)},r===q){const a=e.add.bind(e);e.add=function(...l){return je(t),a(...l)}}if(r===z){const a=e.set.bind(e),i=e.get.bind(e);e.set=function(...f){if(je(t),t.hasOnOperate){const u=f[1];t.rootMeta.execOnOperate("set",f[0],{mayProxyVal:u,value:u,parentMeta:t})}return a(...f)},e.get=function(...f){const u=i(...f);if(t.hasOnOperate){const d=Ee(u,o),p=d?d.copy||d.self:u;t.rootMeta.execOnOperate("get",f[0],{mayProxyVal:u,value:p,parentMeta:t,isChanged:!1})}return u}}}function Sa(e){const{calledBy:t,parentMeta:n,op:r,parentType:o}=e;(["deleteProperty","set"].includes(t)||t==="get"&&(o===q&&$c.includes(r)||o===J&&Gc.includes(r)||o===z&&jc.includes(r)))&&je(n)}function Lr(e,t){const n=e.keyPath.slice();return n.push(t),n.join("|")}function nn(e,t){const{op:n,key:r,value:o,calledBy:s,parentType:c,parentMeta:a,apiCtx:i}=t,l=xr(o,i);if(!a){e[r]=l;return}const{self:f,copy:u}=a;Sa({calledBy:s,parentMeta:a,op:n,key:r,parentType:c});const d=Dr[c]||[];if(ge(o)&&d.includes(n))return n==="slice"?f.slice:(Wc.includes(n)&&(a.isArrOrderChanged=!0),u?c===q||c===z?u[n].bind(u):u[n]:f[n].bind(f));if(!u)return l;const p=u[r],y=()=>{const m=Ee(p,i);m&&(m.isDel=!0)},g=()=>{const m=Ee(o,i);m&&m.isDel&&(m.isDel=!1,m.key=r,m.keyPath=a.keyPath.concat([r]),m.level=a.level+1,m.parent=a.copy,m.parentMeta=a)};if(s==="deleteProperty"){const m=Ee(o,i);m?m.isDel=!0:y();const E=u[r];oe(E)||i.newNodeMap.delete(Lr(a,r)),delete u[r];return}oe(l)||(a.newNodeStats[r]=!0,i.newNodeMap.set(Lr(a,r),{parent:u,node:l,key:r,target:null})),u[r]=l,y(),g()}function rn(e){if(oe(e))return e;if(Array.isArray(e)&&e.length>0)return e.forEach(rn),Object.freeze(e);if(Zt(e)){const n=e;n.add=()=>n,n.delete=()=>!1,n.clear=Oe;for(const r of n.values())Object.freeze(r);return Object.freeze(e)}if(dt(e)){const n=e;n.set=()=>n,n.delete=()=>!1,n.clear=Oe;for(const r of n.values())Object.freeze(r);return Object.freeze(e)}return Object.getOwnPropertyNames(e).forEach(n=>{const r=e[n];rn(r)}),Object.freeze(e)}const Aa=["length","constructor","asymmetricMatch","nodeType","size"],Nr={};Aa.forEach(e=>Nr[e]=1);const _a={[J]:1,[q]:1,[z]:1},on=new Map;function Vr(e){var t,n,r,o,s;const c=e||{},a=c.onOperate,i=!!a,l=c.customKeys||[],f=c.fastModeRange||Kr.fastModeRange,u=(t=c[_r])!==null&&t!==void 0?t:!1,d=(n=c.readOnly)!==null&&n!==void 0?n:!1,p=c.disableWarn,y=(r=c.compareVer)!==null&&r!==void 0?r:!1,g=(o=c.debug)!==null&&o!==void 0?o:!1,m=(s=c.autoFreeze)!==null&&s!==void 0?s:Kr.autoFreeze,E=ua(),S={metaMap:new Map,newNodeMap:new Map,debug:g,metaVer:E};Qt.set(E,S);const T=()=>(p||console.warn("can not mutate state at readOnly mode!"),!0),K=(b,R,D)=>{const{mayProxyVal:h,parentMeta:v,value:A,isCustom:_=!1}=D;let M=!1;if(!a)return{isChanged:M,mayProxyVal:h};const I=v||{},{selfType:O="",keyPath:Me=[],copy:L,self:x,modified:ne,proxyVal:re}=I||{};let be=!1;D.isChanged!==void 0?M=D.isChanged:(Dr[O]||[]).includes(R)?(be=!0,M=(Zc[O]||[]).includes(R)):b!=="get"&&(M=v?(ne?L:x)[R]!==A:!0);let de=null,lr=!1;return a({immutBase:u,parent:x,parentType:O,parentProxy:re,op:b,replaceValue:gc=>{lr=!0,de=gc},getReplaced:()=>({isReplaced:lr,replacedValue:de}),isBuiltInFnKey:be,isChanged:M,isCustom:_,key:R,keyPath:Me,fullKeyPath:Me.concat(R),value:A,proxyValue:h}),{mayProxyVal:lr?de:h,isChanged:M}},F=(()=>{let b=!0;const R={get:(D,h)=>{if(Ar===h)return E;const v=D[h];if(Bc.includes(h))return ge(v)?v.bind(D):v;if(h==="__proto__"||h==="toJSON"&&!Rr(D,h))return v;let A=v;const _=se(D,S);if(l.includes(h))return K("get",h,{parentMeta:_,mayProxyVal:A,value:v,isChanged:!1,isCustom:!0}).mayProxyVal;const M=_==null?void 0:_.selfType;return _a[M]&&Nr[h]?((h==="length"||h==="size")&&K("get",h,{parentMeta:_,mayProxyVal:A,value:v}),_.copy[h]):(A=va(v,{key:h,compareVer:y,parentMeta:_,parentType:M,ver:E,traps:R,parent:D,fastModeRange:f,immutBase:u,readOnly:d,apiCtx:S,hasOnOperate:i}),M===J&&qt(h)?K("get",h,{parentMeta:_,mayProxyVal:A,value:v}).mayProxyVal:Yc[M]?(A=nn(D,{op:h,key:h,value:v,metaVer:E,calledBy:"get",parentType:M,parentMeta:_,apiCtx:S}),K("get",h,{parentMeta:_,mayProxyVal:A,value:v}).mayProxyVal):K("get",h,{parentMeta:_,mayProxyVal:A,value:v}).mayProxyVal)},set:(D,h,v)=>{let A=v;const _=se(D,S);if(wr(v))if(ha(v,E)){if(A=xr(v,S),A===D[h])return!0}else b=!1;if(d)return K("set",h,{parentMeta:_,isChanged:!1,value:A}),T();if(_&&_.selfType===J){if(_.copy&&_.__callSet&&qt(h))return K("set",h,{parentMeta:_,value:A}),_.copy[h]=A,!0;_.__callSet=!0}let M=!1;return a?M=K("set",h,{parentMeta:_,value:A}).isChanged:M=(_.modified?_.copy:_.self)[h]!==v,M&&nn(D,{parentMeta:_,key:h,value:A,metaVer:E,calledBy:"set",apiCtx:S}),!0},deleteProperty:(D,h)=>{const v=se(D,S),A=D[h];return d?(K("del",h,{parentMeta:v,isChanged:!1,value:A}),T()):(K("del",h,{parentMeta:v,isChanged:!0,value:A}),nn(D,{parentMeta:v,op:"del",key:h,value:"",metaVer:E,calledBy:"deleteProperty",apiCtx:S}),!0)},apply:function(D,h,v){return D.apply(h,v)}};return{createDraft:D=>{if(oe(D))throw new Error("base state can not be primitive");let h=D;const v=se(D,S);if(v){if(u&&v.isImmutBase)return v.proxyVal;h=v.self}const A=Pr("",h,{ver:E,traps:R,immutBase:u,readOnly:d,compareVer:y,apiCtx:S,hasOnOperate:i});return Or(A),A.execOnOperate=K,on.set(A.proxyVal,F.finishDraft),A.proxyVal},finishDraft:D=>{const h=se(D,S);if(!h)throw new Error("rootMeta should not be null!");if(h.level!==0)throw new Error("can not finish sub draft node!");if(h.isImmutBase)return D;let v=ga(h,S);return m&&b&&(v=rn(v)),Qt.delete(E),v}}})();return F}function tp(e){const t=getDraftMeta(e);return t?t.self:e}function np(e){const t=getDraftMeta(e);return t?deepCopy(t.copy||t.self):e}function Da(e){return!e||oe(e)||(e[ut]=!0),e}const Ur={has:Rr,noop:Oe,isObject:Ge,isMap:dt,isSet:Zt,isFn:ge,isPrimitive:oe,isPromiseFn:Mr,isPromiseResult:br,isSymbol:ra,isMardedRaw:oa,canBeNum:qt,isDraft:wr,isDiff:Cr,shallowCompare:la,getDraftMeta:Ee,getDataType:Tr},Br=Vc;function sn(e,t){return Vr(t).createDraft(e)}function cn(e){const t=on.get(e);if(!t)throw new Error("Not a Limu root draft or draft has been finished!");return on.delete(e),t(e)}function Yr(e){if(!ge(e))throw new Error("produce callback is not a function")}function Ka(e,t){if(Mr(e)||br(t))throw new Error("produce callback can not be a promise function or result")}function Hr(e,t,n){Yr(t);const r=sn(e,n),o=t(r);return Ka(t,o),cn(r)}function Ra(e,t,n){if(!t||!ge(t)){const r=e,o=t;return Yr(e),s=>Hr(s,r,o)}return Hr(e,t,n)}const Ta=Ra,cp=null;function ap(e){return deepCopyFn(e)}function pt(e,t){return Vr(Object.assign(Object.assign({},t||{}),{readOnly:!0,[_r]:!0})).createDraft(e)}function ip(e){conf.autoFreeze=e}function up(){return conf.autoFreeze}const fp=null,Ma=Da,lp=null;var ba=Object.defineProperty,wa=(e,t)=>{for(var n in t)ba(e,n,{get:t[n],enumerable:!0})},Gr={};wa(Gr,{$:()=>gl,action:()=>_s,addMiddleware:()=>Za,addPlugin:()=>ti,atom:()=>Xf,atomx:()=>zf,block:()=>dl,createShared:()=>ml,cst:()=>El,currentDraftRoot:()=>wi,defineDeriveFnItem:()=>yf,defineDeriveTask:()=>pf,defineMutateFnItem:()=>Ef,derive:()=>Ts,deriveDict:()=>df,dynamicBlock:()=>pc,emit:()=>si,flush:()=>Un,getActionLoading:()=>wf,getAtom:()=>eo,getDeriveLoading:()=>Hu,getMutateLoading:()=>Mf,getRawState:()=>di,getSnap:()=>mo,init:()=>Ja,isAtom:()=>ke,isDerivedAtom:()=>ve,isDerivedResult:()=>Ha,isDiff:()=>yl,isDraft:()=>hl,isSharedState:()=>Ya,markRaw:()=>Ma,mutate:()=>Fs,mutateDict:()=>tr,on:()=>ci,produce:()=>Ta,reactiveDesc:()=>Bo,runDerive:()=>Vu,runDeriveTask:()=>Uu,runMutate:()=>ws,runMutateTask:()=>Is,shallowCompare:()=>pl,share:()=>rc,sharex:()=>oc,signal:()=>yc,storeSrv:()=>Pf,sync:()=>Jf,syncer:()=>Zf,useActionLoading:()=>If,useAtom:()=>Cs,useAtomX:()=>Os,useDerived:()=>rr,useGlobalForceUpdate:()=>Ls,useGlobalId:()=>Tf,useLocalForceUpdate:()=>Bs,useMutable:()=>Ys,useMutateLoading:()=>bf,useOnEvent:()=>Ff,useReactive:()=>sr,useReactiveX:()=>Hs,useService:()=>Of,useWatch:()=>kf,useWatchEffect:()=>Lf,watch:()=>nf,watchEffect:()=>rf});var jr="4.2.2",Ia=Br,an={ON_DATA_CHANGED:"ON_DATA_CHANGED",ON_SHARE_CREATED:"ON_SHARE_CREATED",ON_ERROR_OCCURED:"ON_ERROR_OCCURED"},un={NO:"no",PRIVATE:"private",GLOBAL:"global"},$r=0,Wr=Symbol,Fa=typeof Wr=="function";function ce(e){return Fa?Wr(e):($r+=1,`__HELUX_SYMBOL_${$r}__`)}var Ca="__proto__",Oa=Ve(),Pa=ce("HeluxUndefined"),Xr=ce("HeluxMutateFnItem"),yt=ce("HeluxFnKey"),ht=ce("HeluxSharedKey"),zr=ce("HeluxReactiveMeta"),fn=ce("HeluxIsBlock"),Pe=ce("HeluxIsAtom"),$e=ce("HeluxIsDerivedAtom"),mt=[ht,Pe,$e,fn],gt="SingleMutate",xa="HeluxGlobalLoading",ka=6,La=!0,Jr=2e3,Na=20,We="1",ln="2",Et=1,vt=2,Zr=3,xe="|",St={TASK:"task",MAY_TRANSFER:"may_transfer"},ae={STATIC:"static",HOOK:"hook"},ee={USER_STATE:"user_state",GLOGAL_EMPTY:"global_empty",GLOGAL_LOADING:"global_loading",PRIVATE_LOADING:"private_loading"},qr="derive",Qr="watch",At="Object",Va="Map",Ua="Array",Ba="Other",j={SET_STATE:"SetState",MUTATE:"Mutate",ACTION:"Action",REACTIVE:"Reactive",LOADING:"Loading",SYNC:"Sync"};function ke(e){var t;return e&&(t=e[Pe])!=null?t:!1}function Ya(e){return e?e[Pe]!==void 0:!1}function ve(e){return e&&e[$e]||!1}function Ha(e){return e?e[$e]!==void 0:!1}function eo(e){return ke(e)||ve(e)?e.val:e}function Ga(){return{keySeed:{static:0,hook:0,Reactive:0,Mutate:0},runningFnKey:"",runningSharedKey:0,isIgnore:!1,depKeys:[],delPathAoa:[],GID_INSKEYS_MAP:new Map,FNKEY_STATIC_CTX_MAP:new Map,FNKEY_HOOK_CTX_MAP:new Map,DEPKEY_FNKEYS_MAP:new Map,SKEY_FNKEYS_MAP:new Map,UNMOUNT_INFO_MAP:new Map,DEPKEY_COMPUTING_FNKEYS_MAP:new Map}}function ja(){return{keySeed:0,keyPrefix:0,initCount:0,mountedCount:0,latest:{val:null,stateOrResult:null,sharedKey:0,depKey:"",keyPath:[],isDerivedResult:!1,isDerivedAtom:!1},runningKey:"",isDynamic:!1,KEY_CTX_MAP:new Map,KEY_DYNAMIC_CTX_MAP:new Map}}function $a(){return{keySeed:0,UNMOUNT_INFO_MAP:new Map}}function Wa(){return{keySeed:0,SHARED_KEY_STATE_MAP:new Map,STATE_SHARED_KEY_MAP:new Map,INTERMAL_MAP:new Map,COMPARE_MAP:new Map,isStateChanged:!1}}function to(){const e={};return{on:(t,n)=>{Be(e,t,[]).push(n)},emit:(t,...n)=>{(e[t]||[]).slice().forEach(o=>o(...n))},off:(t,n)=>{const r=e[t]||[],o=r.findIndex(s=>s===n);o>=0&&r.splice(o,1)},canEmit:t=>e[t]}}function no(){const e={VER:jr,LIMU_VER:Br,rootState:{},setState:(t,n)=>{const r=e.ctx.mod[t];if(!r)throw new Error(`moduleName ${t} not found`);r.setState(n)},ctx:{bus:to(),userBus:to(),mod:{},middlewares:[],plugins:[],sharedScope:Wa(),fnScope:Ga(),insScope:$a(),blockScope:ja(),markAtomMap:new Map,renderSN:0,globalLoading:null,globalLoadingInternal:null,globalEmpty:null,globalEmptyInternal:null,isRootRender:!0},legacyRoot:{}};return e}var _t={},ro=!1,oo=null,so=!1;function H(){return _t.ctx||{}}function Xa(){return _t}function co(e){_t=e.ROOT,oo=e.api,ro=e.inited}function za(){return{ROOT:_t,inited:ro,API:oo}}function Ja(e){if(so)return!1;so=!0;const{isRootRender:t=!0}=e;return H().isRootRender=t,!0}function Za(e){const{middlewares:t}=H();t.push(e)}function qa(e,t,n,r){const{middlewares:o}=H();if(!o.length)return;const s={},{sharedKey:c,moduleName:a,forAtom:i}=e,f={forAtom:i,draftRoot:t,draft:n,sharedKey:c,moduleName:a,setData:(u,d)=>s[u]=d,data:s,idx:0,sn:r};o.forEach((u,d)=>{u(G(C({},f),{idx:d}))})}var{ON_DATA_CHANGED:dn,ON_SHARE_CREATED:ao,ON_ERROR_OCCURED:Qa}=an,ei=[ee.GLOGAL_LOADING,ee.PRIVATE_LOADING];function ti(e){const{plugins:t,bus:n}=H();t.push(e);const r={on:(o,s)=>n.on(o,s),onStateChanged:o=>n.on(dn,o)};e.install(r)}function ni(e,t){const{bus:n}=H();if(n.canEmit(dn)){const{from:r,desc:o}=t,{forAtom:s,sharedKey:c,moduleName:a,snap:i,usefulName:l,stateType:f}=e;let u;ei.includes(f)?u=`${l}/setState`:u=`${l}@${r||"Api"}/${o}`,n.emit(dn,{forAtom:s,snap:i,sharedKey:c,moduleName:a,usefulName:l,type:u})}}function ri(e){const{bus:t}=H();if(t.canEmit(ao)){const{forAtom:n,snap:r,sharedKey:o,moduleName:s,usefulName:c}=e,a=`${c}@FactoryApi/createShared`;t.emit(ao,{forAtom:n,snap:r,sharedKey:o,moduleName:s,usefulName:c,type:a})}}function io(e,t,n){const{bus:r}=H();if(!r.canEmit(t))return!1;const{sharedKey:o,moduleName:s}=e;return r.emit(t,{moduleName:s,sharedKey:o,data:n}),!0}function uo(e,t){io(e,Qa,{err:t})||(console.warn("found uncaught error, sugguest add a plugin to handle this error"),console.error(t))}function oi(){const{userBus:e}=H();return e}function si(e,...t){const{userBus:n}=H();n.emit(e,...t)}function ci(e,t){const{userBus:n}=H();return n.on(e,t),()=>n.off(e,t)}function ai(e,t){return e.__proto__=t,e}function ii(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(e,n)||(e[n]=t[n]);return e}var pn=Object.setPrototypeOf||({__proto__:[]}instanceof Array?ai:ii);function ui(e){const t=Object.create(null);return pn(t,C({},Object.prototype)),e&&Object.assign(t,e),t}function fo(e){if(k(e))return;const t=Object.create(null);return pn(t,Object.prototype),pn(e,t),e}function lo(e,t,n){return e[t]=n,!0}function po(e,t){return e[t]}function Xe(e,t){const{set:n=lo,get:r=po,obj:o={}}=t||{};return Object.keys(e).forEach(s=>{Object.defineProperty(o,s,{enumerable:!0,configurable:!1,set:function(c){return n(e,s,c)},get:function(){return r(e,s)}})}),o}function Se(e,t){const{set:n=lo,get:r=po}=t||{};if(Ve())return new Proxy(e,{set(c,a,i){return n(c,a,i)},get(c,a){return r(c,a)}});const o=ui();return Xe(o,{obj:o,set:n,get:r})}var ze=H();function Dt(e){const n=H()[e];return ze[e]=n,n}function te(){return ze.blockScope||Dt("blockScope")}function B(){return ze.fnScope||Dt("fnScope")}function ie(){return ze.sharedScope||Dt("sharedScope")}function yo(){return ze.insScope||Dt("insScope")}function ho(){const{INTERMAL_MAP:e}=ie();return e}function fi(e,t){if(!e||!pe()||!t)return;const{INTERMAL_MAP:n,SHARED_KEY_STATE_MAP:r,STATE_SHARED_KEY_MAP:o}=ie();let s=[],c=!1;if(n.forEach(a=>{a.moduleName===e&&a.loc===t&&a.stateType===ee.USER_STATE&&s.push(a.sharedKey)}),s.length>1){const a=s[0],i=n.get(a);n.delete(a),i&&(r.delete(i.sharedKey),o.delete(i.rawState))}return c}function Je(e){return ho().get(e)}function Y(e){const t=ue(e);return Je(t)}function li(e,t){const n=ho(),r=ue(e);n.set(r,t)}function di(e){return Y(e).rawState}function mo(e,t=!0){const n=Y(e);return t?n.prevSnap:n.snap}function ue(e){return e&&(e[ht]||ie().STATE_SHARED_KEY_MAP.get(e))||0}function yn(e){let t={state:{},stateRoot:{},isAtom:!1};if(!e)return t;const n=Y(e);if(n){const{sharedState:r,sharedRoot:o}=n;t={state:r,stateRoot:o,isAtom:n.forAtom}}return t}function pi(e){const t=ie(),{STATE_SHARED_KEY_MAP:n}=t,r=Ue(t.keySeed);return n.set(e,r),t.keySeed=r,r}function yi(e,t){const{SHARED_KEY_STATE_MAP:n,STATE_SHARED_KEY_MAP:r}=ie();n.set(e,t),r.set(t,e)}function hi(e){return ie().SHARED_KEY_STATE_MAP.get(e)}function mi(e,t){const{rootState:n,ctx:r}=Xa(),{moduleName:o,usefulName:s}=t,c=n[s],a=Y(c);if(o&&a&&a.loc!==t.loc){const i=`
loc1:${a.loc} 
loc2:${t.loc}`;return Ce(`only-dev-mode tip: moduleName ${o} duplicate! this does not effect helux but the duplicated module will be ignored by devtool`+i)}n[s]=e,r.mod[s]=Y(e)}var gi={innerSetState:P};function go(e,t){const{rawState:n,forAtom:r}=e,o=new Map,s={},c={},a=[],i=C({},n);let l=i;return r&&(l=n.val),G(C(C({ver:0,sn:0,reactive:n,reactiveRoot:n,sync:P,syncer:P,snap:i,prevSnap:i,rawStateVal:l},e),t),{insCtxMap:o,key2InsKeys:s,id2InsKeys:c,recordId(f,u){if(!f)return;const d=Be(c,f,[]);w(d,u)},delId(f,u){f&&Z(c[f]||[],u)},recordDep(f,u){const d=Be(s,f,[]);w(d,u)},delDep(f,u){Z(s[f]||[],u)},mapInsCtx(f,u){o.set(u,f)},delInsCtx(f){o.delete(f)},extra:{},loadingInternal:gi,level1ArrKeys:a})}var Ei={Mutate:"",Reactive:"r",[ae.STATIC]:"s",[ae.HOOK]:"h"};function vi(){const e=yo(),t=Ue(e.keySeed);return e.keySeed=t,t}function Si(){const e=te(),{keySeed:t,keyPrefix:n}=e,r=Ue(t);e.keySeed=r;let o=n;return pr(t)&&(o=Ue(n),e.keyPrefix=o),`${o}_${r}`}function Ai(){const e=H(),t=e.renderSN,n=t===Number.MAX_VALUE?1:t+1;return e.renderSN=n,n}function hn(e){const t=Ei[e],r=B().keySeed,o=Ue(r[e]);return r[e]=o,`${t}${o}`}function _i(){return hn("Reactive")}var{MAY_TRANSFER:Di}=St,{SET_STATE:Ki,REACTIVE:Ri}=j,Ti=()=>({isReplaced:!1,replacedValue:null}),Mi=()=>{},bi=gn({isFake:!0});function Eo(e,t,n=P){const{desc:r="",onRead:o,from:s=Ri,depKeys:c=[],isTop:a=!1,expired:i=!1,insKey:l=0}=t;return{draft:e,finish:n,modified:!1,expired:i,sharedKey:0,moduleName:"",hasFlushTask:!1,nextTickFlush:P,data:[],isTop:a,key:"",fnKey:"",depKeys:c,writeKeys:[],desc:r,onRead:o,from:s,insKey:l}}function mn(e){const{ids:t=[],globalIds:n=[],isReactive:r=!1,from:o=Ki,enableDep:s=!1,handleCbReturn:c=!0,sn:a=Ai(),isFirstCall:i=!1,desc:l="",onRead:f}=e;return{fnKey:"",depKeys:[],forcedDepKeys:[],triggerReasons:[],ids:t,globalIds:n,readKeys:{},writeKeys:{},arrKeyDict:{},writeKeyPathInfo:{},handleCbReturn:c,draftVal:null,from:o,isReactive:r,enableDep:s,sn:a,isFirstCall:i,desc:l,onRead:f}}function Ze(e,t,n){const{isChanged:r=!0,parentKeyPath:o=[],op:s="set",parentType:c="Object"}=n,a=o.slice();return a.push(e),{isChanged:r,isCustom:!1,op:s,immutBase:!1,key:e,value:t,proxyValue:t,parentType:c,keyPath:o,fullKeyPath:a,isBuiltInFnKey:!1,replaceValue:P,getReplaced:Ti}}function gn(e){const u=e||{},{desc:t="",fn:n=P,task:r=Mi,depKeys:o=[],writeKeys:s=[],deps:c=Fe,isFake:a=!1,onlyDeps:i=!1}=u,l=Ac(u,["desc","fn","task","depKeys","writeKeys","deps","isFake","onlyDeps"]);return C({fn:n,task:r,deps:c,oriDesc:"",onlyDeps:i,desc:t,depKeys:o,writeKeys:s,checkDeadCycle:void 0,watchKey:"",isFake:a,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}},l)}function vo(){const e={fnKey:"",fn:P,subFnInfo:bi,checkDeadCycle:!0,isFirstLevel:!0,isExpired:!1,task:P,deps:Fe,status:{loading:!1,err:null,ok:!0},stateRoot:{},isStateAtom:!1,forAtom:!1,remainRunCount:0,showLoading:!1,nextLevelFnKeys:[],prevLevelFnKeys:[],mountStatus:Et,depKeys:[],depSharedKeys:[],result:{},fnType:"watch",returnUpstreamResult:!1,scopeType:"static",renderStatus:We,proxyResult:{},updater:P,createTime:Date.now(),shouldReplaceResult:!1,isAsync:!1,isAsyncTransfer:!1,isSimpleWatch:!1,isRunning:!1,dcErrorInfo:{err:null,tipFn:P},asyncType:Di,subscribe:t=>{t()},extra:{},setLoading:(t,n=null)=>{const r=!t&&!n;e.status={loading:t,err:n,ok:r}},renderInfo:{time:0,insKey:0,sn:0,getDeps:()=>e.depKeys.slice()}};return e}var So={draftRoot:{val:null},isFake:!0,isAtom:!0},Ao=mn({}),Kt=Eo(!0,{expired:!0}),dp=gn(),_o=go({rawState:{},forAtom:!1,usefulName:""},{}),Do=vo(),Rt=So,En=Ao,Ko="",vn=new Map,Sn=new Map,An=new Map,_n=P,Dn=[],Kn="";function wi(){return Rt}var qe={current:()=>Kn,set:e=>Kn=e,del:()=>Kn=""},Rn={current:()=>_n,set:e=>_n=e,del:()=>_n=P},Qe={current:e=>Sn.get(e)||"SetState",set:(e,t)=>Sn.set(e,t),del:e=>Sn.delete(e)},et={current:()=>Dn,set:e=>Dn=e,del:()=>Dn=[]},fe={current:()=>An.get(Ko)||Kt,markUsing:e=>Ko=e,set:(e,t)=>An.set(e,t),del:e=>An.delete(e)},Tn={current:e=>vn.get(e),set:(e,t)=>vn.set(e,t),del:e=>vn.delete(e)},Tt={current:()=>Rt,set:(e,t)=>{Object.assign(Rt,{draftRoot:e,isAtom:t,isFake:!1})},del:()=>Rt=So},Mn={current:()=>En,set:e=>En=e,del:()=>En=Ao};function bn(e){const{FNKEY_STATIC_CTX_MAP:t,FNKEY_HOOK_CTX_MAP:n}=B();return e[0]==="s"?t:n}function Ii(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=B();Ye(n,e,[]).push(t)}function Fi(e,t){const{DEPKEY_COMPUTING_FNKEYS_MAP:n}=B(),r=n.get(e);r&&Z(r,t)}function Ci(e){const{DEPKEY_FNKEYS_MAP:t}=B(),{depKeys:n,fnKey:r}=e;n.forEach(o=>{const s=t.get(o)||[];Z(s,r)})}function Ro(e,t){const{FNKEY_STATIC_CTX_MAP:n}=B(),{fnKey:r,prevLevelFnKeys:o}=e;o.forEach(s=>{var a;const c=(a=n.get(s))==null?void 0:a.nextLevelFnKeys;c&&(t?w(c,r):Z(c,r))})}function Oi(){const{FNKEY_HOOK_CTX_MAP:e}=B();pe()&&e.forEach(t=>{t.isExpired=!0})}function To(e,t,n){const r=n||hn(t);return k(e)?e[yt]=r:(fo(e),e.__proto__[yt]=r),r}function Mo(e){return k(e)?e[yt]||"":X(e)&&e.__proto__[yt]||""}function Ae(e){return bn(e).get(e)}function wn(e){return bn(e).get(e)||Do}function tt(e){const t=Mo(e);return Ae(t)||null}function nt(){const{runningFnKey:e,depKeys:t,runningSharedKey:n,isIgnore:r,delPathAoa:o}=B();return{fnCtx:e?Ae(e):null,depKeys:t,delPathAoa:o,isIgnore:r,runningSharedKey:n}}function Pi(){return B().runningFnKey}var{USER_STATE:xi}=ee;function ki(e,t=8){let n="";if(pe()&&e)try{throw new Error("loc")}catch(r){const o=r.stack.split(`
`),s=o[1]||"";s.includes("webpack-internal")||s.includes("/node_modules/")?n=o.slice(0,16).join(" -> "):n=o.map(a=>a.substring(0,a.indexOf("(")).trim()).slice(4,t).join(" -> ")}return n}function bo(e){const[t,n]=e.split("/"),r=n.split(xe);return{sharedKey:Number(t),keyPath:r,depKey:e}}function wo(e){const{sharedKey:t,forAtom:n}=e,r=n?"/val":"",o=n?["val"]:[];return{depKey:`${t}${r}`,keyPath:o,sharedKey:t}}function $(e,t){try{return Ht(e.join(xe),t)}catch(n){return console.warn("found Symbol key in your path :",e),`${t}`}}function Li(e,t){const{snap:n,prevSnap:r,stateType:o}=e;if(xi!==o)return!0;const{keyPath:s}=bo(t);try{const c=he(n,s),a=he(r,s);return c!==a}catch(c){return!0}}function Ni(e,t){return Ve()?pt(e,{onOperate:t,compareVer:!0}):Se(e,{get(n,r){const o=n[r],s=Ze(r,o,{isChanged:!1,parentKeyPath:[]});return t(s),o}})}function Vi(e,t){if(t!==void 0){if(e)return{val:t};if(X(t))return t}}function Ui(e,t,n){const r=k(t)?t(n):t;return Vi(e,r)}function Mt(e,t){let{value:n}=e;if(t){t(e);const{replacedValue:r,isReplaced:o}=e.getReplaced();o&&(n=r)}return n}function Io(e){return[Ua,Va].includes(e)}function Bi(e){return Array.isArray(e)||Ut(e)}var{isObject:_e,getDataType:Fo}=Ur;function In(e,t){return typeof e=="boolean"?e:t}function Co(e,t){if(e===t)return e;const r=t.substring(e.length+1).split(xe);return`${e}${xe}${r[0]}`}function Yi(e,t){Ie(e,t)||w(e,t)}var Fn=new Map;function Oo(e,t){let n=!1;const{depKey:r,keyPath:o,sharedKey:s}=e,{stopDepInfo:c,level1ArrKeys:a,recordCb:i}=t,l=Fn.get(r);if(l)return i(l),!0;const{keys:f,isArrDict:u,depth:d,arrKeyStopDcit:p,stopArrDep:y}=c,g=Ie(a,r),m=o.length>d;if(m||g){let S="",T=d;return g&&(T=d+1,p[g]===!1||y&&(m?S=$(o.slice(0,T),s):S=Co(g,r))),S||(S=$(o.slice(0,T),s)),g||Fn.set(r,S),i(S),!0}const E=String(s);for(const S of f){if(!r.startsWith(S)||S===E)continue;const T=u[S],K=T?Co(S,r):S;T||Fn.set(r,K),i(K),n=!0;break}return n}function Cn(e,t){const n=te(),{runningKey:r}=n;if(r){const{KEY_DYNAMIC_CTX_MAP:o,KEY_CTX_MAP:s,isDynamic:c}=n,i=(c?o:s).get(r);if(i){const{results:l,depKeys:f}=i;t?w(l,t):e.forEach(u=>w(f,u))}}}function bt(e,t){const n=ie(),{COMPARE_MAP:r}=n;let o=r.get(t);return o!==void 0?o:e.sharedKeyStr===t?n.isStateChanged:(o=Li(e,t),r.set(t,o),o&&(n.isStateChanged=!0),o)}function Po(e,t,n){if(t.includes(n)&&bt(e,n))return!0;let r=!1;for(const o of t)o.startsWith(n)&&bt(e,o)&&(r=!0);return r}function Hi(){const e=ie();e.COMPARE_MAP.clear(),e.isStateChanged=!1}function On(e=!0){const t=B();t.isIgnore=e}function Le(e,t){const{fnCtx:n,depKeys:r,isIgnore:o}=nt(),s=t.specificCtx||n;if(!s){Rn.current()(e);return}const{DEPKEY_FNKEYS_MAP:c,SKEY_FNKEYS_MAP:a}=B(),{belongCtx:i,sharedKey:l}=t;if(l&&w(s.depSharedKeys,l),n&&i){n.isFirstLevel=!1,i.isAsync&&(n.isAsync=!0);const u=i.fnKey;w(s.prevLevelFnKeys,u),w(i.nextLevelFnKeys,n.fnKey)}const{fnKey:f}=s;e.forEach(u=>{if(Ca===u||o)return;n&&w(r,u);const d=Ye(c,u,[]);w(d,f);const[p]=u.split("/"),y=Ye(a,p,[]);w(y,f)})}function Pn(e){e&&e.depKeys.forEach(t=>Le([t],{specificCtx:e}))}function xo(e){const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=B(),{fnKey:r}=e;t.set(r,e),Ro(e,!0);let o=n.get(r);o?o.c=2:(o={c:1,t:Date.now(),prev:0},n.set(r,o));const{c:s}=o;if(s===2){const c=Ae(r);Pn(c)}}function ko(e){let t="";return e.depSharedKeys.forEach(n=>{var o;const r=((o=Je(n))==null?void 0:o.ver)||0;t+=`${r}_`}),t}function Gi(e,t,n,r=!1){const{DEPKEY_FNKEYS_MAP:o,SKEY_FNKEYS_MAP:s}=B(),a=(r?s:o).get(t)||[],i=[],l=[];return a.forEach(f=>{const u=Ae(f);if(u&&Po(e,u.depKeys,t)){u.isFirstLevel&&i.push(f),u.isAsync&&u.fnType===qr&&l.push(f);const d=n[f];d===void 0?n[f]=1:r||(n[f]=d+1)}}),{firstLevelFnKeys:i,asyncFnKeys:l}}function xn(e){Ci(e),Ro(e)}function ji(){const{FNKEY_HOOK_CTX_MAP:e}=B();if(e.size>=Na){const t=Date.now();e.forEach(n=>{const{mountStatus:r,createTime:o,fnKey:s}=n;[Et,Zr].includes(r)&&t-o>Jr&&(xn(n),e.delete(s))})}}function kn(e,t,n,r,o,s=!1,c=!1){const a=te();a.latest={sharedKey:e,val:t,stateOrResult:n,depKey:r,keyPath:o,isDerivedResult:s,isDerivedAtom:c}}function $i(){return te().latest}function Lo(e){const{KEY_DYNAMIC_CTX_MAP:t,KEY_CTX_MAP:n}=te();return e?t:n}function No(){return Ce("changing shared state is invalid"),!0}function wt(e,t,n,r,o){return r===Pe?e?t:!1:r===ht?n:o}function Ln(e,t,n){e.replaceValue(wt(e.keyPath.length===0,t,n,e.key,e.value))}function Wi(e){let t={};const{rawState:n,sharedKey:r,forAtom:o,onRead:s,isPrimitive:c,stopDepth:a}=e,i=(f,u)=>{const d=$(f,r);Le([d],{sharedKey:r}),Cn([d]),kn(r,u,t,d,f)};if(Oa)t=pt(n,{customKeys:mt,onOperate:f=>{const{isBuiltInFnKey:u,isCustom:d}=f;if(d)return Ln(f,o,r);if(!u){const{fullKeyPath:p}=f,y=Mt(f,s);i(p,y)}},compareVer:!0});else{const f=(u,d,p)=>Xe(u,{set:No,get:(y,g)=>{const m=y[g];if(mt.includes(g))return wt(d===1,o,r,g,m);const E=Ze(g,m,{isChanged:!1,parentKeyPath:p});if(d<a&&_e(m))return f(m,d+1,E.fullKeyPath);const S=Mt(E,s);return i(E.fullKeyPath,S),S}});t=f(n,1,[])}let l=t;return o&&(c?l=n.val:l=Se(n,{set:No,get:(f,u)=>t.val[u]})),yi(r,t),{sharedRoot:t,sharedState:l}}var Vo=null;function Nn(){return Vo}function Xi(e,t){const n=H();let r=n.globalEmpty;if(!r){const{stateRoot:o}=t({apiCtx:e,rawState:{},forGlobal:!0,stateType:ee.GLOGAL_EMPTY}),s=Y(o);n.globalEmpty=o,n.globalEmptyInternal=s}return Vo=r,r}function Vn(e){const{GID_INSKEYS_MAP:t}=B();return Ye(t,e,[])}function zi(){return H().globalEmptyInternal}function Uo(e,t){if(!e)return;const n=Vn(e);w(n,t)}function Ji(e,t){if(!e)return;const n=Vn(e);Z(n,t)}var{REACTIVE:Zi}=j,rt=new Map;function qi(e){return!!(e&&!e.expired&&e.modified)}function Qi(e){const{sharedKey:t}=e;e.expired=!0,fe.del(e.key);const n=Qe.current(t);return Qe.del(t),e.finish(null,{desc:n})}function Bo(e,t){const n=ue(e);return t&&Qe.set(n,t),n}function Un(e,t){const n=ue(e);ot(n,t)}function eu(){const e=fe.current();e.isTop&&ot(e.sharedKey,e.desc)}function ot(e,t){const n=rt.get(e);qi(n)&&(t&&Qe.set(e,t),Qi(n))}function tu(e){const t=rt.get(e)||Kt;t.expired=!0}function nu(e,t){const n=rt.get(e)||Kt;n.modified=!0,n.nextTickFlush(t)}function ru(e,t){const{from:n=Zi,onRead:r}=t,{finish:o,draftRoot:s}=e.setStateFactory({isReactive:!0,from:n,handleCbReturn:!1,enableDep:!0,onRead:r}),c=Eo(s,t,o);return c.key=_i(),c.sharedKey=e.sharedKey,c.nextTickFlush=a=>{const{expired:i,hasFlushTask:l}=c;i||(c.data=[a]),l||(c.hasFlushTask=!0,Promise.resolve().then(()=>{const[f]=c.data;ot(e.sharedKey,f)}))},c}function Yo(e,t,n){const{sharedKey:r}=e,{insKey:o=0,from:s}=t;let c=rt.get(r)||Kt;c.expired&&(c=ru(e,{isTop:!0,from:s}),rt.set(r,c),fe.set(c.key,c),c.fnKey=qe.current()),fe.markUsing(c.key),c.onRead=o?t.onRead:void 0,c.insKey=o;const{draft:a}=c;return{val:n?a.val:a,meta:c}}function Bn(e,t){let n={},r={};const{rawState:o,deep:s,forAtom:c,isPrimitive:a,sharedKey:i}=e;if(Gt(s)){const l={[ht]:i,[Pe]:c},f=(d,p,y)=>{const{val:g}=Yo(e,t,d);return g[p]=y,!0},u=(d,p,y)=>{const g=y[p];if(g!==void 0)return g;const{val:m,meta:E}=Yo(e,t,d);return zr===p?E:m[p]};if(n=new Proxy(o,{set:(d,p,y)=>f(!1,p,y),get:(d,p)=>u(!1,p,l)}),r=n,c){const d=G(C({},l),{[Pe]:!1});r=a?o.val:new Proxy(o.val,{set:(p,y,g)=>f(!0,y,g),get:(p,y)=>u(!0,y,d)})}}else n=o,r=o.val;return{draftRoot:n,draft:r}}function ou(e){const{UNMOUNT_INFO_MAP:t}=yo(),{insKey:n,readMap:r,internal:o}=e;o.mapInsCtx(e,n);let s=t.get(n);s?(s.c=2,s.prev=n-1):(s={c:1,t:Date.now(),prev:0},t.set(n,s));const{c}=s;c===2&&Object.keys(r).forEach(a=>{o.recordDep(a,n)})}function Ho(e){const{readMap:t,insKey:n,internal:r}=e;Object.keys(t).forEach(o=>r.delDep(o,n)),r.delInsCtx(n)}function su(e){const{canCollect:t,isFirstRender:n,currentDepKeys:r}=e;if(!t){n&&(e.depKeys=r.slice());return}e.depKeys=r.slice()}function cu(e){const{canCollect:t}=e;t&&(e.readMap={},e.delReadMap={},e.depKeys=e.currentDepKeys.slice(),e.currentDepKeys.length=0)}function Go(e,t,n){if(!e.canCollect)return;const{parentType:r,rawVal:o}=n,s=Bi(o);s&&Yi(e.internal.level1ArrKeys,t.depKey),e.recordDep(t,r,s)}function Yn(e,t){const{depKeys:n,currentDepKeys:r,fixedDepKeys:o}=e;return(t?r:n).concat(o)}function au(e){if(!e)return;const{updater:t,mountStatus:n,createTime:r}=e;if(n===Et){Date.now()-r>Jr?Ho(e):e.needEFUpdate=!0;return}t()}function jo(e){const{internal:t,isReactive:n,insKey:r}=e,{rawState:o,isDeep:s,sharedKey:c,onRead:a,forAtom:i}=t;if(s){const l=f=>{const{isBuiltInFnKey:u,key:d}=f;if(u)return;if(Bt(d))return Ln(f,i,c);const{fullKeyPath:p,keyPath:y,parentType:g}=f,m=Mt(f,a),S={depKey:$(p,c),keyPath:p,parentKeyPath:y,sharedKey:c};Go(e,S,{parentType:g,rawVal:m})};if(n){const{draft:f,draftRoot:u}=Bn(t,{onRead:l,insKey:r});e.proxyState=u,e.proxyStateVal=f}else e.proxyState=pt(o,{onOperate:l,compareVer:!0})}else e.proxyState=Se(o,{set:()=>(Ce("changing shared state is invalid"),!0),get:(l,f)=>{const u=l[f];if(Bt(f))return wt(!0,i,c,f,u);const d=Mt(Ze(f,u,{isChanged:!1,parentKeyPath:[]}),a),p=Ht(f,c),y=_e(l)?At:Ba;return Go(e,{depKey:p,keyPath:[f],sharedKey:c},{parentType:y,rawVal:d}),d}})}function iu(e){var D;const{updater:t,sharedState:n,id:r="",globalId:o="",collectType:s="every",deps:c,pure:a=!0,arrDep:i=!0,isReactive:l=!1}=e,f=i&&(D=e.arrIndexDep)!=null?D:!0,u=Y(n);if(!u)throw new Error("ERR_OBJ_NOT_SHARED: input object is not a result returned by share api");const d=vi(),{rawState:p,isDeep:y,ver:g,ruleConf:m,level1ArrKeys:E,forAtom:S,sharedKey:T,sharedKeyStr:K,snap:F}=u,{stopDepInfo:b}=m,R={readMap:{},delReadMap:{},pure:a,depKeys:[],fixedDepKeys:[],currentDepKeys:[],isDeep:y,isReactive:l,insKey:d,internal:u,rawState:p,sharedState:n,sharedKey:T,proxyState:{},proxyStateVal:{},updater:t,mountStatus:Et,renderStatus:We,needEFUpdate:!1,createTime:Date.now(),rootVal:null,ver:g,id:r,globalId:o,collectType:s,canCollect:s!=="no",isFirstRender:!0,subscribe:h=>{h()},extra:{},getDeps:()=>Yn(R,!0),renderInfo:{isAtom:S,setDraft:u.insSetDraft,time:Date.now(),sn:0,snap:F,insKey:d,getDeps:()=>Yn(R,!0),getPrevDeps:()=>Yn(R,!1)},recordDep:(h,v,A)=>{let _=h.depKey;Oo(h,{stopDepInfo:b,level1ArrKeys:E,recordCb:re=>{_=re}});const{renderStatus:M,fixedDepKeys:I}=R;if(M===ln)return;const{readMap:O,insKey:Me,currentDepKeys:L,delReadMap:x}=R;Le([_],{}),Pi()&&(Z(L,_),w(R.fixedDepKeys,_));const ne=()=>{O[_]=1,u.recordDep(_,Me),I.includes(_)||w(L,_)};if(!O[_]&&!x[_]){const{parentKeyPath:re}=h;if(a&&v===At&&re){const de=re.length?$(re,T):K;O[de]&&(delete O[de],x[de]=1,Z(L,de))}const be=Io(v);if(be){f&&ne();return}(!A||!be&&i)&&ne()}}};if(o&&Uo(o,d),jo(R),u.mapInsCtx(R,d),u.recordId(r,d),k(c)){const h=S?R.proxyState.val:R.proxyState,v=W(c,h),A=R.getDeps().slice();v.includes(h)&&A.push(u.rootValKey),R.fixedDepKeys=A}return R}function $o(e){const{result:t,forAtom:n}=e;e.proxyResult=Se(t,{set:()=>(Ce("changing derived result is invalid"),!1),get:(r,o)=>$e===o?n:(We===e.renderStatus&&Pn(e),t[o])})}function uu(e){const{proxyState:t,internal:n,renderInfo:r,canCollect:o,isReactive:s}=e,{sharedKey:c,sharedKeyStr:a,insSetState:i,forAtom:l}=n;r.snap=n.snap,r.time=Date.now();const f=l?t.val:t;return e.isFirstRender&&(e.rootVal=f,Tn.set(e.rootVal,e)),!l&&o&&e.recordDep({depKey:a,keyPath:[],sharedKey:c},At),[s?t:f,i,r]}function fu(e,t){if(t&&!ke(e))throw new Error("useAtom only accept atom")}function lu(e){const{ver:t,internal:{ver:n}}=e;t!==n&&(e.ver=n,jo(e))}function du(e){e.mountStatus=vt;const{id:t,globalId:n,insKey:r}=e;e.internal.recordId(t,r),Uo(n,r),ou(e)}function pu(e){e.mountStatus=Zr;const{id:t,globalId:n,insKey:r}=e;e.internal.delId(t,r),Ji(n,r),Ho(e)}function yu(e,t){const n=Y(t).sharedKey;return e.internal.sharedKey!==n}function It(e,t,n,r){if(H().isRootRender)try{const o=r||n;e.react.useSyncExternalStore(t,n,o)}catch(o){console.error(o)}}var hu=null;function Wo(e,t,n){const{hookImpl:r,react:o}=e,s=r.useForceUpdate(),c=o.useRef({ctx:hu});let a=c.current.ctx;return(!a||yu(a,t))&&(a=iu(C({updater:s,sharedState:t},n)),c.current.ctx=a),a}function Xo(e,t){e.react.useEffect(()=>(t.isFirstRender=!1,Tn.del(t.rootVal),t.collectType==="first"&&(t.canCollect=!1),t.needEFUpdate&&(t.needEFUpdate=!1,t.updater()),du(t),()=>{pu(t)}),[t])}function mu(e,t,n,r){n.renderStatus=We,cu(n),It(e,n.subscribe,()=>Y(t).snap),e.react.useEffect(()=>{n.renderStatus=ln,n.isFirstRender=!1,su(n)})}function Hn(e,t,n={}){const r=Wo(e,t,n);return It(e,r.subscribe,()=>Y(t).snap),Xo(e,r),r}function Ft(e,t,n={}){const{forAtom:r}=n;fu(t,r);const o=Wo(e,t,n);return mu(e,t,o,n),Xo(e,o),lu(o),{tuple:uu(o),insCtx:o}}function zo(e,t){const{forAtom:n,label:r,strict:o=!1}=t||{};let s;if(typeof e=="number"?s=Je(e):s=Y(e),!s&&e){const a=e[zr];s=Je(a==null?void 0:a.sharedKey)}let c=r?`[[${r}]] err:`:"err:";if(!s)if(o)ye(`${c} not a valid shared or atom`,{throwErr:!0});else return null;return n!==void 0&&(n&&!s.forAtom&&ye(`${c} expect a shared but recived a atom`,{throwErr:!0}),!n&&s.forAtom&&ye(`${c} expect a atom but recived a shared`,{throwErr:!0})),s}function De(e,t){return zo(e,G(C({},t||{}),{strict:!0}))}var{MUTATE:gu,LOADING:Eu}=j,{GLOGAL_LOADING:vu,PRIVATE_LOADING:Su}=ee,{PRIVATE:Au,GLOBAL:_u}=un,Jo={},Du={},Ku={time:0,sn:0,getDeps:Fe,getPrevDeps:Fe,insKey:0,setDraft:P,isAtom:!1},Ru=[Ke(Jo,Du,gu),P,Ku];function Tu(e,t){const{internal:n,apiCtx:r}=t,{mutateFnDict:o,moduleName:s}=n,c={};Object.keys(o).forEach(l=>{c[l]={loading:!1,err:null,ok:!0}});const a=s?`${s}@Loading`:"";return e({apiCtx:r,rawState:c,isLoading:!0,stateType:Su},{moduleName:a}).state}var Zo=null;function Mu(){return Zo}function qo(){return H().globalLoadingInternal}function bu(e,t){const n=H();let r=n.globalLoading;if(!r){const{stateRoot:o}=t({apiCtx:e,rawState:{},stateType:vu},{moduleName:xa}),s=Y(o);n.globalLoadingInternal=s,n.globalLoading=o}return Zo=r,r}function Gn(e,t){let n=t;return Bt(t)&&(n=t.toString()),`${e}>${n}`}function Qo(e,t,n){if(!t)return;const{loadingInternal:r}=e;r.innerSetState(o=>{o[t]=n},{from:Eu}),n.err&&(io(e,an.ON_ERROR_OCCURED,{err:n.err}),console.error(n.err))}function Ke(e,t,n){let r=e[n];return r||(r=Se(t,{get(o,s){const c=Gn(n,s);return o[c]||{loading:!1,ok:!0,err:null}}}),e[n]=r),r}function st(e,t){const{internal:n,from:r}=t,{stateType:o,recordLoading:s}=n,c=ee.USER_STATE===o;let a=Ke(Jo,{},r),i={};if(c)if(Au===s)i=n.extra.loadingProxy,i||(i=Tu(e,t),n.extra.loadingProxy=i,n.loadingInternal=Y(i)),a=Ke(n.extra,i,r);else if(_u===s){const l=qo();i=Mu(),n.loadingInternal=l,a=Ke(l.extra,i,r)}else i=Nn();else i=n.sharedState,a=Ke(n.extra,i,r);return{loadingState:a,loadingProxy:i}}function es(e,t){if(!_e(t))return e;const n=Object.keys(t);if(!n.length)return e;const r=t[n[0]];return r.__sharedKey?G(C({},e),{internal:De(r.__sharedKey)}):e}function ts(e,t){const{internal:n,from:r,apiCtx:o}=t,{stateType:s}=n,c=ee.USER_STATE===s;st(e,t);let a=()=>Ru;return c&&(a=i=>{const l=es(t,i),f=st(e,l).loadingProxy,{insCtx:{proxyState:u,internal:d,extra:p,renderInfo:y}}=Ft(o,f);return[Ke(p,u,r),d.setState,y]}),{useLoading:a,getLoading:i=>{const l=es(t,i);return st(e,l).loadingState}}}function Ct(e){const t=vo();return Object.assign(t,e||{})}function Re(){const e=B(),{runningFnKey:t}=e;if(!t)return[];const n=Ae(t);let r=[];if(n){const{depKeys:o,delPathAoa:s,runningSharedKey:c}=e,{depKeys:a}=n,i={};o.forEach(f=>i[f]=1),o.forEach(f=>{const u=hr(i,f);u&&u!==f&&delete i[u]}),Object.keys(i).forEach(f=>w(a,f)),s.forEach(f=>{const u=f.length;for(let d=1;d<=u;d++){const p=$(f.slice(0,d),c);Z(a,p)}}),r=a.slice()}return e.runningFnKey="",e.depKeys=[],e.delPathAoa=[],e.runningSharedKey=0,r}function jn(e,t){const n=B();n.runningFnKey=e,n.runningSharedKey=t,n.isIgnore=!1}function ns(e,t){const{specificProps:n,fnCtxBase:r}=t,{scopeType:o}=n,s=To(e,o),c=C({fn:e,fnKey:s},n),a=r?Object.assign(r,c):Ct(c);return bn(o).set(s,a),a}function $n(e){var o;const{FNKEY_HOOK_CTX_MAP:t,UNMOUNT_INFO_MAP:n}=B(),{fnKey:r}=e;xn(e),e.extra.deferedWatch=null,t.delete(r),((o=n.get(r))==null?void 0:o.c)===2&&n.delete(r),ji()}function rs(e){const{DEPKEY_COMPUTING_FNKEYS_MAP:t}=B(),{prevLevelFnKeys:n,depKeys:r}=e;let o=!1;for(const s of r){const c=t.get(s)||[];if(ct(c,n)){o=!0;break}}return o}function wu(e,t=!0,n=xe){return e.map(r=>{const[o,s]=r.split("/"),c=s.split(xe);return`${t?`${Je(Number(o)).usefulName}/`:""}${c.join(n)}`})}var Ot=new Map,Pt={WATCH:"1",MUTATE:"2"},Iu={[Pt.WATCH]:"watch",[Pt.MUTATE]:"mutate fn or task"};function Fu(e=0){return{sn:e,descs:[],errs:[],timer:null,cycle:[]}}function os(e,t,n){const r=new Error(`DEAD_CYCLE: module(${e}) found mutate fn(${n}) in these dead cycle fns [${t.join(",")}]`);return r.cause="DeadCycle",r.data=t,r}function Cu(e){Ot.delete(e)}function Ou(e,t,n,r){const o=Iu[r],{desc:s,task:c,fn:a,isFake:i}=t.subFnInfo,l=s?`(${s})`:"",f=`DEAD_CYCLE: found reactive object in ${o}${l} cb is changing module(${e.usefulName})'s some of these dep keys(${wu(n,!1,".")}), it will cause a infinity loop call!`,u=i?t.fn:c||a;return{err:new Error(`[only-dev-mode alert] ${f}`),tipFn:()=>console.error(` ${f} open the stack to find the below fn: 
`,u)}}function Pu(e,t,n){if(e&&n){const{usefulName:r}=e,o=Ye(Ot,r,Fu(t));o.sn!==t&&(o.descs=[],o.errs=[]);const{descs:s}=o;if(s.length>1&&s[0]===n){const c=s.slice();throw o.cycle=c,s.length=0,os(r,c,n)}w(s,n)}}function Wn(e,t){t.tipFn(),ye(t.err,{logErr:!1,throwErr:!1,alertErr:e.alertDeadCycleErr})}function Te(e,t,n){const{depKeys:r,subFnInfo:o}=t;let s=t.depKeys,c=n;r.length>n.length&&(s=n,c=r);let a=!1;if(ct(s,c)){const i=o.desc?Pt.MUTATE:Pt.WATCH,l=Ou(e,t,n,i);Wn(e,l),t.dcErrorInfo=l,a=!0}return a}function xu(e,t){const n=Ot.get(e);return!n||!n.cycle.includes(t)?{isIn:!1,cycle:[]}:{isIn:!0,cycle:n.cycle}}function ku(e,t,n=!0){const r=Ot.get(e);if(!r)return;const{timer:o,errs:s}=r;s.push(t),o&&clearTimeout(o),r.timer=setTimeout(()=>{let c=null;for(const a of s)c?a.data.length>c.data.length&&(c=a):c=a;c&&ye(c,{alertErr:n}),s.length=0},0)}function Xn(e,t=0){const n=Ae(e);n&&(n.showLoading&&(n.setLoading(!0),n.updater()),t&&(n.remainRunCount+=t))}var{MAY_TRANSFER:Lu}=St;function Nu(e,t){const{isFirstCall:n=!1,triggerReasons:r=[],sn:o=0,from:s,internal:c=_o,desc:a,fromFnKey:i}=t;if(e.dcErrorInfo.err){Wn(c,e.dcErrorInfo);return}if(e.fnKey===i){Te(c,e,e.depKeys);return}if(e.isSimpleWatch||!e.checkDeadCycle)return e.fn({isFirstCall:n,triggerReasons:r,sn:o});if(j.MUTATE===s&&Pu(c,o,a),e.isRunning&&Te(c,e,t.depKeys||[]))return;const l=fe.current();if(l.fnKey===e.fnKey&&Te(c,e,l.writeKeys)||(ot(l.sharedKey,l.desc),e.isRunning===!0&&l.isTop&&Te(c,e,l.writeKeys)))return;e.isRunning=!0,qe.set(e.fnKey);const u=e.fn({isFirstCall:n,triggerReasons:r,sn:o});qe.del();const d=fe.current();if(!(d.isTop&&d.fnKey===e.fnKey&&Te(c,e,d.writeKeys))&&!(u&&u.task&&d.from===j.MUTATE&&Te(c,e,e.subFnInfo.writeKeys)))return e.isRunning=!1,u}function ss(e,t,n){let r=t.val;return n||(r=t),{input:W(e,{state:r,stateRoot:t,isAtom:n}),state:r,stateRoot:t}}function Ne(e,t={}){const{isFirstCall:n=!1,forceFn:r=!1,forceTask:o=!1,throwErr:s=!1,triggerReasons:c=[],watchFnKeys:a=[],skipWatch:i=!1,sn:l=0,err:f,unbox:u=!1,internal:d=_o}=t,p=Ae(e),y=(L=null)=>{if(L&&s)throw L;const x=p||Do;return u?[x.result.val,L]:[x.result,L]};if(!p)return y(new Error(`not a valid watch or derive cb for key ${e}`));if(p.fnType===Qr)return i?w(a,p.fnKey):Nu(p,t);const{isAsync:g,fn:m,task:E,isAsyncTransfer:S,forAtom:T,result:K,depKeys:F}=p;p.remainRunCount>0&&(p.remainRunCount-=1);const b=L=>{const x=T?{val:L}:L;!p.returnUpstreamResult&&x&&Object.assign(p.result,x),p.shouldReplaceResult=!0},R=()=>{p.renderInfo.sn=l,p.updater()},D=L=>{const{data:x,err:ne=null}=L;ne?p.setLoading(!1,ne):(b(x),n?g&&p.status.loading&&!rs(p)&&p.setLoading(!1,ne):p.remainRunCount===0&&p.setLoading(!1,ne)),R();const re={isFirstCall:n,sn:l,triggerReasons:c,err:ne,watchFnKeys:a,skipWatch:i};p.nextLevelFnKeys.forEach(be=>{Ne(be,re)})},h=T?K:K.val,{deps:v,isStateAtom:A}=p,{input:_,state:M,stateRoot:I}=ss(v,p.stateRoot,A),O={isAtom:p.isStateAtom,state:M,stateRoot:I,isFirstCall:n,prevResult:h,triggerReasons:c,input:_,sn:l};if(!g||r||g&&!E){const L=m(O);return D({data:L}),y()}if(g&&n&&p.nextLevelFnKeys.forEach(L=>Xn(L,0)),S)return D({err:f}),y();if(p.asyncType===Lu){const L=m(O);return D({data:L}),y()}if(E){let L=Dc;return n?(F.forEach(x=>Ii(x,e)),L=()=>F.forEach(x=>Fi(x,e))):o&&p.nextLevelFnKeys.forEach(x=>Xn(x)),Promise.resolve(()=>{const x=E(O);return Yt(x)?x:(ye("ERR_NON_FN: derive task arg should be async function!",{throwErr:s}),null)}).then(x=>x()).then(x=>(L(),D({data:x}),y())).catch(x=>{if(L(),D({err:x}),s)throw x;return uo(d,x),y(x)})}return y(f)}function xt(e,t){const n=tt(e);if(!n)throw new Error("[Helux]: not a derived result");return Ne(n.fnKey,C({},t||{}))}function Vu(e,t){return xt(e,{forceFn:!0,throwErr:t})}function Uu(e,t){return Promise.resolve(xt(e,{forceTask:!0,throwErr:t}))}function Bu(e,t){return xt(e,{forceFn:!0,throwErr:t,unbox:!0})}function Yu(e,t){return Promise.resolve(xt(e,{forceTask:!0,throwErr:t,unbox:!0}))}function Hu(e){const t=tt(e);return t?t.status:{loading:!1,err:null,ok:!0}}function zn(e,t,n){const r=e.get(t);r&&(r.renderInfo.sn=n,au(r))}function Gu(e){const{mutateCtx:t,internal:n}=e,{ids:r,globalIds:o,depKeys:s,triggerReasons:c,isFirstCall:a,from:i,sn:l,desc:f,fnKey:u}=t,{key2InsKeys:d,id2InsKeys:p,insCtxMap:y,rootValKey:g}=n;let m=[],E=[],S=[],T=[];const K={};if(a){const v=Re();et.set(v)}const F=(v,A=!1)=>{const{firstLevelFnKeys:_,asyncFnKeys:M}=Gi(n,v,K,A);S=S.concat(_),T=T.concat(M)},b=v=>{if(!bt(n,v))return;const A=d[v]||[],_=[];for(const M of A){if(m.includes(M))continue;const I=y.get(M);if(!I)continue;const O=I.getDeps();if(O[0]===g){bt(n,g)&&_.push(M);continue}Po(n,O,v)&&_.push(M)}m=m.concat(_),F(v)};s.forEach(v=>b(v)),s.includes(g)||b(g),F(g,!0),Hi(),r.forEach(v=>{m=m.concat(p[v]||[])}),o.forEach(v=>{Vn(v).forEach(A=>w(E,A))}),m=we(m),S=we(S),T=we(T),T.forEach(v=>Xn(v,K[v]));const R=[],D={depKeys:s,sn:l,from:i,triggerReasons:c,watchFnKeys:R,skipWatch:!0,internal:n,desc:f,isFirstCall:a,fromFnKey:u};S.forEach(v=>Ne(v,D));const h={depKeys:s,sn:l,from:i,triggerReasons:c,internal:n,desc:f,isFirstCall:a,fromFnKey:u};if(R.forEach(v=>Ne(v,h)),m.forEach(v=>zn(y,v,l)),E.length){const v=zi().insCtxMap;E.forEach(A=>zn(v,A,l))}}function ju(e){const{state:t,internal:n,mutateCtx:r}=e,{rawState:o,isDeep:s,ver:c,snap:a}=n;s?(n.prevSnap=c===0?C({},a):a,n.snap=t,Object.assign(o,t)):n.snap=C({},o),n.ver+=1,n.sn=r.sn,Gu(e)}var{MUTATE:cs}=j;function as(e,t){const{writeKey:n,ids:r,internal:o,opParams:s}=t,{snap:c}=o,{fullKeyPath:a,value:i}=s;Object.keys(e).forEach(l=>{n.startsWith(l)&&he(c,a)!==i&&e[l].forEach(f=>w(r,f))})}function is(e,t){const{isChanged:n,fullKeyPath:r,keyPath:o,parentType:s,value:c}=e,{internal:a,mutateCtx:i}=t,{arrKeyDict:l,isReactive:f,readKeys:u,from:d}=i,{sharedKey:p}=a,y=Io(s),g=fe.current();if(e.op==="get"){y&&(l[$(o,p)]=1);const M=$(r,p);u[M]=1,i.enableDep&&(g.onRead?g.onRead(e):(nt().fnCtx&&Le([M],{sharedKey:p}),f&&(Cn([M]),kn(p,c,a.sharedState,M,r))));return}if(cs===d){const{delPathAoa:M,fnCtx:I}=nt();I&&M.push(o)}if(!n)return;const{moduleName:m,ruleConf:E,level1ArrKeys:S}=a,{writeKeyPathInfo:T,ids:K,globalIds:F,writeKeys:b}=i,R=$(r,p);if(g.key&&(g.isTop?w(g.writeKeys,R):g.from===cs&&w(wn(g.fnKey).subFnInfo.writeKeys||[],R)),y){const M=$(o,p);T[M]={sharedKey:p,moduleName:m,keyPath:o},b[M]=1}const{hasIds:D,hasGlobalIds:h,stopDepInfo:v}=E;T[R]={sharedKey:p,moduleName:m,keyPath:r};const A=hr(l,R);A&&(b[A]=1),Oo({sharedKey:p,keyPath:r,depKey:R},{stopDepInfo:v,level1ArrKeys:S,recordCb:M=>{b[M]=1}})||(b[R]=1),D&&as(E.idsDict,{ids:K,writeKey:R,internal:a,opParams:e}),h&&as(E.globalIdsDict,{ids:F,writeKey:R,internal:a,opParams:e}),f?nu(p,g.desc):tu(p)}function us(e,t){Object.keys(t).forEach(n=>{e[n]=t[n]})}function kt(e,t){if(!t)return e;On(!0);const n=e.val;return On(!1),n}function fs(e){const{partial:t,forAtom:n,draftRoot:r,draftNode:o}=e;if(!t)return;if(!n){_e(t)&&us(o,t);return}const s=t.val;if(_e(o)){_e(s)?us(o,s):console.warn("dict atom deny to handle a non-dict returned value!");return}r.val=s}function $u(e,t){const{internal:n,mutateCtx:r}=e,o=kt(t,n.forAtom),{from:s,sn:c,desc:a}=r;n.before({from:s,draftRoot:t,draft:o,desc:a,sn:c}),qa(n,t,o,c)}function ls(e,t,n,r){const{mutateCtx:o,internal:s}=e,{writeKeys:c,writeKeyPathInfo:a,handleCbReturn:i}=o,{forAtom:l}=s;i&&fs({partial:r,forAtom:l,draftRoot:t,draftNode:n}),$u(e,t),o.depKeys=Object.keys(c),Tt.del(),Mn.del(),e.state=cn(t),e.state!==s.rawState&&(o.triggerReasons=Object.values(a),ju(e),ni(s,o))}function ds(e,t){const{ids:n,globalIds:r,from:o,desc:s,fnKey:c}=t;n&&n.forEach(a=>w(e.ids,a)),r&&r.forEach(a=>w(e.globalIds,a)),o&&(e.from=o),s&&(e.desc=s),c&&(e.fnKey=c)}function Wu(e){const{internal:t,setFactoryOpts:n}=e,{forAtom:r,rawState:o}=t,s=mn(n),c=sn(o,{customKeys:mt,onOperate:i=>{if(i.isCustom)return Ln(i,r,t.sharedKey);is(i,{internal:t,mutateCtx:s})}});Tt.set(c,r),Mn.set(s);const a=kt(c,r);return r&&(s.readKeys={}),{draftRoot:c,draftNode:a,finishMutate(i,l={}){ds(s,l),ls({state:{},mutateCtx:s,internal:t},c,a,i)}}}function Xu(e){return fo(e),pi(e)}function zu(e){if(!e)return{};const{desc:t,ids:n,globalIds:r}=e;return{desc:t,ids:n,globalIds:r}}function Ju(e){const{forAtom:t=!1}=e;let n=e.rawState;const r=k(n);let o=!1;if(t)n=r?{val:n()}:{val:n},o=!n.val||!yr(n.val);else{if(n=r?n():n,!X(n))throw new Error("ERR_NON_OBJ: pass an non-object to createShared!");if(ue(n))throw new Error("ERR_ALREADY_SHARED: pass a shared object to createShared!")}return{isPrimitive:o,rawState:n}}function ps(e,t,n){let r=null,o=t||"";if(k(e)&&e!==P)r={[Xr]:1,fn:e,deps:Fe,oriDesc:o,onlyDeps:!1,desc:o,depKeys:[],writeKeys:[],checkDeadCycle:void 0,watchKey:"",isFake:!1,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}};else if(X(e)){const{fn:s,desc:c,deps:a,task:i,immediate:l,checkDeadCycle:f,onlyDeps:u=!1}=e,d=t||c||"",p=k(s)?s:void 0,y=k(i)?i:void 0,g=k(a)?a:Fe;(s||i)&&(r={[Xr]:1,checkDeadCycle:f,fn:p,watchKey:"",desc:d,oriDesc:d,deps:g,task:y,onlyDeps:u,immediate:l,depKeys:[],writeKeys:[],isFake:!1,enabled:!0,extraBound:{state:{},stateRoot:{},isAtom:!1}})}if(r&&n){const{oriDesc:s}=r;(!s||n[s])&&(r.desc=hn(j.MUTATE))}return r}function ys(e,t,n=!0){const r={},o=t||{};if(!e)return r;const s=(c,a)=>{const i=ps(c,a,o);i&&(i.enabled=n,r[i.desc]=i,o[i.desc]=i)};if(Array.isArray(e))if(e.length===1){const c=e[0],a=(X(c)?c.desc:"")||gt;s(e[0],a)}else e.forEach(c=>s(c));else k(e)?s(e,gt):X(e)&&Object.keys(e).forEach(c=>{s(e[c],c)});return r}function Zu(e,t={}){var D,h,v,A,_;const{forAtom:n=!1,forGlobal:r=!1,stateType:o=ee.USER_STATE}=e,{rawState:s,isPrimitive:c}=Ju(e),a=Xu(s),i=t.moduleName||"",l=(D=t.alertDeadCycleErr)!=null?D:pe(),f=(h=t.deep)!=null?h:!0,u=(v=t.checkDeadCycle)!=null?v:!0,d=(A=t.enableMutate)!=null?A:!0,p=t.recordLoading||un.PRIVATE,y=t.rules||[],g=t.before||P,m=t.mutate||P,E=(_=t.stopArrDep)!=null?_:!0,S=t.stopDepth||ka,T=`${a}`,K=n?`${a}/val`:T,F=i||T,b=ki(i),R=ys(m,{},d);return{isDestroyed:!1,alertDeadCycleErr:l,checkDeadCycle:u,rawState:s,sharedKey:a,sharedKeyStr:T,rootValKey:K,moduleName:i,usefulName:F,forAtom:n,forGlobal:r,loc:b,deep:f,rules:y,before:g,mutate:m,mutateFnDict:R,onRead:null,enableMutate:d,stateType:o,recordLoading:p,stopArrDep:E,stopDepth:S,isPrimitive:c}}function qu(e){const{rawState:t,sharedKey:n,rootValKey:r,deep:o,rules:s,stopDepth:c,stopArrDep:a,forAtom:i}=e,l={},f={},u={keys:[],isArrDict:{},arrKeyStopDcit:{},depth:c,stopArrDep:a},d={},p=Gt(o);s.forEach(m=>{const E=[],{when:S,ids:T=[],globalIds:K=[],stopDep:F}=m;let b;if(p){let A="";b=pt(t,{onOperate:({fullKeyPath:_,value:M,isBuiltInFnKey:I})=>{if(I)return;const O=$(_,n);A&&O.includes(A)&&E.pop(),E.push(O),d[O]=Array.isArray(M),A=O}})}else b=Se(t,{set:Ic,get:(A,_)=>{const M=$([_],n);E.push(M);const I=A[_];return d[M]=Array.isArray(I),I}});const R=i?b.val:b,D=W(S,R),h=(A,_,M)=>{const I=Be(A,M,[]);_.forEach(O=>w(I,O))},v=A=>{h(l,T,A),h(f,K,A);let _;d[A]?(_=F!=null?F:La,u.arrKeyStopDcit[A]=_,u.isArrDict[A]=d[A]):_=F!=null?F:!1,_&&w(u.keys,A)};E.forEach(v),D.includes(R)&&v(r)});const y=Object.keys(l).length>0,g=Object.keys(f).length>0;return{hasIds:y,idsDict:l,hasGlobalIds:g,globalIdsDict:f,stopDepInfo:u}}function Qu(e){const{desc:t=gt,strict:n=!1,throwErr:r=!1,extraArgs:o}={};return typeof e=="string"?{desc:e,strict:n,throwErr:r,extraArgs:o}:G(C({desc:t,strict:n},e),{throwErr:r,extraArgs:o})}function hs(e,t){var o;let n=P,r=!1;return k(t)?n=t:X(t)&&(n=t.deps||P,r=(o=t.immediate)!=null?o:!1),r=e?!0:r,{immediate:r,deps:n}}function ef(e){return e?typeof e=="boolean"?{enableStatus:e}:X(e)?e:{}:{}}function tf(e){Array.isArray(e)&&e.forEach(t=>{const n=Tn.current(t),r=Y(t)||(n==null?void 0:n.internal);if(r){const{depKey:o,sharedKey:s}=wo(r);Le([o],{sharedKey:s})}n&&n.recordDep(wo(r))})}function ms(e,t,n){const{deps:r,immediate:o}=hs(e,n),s=Lt(t,{scopeType:ae.STATIC,deps:r,immediate:o});return{run:c=>Ne(s.fnKey,{throwErr:c}),unwatch:()=>xn(s)}}function Lt(e,t){const{scopeType:n,fnCtxBase:r,immediate:o,deps:s=P,label:c="watch",sharedState:a,isSimpleWatch:i}=t;if(!k(e))throw new Error(`ERR_NON_FN: pass an non-function to ${c}!`);const l=ns(e,{specificProps:{scopeType:n,fnType:Qr,isSimpleWatch:i},fnCtxBase:r});jn(l.fnKey,ue(a));const f=s()||[];return tf(f),o&&e({isFirstCall:!0}),Re(),l}function nf(e,t){return ms(!1,e,t)}function rf(e,t){return ms(!0,e,t)}var gs=()=>{},Jn=new Map;function Es(e,t){const{forAtom:n,rawState:r}=e,{deps:o,extraBound:s}=t;return n?W(o,r.val,s):W(o,r,s)}function of(e){var t;return(t=Jn.get(e))!=null?t:!1}function Zn(e,t){const{sn:n,getArgs:r=P,from:o,throwErr:s,isFirstCall:c,fnItem:a,mergeReturn:i,extraArgs:l}=t,{desc:f="",depKeys:u,task:d=gs,extraBound:p}=a,y=Y(e),{sharedKey:g}=y,m={desc:f,sn:n,from:o},E=Gn(o,f),{draft:S,draftRoot:T}=Bn(y,{depKeys:u,desc:f,from:o}),K=I=>{ot(g,I)},F=I=>{K(f);const{finish:O}=y.setStateFactory(m);return O(I)},b=j.MUTATE===o?Es(y,a):[],R={isFirstCall:c,desc:f,setState:F,input:b,draft:S,draftRoot:T,flush:K,extraBound:p,extraArgs:l},D=r(R)||[R],h=Jn.get(d),v=h===void 0,A=(I,O,Me)=>{(v||h)&&Qo(y,E,{loading:I,err:O,ok:Me})};A(!0,null,!1);const _=I=>{if(et.del(),A(!1,I,!1),s)throw I;return{snap:y.snap,err:I,result:null}},M=I=>(i&&I&&F(I),A(!1,null,!0),K(f),{snap:y.snap,err:null,result:I});try{const I=d(...D),O=Yt(I);return Jn.set(d,O),O?Promise.resolve(I).then(M).catch(_):M(I)}catch(I){return _(I)}}function vs(e,t){const{sn:n,getArgs:r=P,from:o,throwErr:s,isFirstCall:c=!1,fnItem:a,extraArgs:i}=t,{desc:l="",watchKey:f,fn:u=gs,extraBound:d}=a,p=j.MUTATE===o;p&&qe.set(f);const y=Y(e),{setStateFactory:g,forAtom:m,sharedRoot:E}=y,T={desc:l,sn:n,from:o,isFirstCall:c,enableDep:p&&c},K=A=>{const{finish:_}=g(T);return _(A)},F=kt(E,m),b=p?Es(y,a):[],{draftNode:R,draftRoot:D,finish:h}=g(T),v=r({draft:R,draftRoot:D,setState:K,desc:l,input:b,extraArgs:i})||[R,{input:b,state:F,draftRoot:D,isFirstCall:c,extraBound:d,extraArgs:i}];try{const A=wn(a.watchKey);if(A.dcErrorInfo.err)return Wn(y,A.dcErrorInfo),{snap:y.snap,err:null,result:null};const _=u(...v);return h(_,{fnKey:A.fnKey}),Ss(y,a,c),{snap:y.snap,err:null,result:null}}catch(A){if(Ss(y,a,c),s)throw A;return{snap:y.snap,err:A,result:null}}}function Ss(e,t,n){n&&!t.onlyDeps&&(nt().fnCtx?t.depKeys=Re():t.depKeys=et.current(),et.del());const r=fe.current();r.isTop&&r.fnKey===t.watchKey&&Te(e,wn(t.watchKey),r.writeKeys),qe.del()}function sf(e,t){var r;eu(),et.del(),On(!1);const n=nt().fnCtx;n&&(n.subFnInfo=t,n.checkDeadCycle=(r=t.checkDeadCycle)!=null?r:e.checkDeadCycle,t.watchKey=n.fnKey),t.onlyDeps&&(t.depKeys=Re())}function qn(e){const{target:t,dict:n}=e,r=Object.keys(n);if(!r.length)return;const o=Y(t),{mutateFnDict:s,usefulName:c,forAtom:a,sharedRoot:i}=o,l=f=>uo(o,f);r.forEach(f=>{const u=s[f];Lt(({sn:d,isFirstCall:p})=>{if(p&&sf(o,u),!o.enableMutate)return;const{desc:y,fn:g,task:m,immediate:E}=u,S=xu(c,y);try{if(S.isIn)throw os(c,S.cycle,y);const T={sn:d,throwErr:!0,isFirstCall:p,fnItem:u,from:j.MUTATE};if(g&&(p||!m)&&vs(t,T),m){p&&(u.depKeys=Re());const K=p&&(E!=null?E:!g);(!p||K)&&Zn(t,T).catch(l)}return u}catch(T){T.cause==="DeadCycle"&&ku(c,T,o.alertDeadCycleErr),l(T)}},{deps:()=>u.deps?u.deps(kt(i,a),u.extraBound)||[]:[],sharedState:t,scopeType:ae.STATIC,immediate:!0})})}var{ACTION:As}=j;function cf(e,t){const{label:n,throwErr:r,desc:o="",task:s,mergeReturn:c=!0}=t,a=In(r,!1),i=De(e,{label:n}),{forAtom:l}=i,f=(u,d)=>{const p=In(d,a),y=gn({desc:o,task:s,depKeys:[]}),g=(m,E)=>m.__action?m.__action(E):m(E);return Zn(e,{fnItem:y,from:As,mergeReturn:c,throwErr:p,getArgs:({draft:m,draftRoot:E,setState:S,desc:T,flush:K})=>[{draft:m,draftRoot:E,setState:S,desc:T,payload:u,flush:K,merge:b=>{fs({partial:b,forAtom:l,draftRoot:E,draftNode:m})},dispatch:g}]})};return Qo(i,Gn(As,o),{loading:!1,ok:!0,err:null}),f.__sharedKey=i.sharedKey,f.__fnName=o,f.__task=s,s.__action=f,f}function _s(e){return t=>(n,r="",o)=>cf(e,{task:n,desc:r,label:"action",mergeReturn:t,throwErr:o})}var{TASK:Ds}=St,{STATIC:af,HOOK:uf}=ae;function Ks(e,t,n){if(!n&&(!X(t)||Yt(t)))throw new Error("ERR_NON_OBJ: derive,deriveAsync expect result to be a plain object");const{isAsync:r,isAsyncTransfer:o}=e;if(r&&!o){const s=Mo(t),c=ue(t);if(s&&e.fnKey!==s||c)throw new Error("ERR_INVALID_CALL: derive,deriveAsync can not transfer another derived result or shared state, it will cause wrong result")}}function ff(e,t){const n=Se(e.result,{set:()=>(Ce("changing derived result is invalid"),!1),get:(r,o)=>{if(o===$e)return t;const s=r[o];return Le(e.depKeys,{belongCtx:e}),Cn(e.depKeys,n),kn(0,s,n,"",[o],!0,t),s}});return e.proxyResult=n,n}function Rs(e,t){const{result:n,isUpstream:r}=t,o=tt(n);o&&(e.depKeys=we(e.depKeys.concat(o.depKeys)),w(o.nextLevelFnKeys,e.fnKey),w(e.prevLevelFnKeys,o.fnKey),e.isFirstLevel=!1,r==null||r())}function lf(e){var D,h;const{scopeType:t=af,fnCtxBase:n,isAsyncTransfer:r=!1,asyncType:o=Ds,returnUpstreamResult:s,runAsync:c=!0,forAtom:a=!1,immediate:i}=e;if(!k(e.fn))throw new Error("ERR_NON_FN: derive need fn arg!");const{fn:l=P,deps:f=P,task:u,stateRoot:d={}}=e,p=ke(d),y=(D=e.isAsync)!=null?D:k(u),g=(h=e.showLoading)!=null?h:y,m=ns(l,{specificProps:{forAtom:a,scopeType:t,stateRoot:d,isStateAtom:p,fnType:qr,task:u,deps:f,isAsync:y,asyncType:o,isAsyncTransfer:r,showLoading:g},fnCtxBase:n});jn(m.fnKey,0);const{input:E,state:S}=ss(f,d,p);E.forEach(v=>Rs(m,{result:v}));let K=l({isFirstCall:!0,prevResult:null,triggerReasons:[],input:E,sn:0,state:S,stateRoot:d,isAtom:p});Re();const F=tt(K);a&&!F&&(K={val:K,z__is_atom_result__:!0});const b=m.fnKey;Ks(m,K),Rs(m,{result:K,isUpstream:()=>{m.returnUpstreamResult=s!=null?s:!y}}),Pn(m),m.returnUpstreamResult||To(K,t,b);const R=c&&o===Ds&&(i!=null?i:!e.fn);return u&&R&&Ne(b,{isFirstCall:!0,sn:m.renderInfo.sn+1}).then(v=>{Ks(m,v[0],a)}).catch(v=>ye(v)),m.result=K,t===uf&&rs(m)&&m.setLoading(!0),m.returnUpstreamResult?m.proxyResult=K:ff(m,a),m}function Qn(e,t){const n=k(e)?{fn:e}:e||{};return lf(C(C({},t||{}),n))}function Ts(e,t){return Qn(e,{forAtom:!0,stateRoot:t}).proxyResult}function df(e,t){return Qn(e,{stateRoot:t}).proxyResult}function pf(e){return t=>G(C({},t),{deps:e})}function yf(e){return e}var Nt=e=>[e.snap,e.err];function er(e){const{target:t,desc:n="",forTask:r=!1,throwErr:o,extraArgs:s}=e,{mutateFnDict:c,snap:a}=Y(t),i=n||gt,l=c[i];if(!l)return{snap:a,err:new Error(`mutate fn ${i} not defined`),result:null};if(r&&!l.task)return{snap:a,err:new Error(`mutate task ${i} not defined`),result:null};const f=In(o,!1),u={sn:0,fnItem:l,from:j.MUTATE,throwErr:f,extraArgs:s};return r?Zn(t,u):vs(t,u)}function Ms(e,t,n,r){return{run:o=>{const s=er({target:e,desc:t,throwErr:o});return Nt(s)},runTask:o=>Promise.resolve(er({target:e,desc:t,forTask:!0,throwErr:o})).then(Nt),desc:t,oriDesc:n,getSnap:()=>r.snap,snap:r.snap,__sharedKey:r.sharedKey}}function hf(e){const{target:t,fnItem:n,label:r,extraTarget:o}=e,s=De(t,{label:r}),c=ps(n,"",s.mutateFnDict);if(!c)throw new Error("not a fn or fnItem { fn }");o&&(c.extraBound=yn(o)),s.mutateFnDict[c.desc]=c,c.enabled=s.enableMutate;const a={[c.desc]:c};return s.enableMutate&&qn({target:t,dict:a}),Ms(t,c.desc,c.oriDesc,s)}function mf(e){const{target:t,fnDict:n,label:r}=e,o=De(t,{label:r}),s=ys(n,o.mutateFnDict,o.enableMutate);if(e.extraTarget){const a=yn(e.extraTarget);Object.keys(s).forEach(i=>s[i].extraBound=a)}o.enableMutate&&qn({target:t,dict:s});const c={};return Object.keys(s).forEach(a=>{c[a]=Ms(t,a,a,o)}),c}function gf(e,t){const{label:n,descOrOptions:r,forTask:o=!1}=t,{desc:s,strict:c,throwErr:a,extraArgs:i}=Qu(r);return s?zo(e,{label:n,strict:c})?{ok:!0,desc:s,forTask:o,throwErr:a,extraArgs:i,err:null}:{ok:!1,desc:s,forTask:o,throwErr:a,extraArgs:i,err:new Error("not a valid atom or shared result")}:{ok:!1,desc:s,forTask:o,throwErr:a,err:new Error("miss desc")}}function bs(e,t){const{ok:n,desc:r,forTask:o,err:s,throwErr:c,extraArgs:a}=gf(e,t);if(!n){if(c)throw s;return o?Promise.resolve([e,s]):[e,s]}const i=er({target:e,desc:r,forTask:o,throwErr:c,extraArgs:a});return o?Promise.resolve(i).then(Nt):Nt(i)}function ws(e,t){return bs(e,{descOrOptions:t,label:"runMutate"})}function Is(e,t){return bs(e,{descOrOptions:t,label:"runMutateTask",forTask:!0})}function Fs(e,t){return n=>hf({target:e,extraTarget:t,fnItem:n,label:"mutate"})}function tr(e,t){return n=>mf({target:e,extraTarget:t,fnDict:n,label:"mutateDict"})}function Ef(e){return e}function Cs(e,t,n={}){const{tuple:r}=Ft(e,t,n);return r}function Os(e,t,n={}){const{tuple:r}=Ft(e,t,n),[o,s,c]=r;return G(C({},c),{state:o,setState:s})}var vf="ERR_NOT_DERIVED_RESULT: useDerived only accept derived result",Sf="ERR_NOT_ATOM_RESULT: useDerivedAtom only accept derived atom";function Af(e,t,n){return e.isExpired?(e.isExpired=!1,!0):k(n)?!1:n!==t}function _f(e){$n(e),e.depKeys.length=0,e.prevLevelFnKeys.length=0,e.renderInfo.sn+=1}function Df(e,t){const{result:n,forAtom:r,showLoading:o}=t,{fnCtx:s,input:c,deriveFn:a}=e;let i=!1;if(a)if(Af(s,c,n))i=!0,_f(s);else return;e.input=n;const l=tt(n);if(!l)throw new Error(vf);if(r&&!ve(n))throw new Error(Sf);e.deriveFn=()=>l.result,Qn({fn:()=>l.result,deps:()=>[],task:()=>_c(this,null,function*(){return l.result})},{isAsync:l.isAsync,scopeType:ae.HOOK,fnCtxBase:s,isAsyncTransfer:!0,runAsync:!1,returnUpstreamResult:!0,forAtom:r,asyncType:St.MAY_TRANSFER,showLoading:o}),$o(s),i&&s.updater()}function Ps(e,t){const{result:n,forAtom:r}=t,{hookImpl:o,react:s}=e,c=o.useForceUpdate(),{current:a}=s.useRef({input:n,deriveFn:null,fnCtx:null});a.fnCtx||(a.fnCtx=Ct({updater:c,scopeType:ae.HOOK,forAtom:r}));const i=a.fnCtx;return i.renderStatus=We,Df(a,t),i}function Kf(e,t){t.shouldReplaceResult&&($o(t),t.shouldReplaceResult=!1),It(e,t.subscribe,()=>ko(t)),e.react.useEffect(()=>{t.renderStatus=ln})}function xs(e,t){e.react.useEffect(()=>(t.mountStatus=vt,xo(t),()=>{$n(t)}),[t])}function nr(e,t){const n=Ps(e,t);return It(e,n.subscribe,()=>ko(n)),xs(e,n),n}function Rf(e,t){const n=Ps(e,t);return Kf(e,n),xs(e,n),n}function rr(e,t,n){const r=Rf(e,C({result:t},n||{})),{proxyResult:o,status:s,renderInfo:c}=r;return[ve(t)?o.val:o,s,c]}function ks(e,t,n){if(t===null)return n;if(!k(t))return null;const{sharedState:r,forAtom:o}=e,s=o?r.val:r,c={};Rn.set(i=>c[i[0]]=1);const a=W(t,s);return Rn.del(),a.includes(s)?e.key2InsKeys:c}function Ls(e,t,n){const r=De(t),[o]=e.react.useState(()=>ks(r,n,null));return s=>{const{insCtxMap:c,key2InsKeys:a}=r,i=ks(r,s,a)||o||a,l={};if(Object.keys(i).forEach(u=>{(a[u]||[]).forEach(p=>l[p]=1)}),Object.keys(l).length){r.sn+=1;const u=r.sn;Object.keys(l).forEach(d=>{zn(c,Number(d),u)})}}}function Tf(e,t){ar(e);const n=Nn();return Hn(e,n,{collectType:"no",globalId:t}).renderInfo}var{ACTION:Ns,MUTATE:Vs}=j;function or(e,t){ar(e);const{target:n,from:r="Mutate"}=t||{};let o=qo();n&&(o=De(n));const{loadingProxy:s,loadingState:c}=st(le,{apiCtx:e,internal:o,from:r});return{loadingProxy:s,loadingState:c,internal:o,from:r}}function Us(e,t){const{loadingProxy:n,internal:r,from:o}=or(e,t),{proxyState:s,extra:c,renderInfo:a}=Hn(e,n);return[Ke(c,s,o),r.setState,a]}function Mf(e,t){const{loadingProxy:n}=or(e,{target:t,from:Vs});return n}function bf(e,t){return Us(e,{target:t,from:Vs})}function wf(e,t){const{loadingProxy:n}=or(e,{target:t,from:Ns});return n}function If(e,t){return Us(e,{target:t,from:Ns})}function Bs(e){return e.hookImpl.useForceUpdate()}function Ys(e,t){const n=(r,o)=>{let s=null;if(k(r)){const c=sn(o),a=r(c);s=cn(c),X(a)&&Object.assign(s,a)}else X(r)&&(s=C(C({},o),r));return s};return e.hookImpl.useObjectLogic(t,n,!0)}function Ff(e,t,n){const{useRef:r,useMemo:o,useEffect:s}=e.react,c=r({fn:n,wrap:null});c.current.fn=o(()=>n,[n]),c.current.wrap||(c.current.wrap=(...a)=>{c.current.fn(...a)}),s(()=>{const a=oi(),i=c.current.wrap;return a.on(t,i),()=>a.off(t,i)},[t,c])}function sr(e,t,n={}){const r=ke(t),{insCtx:o}=Ft(e,t,G(C({},n),{forAtom:r,isReactive:!0}));return[o.proxyStateVal,o.proxyState,o.renderInfo]}function Hs(e,t,n={}){const[r,o,s]=sr(e,t,n);return G(C({},s),{state:r,stateRoot:o})}function Cf(e,t,n){const r=X(n)?n:{};e.react.useEffect(()=>{const{srvRef:o}=r;k(o)&&o(t)},[])}function Of(e,t,n){const r=e.hookImpl.useStable(t);return Cf(e,r,n),r}function Pf(e){return t=>e.current=t}var{HOOK:Gs}=ae;function js(e,t){e(()=>{var n,r;return t.mountStatus=vt,xo(t),(r=(n=t.extra).deferedWatch)==null||r.call(n),()=>{$n(t)}},[t])}function $s(e,t){const{useRef:n,useState:r,useMemo:o,useEffect:s}=e.react,{label:c,forEffect:a,watchFn:i,watchOptions:l}=t,f=n({fn:i,wrap:null,fnKey:"",isDeferMarked:!1}),[u]=r(()=>Ct());if(f.current.fn=o(()=>i,[i]),!f.current.wrap){const{deps:d,immediate:p}=hs(a,l);f.current.wrap=g=>{if(u.mountStatus===vt){f.current.fn(g);return}u.extra.deferedWatch=()=>{if(f.current.isDeferMarked){f.current.fn(g);return}f.current.isDeferMarked=!0,jn(f.current.fnKey,0),f.current.fn(g),Re()}};const{fnKey:y}=Lt(f.current.wrap,{scopeType:Gs,fnCtxBase:u,deps:d,immediate:p,label:c});f.current.fnKey=y}js(s,u)}function xf(e,t,n){const{useState:r,useEffect:o}=e.react,[s]=r(()=>Ct());if(s.fn===P){const{manualDepKeys:c=[]}=n;Lt(t,{scopeType:Gs,fnCtxBase:s,deps:()=>c.map(i=>{const{sharedKey:l,keyPath:f}=bo(i),u=hi(l);return he(u,f)}),isSimpleWatch:!0})}js(o,s)}function kf(e,t,n){$s(e,{label:"useWatch",forEffect:!1,watchFn:t,watchOptions:n})}function Lf(e,t,n){$s(e,{label:"useWatchEffect",forEffect:!0,watchFn:t,watchOptions:n})}function Nf(e){const{internal:t,setFactoryOpts:n}=e,{rawState:r,forAtom:o,stopDepth:s,sharedKey:c}=t,a=mn(n),i=C({},r),l=(p,y,g,m)=>{const E=Ze(y,g,{parentType:Fo(p),parentKeyPath:m});is(E,{internal:t,mutateCtx:a}),gr(i,E.fullKeyPath,g)},f=(p,y,g)=>Xe(p,{set:(m,E,S)=>(l(m,E,S,g),!0),get:(m,E)=>{const S=m[E];if(mt.includes(E))return wt(y===1,o,c,E,S);const T=Ze(E,S,{isChanged:!1,parentKeyPath:g,op:"get",parentType:Fo(m)});return y<s&&_e(S)?f(S,y+1,T.fullKeyPath):he(i,T.fullKeyPath)}}),u=f(i,1,[]);Tt.set(u,o),Mn.set(a);const d=o?u.val:u;return{draftRoot:u,draftNode:d,finishMutate(p,y={}){ds(a,y);const g=C({state:{},mutateCtx:a},e);ls(g,u,d,p)}}}function Vf(e){let t=e;if(e){e.persist&&e.persist();const{currentTarget:n}=e;n&&e.type?n.tagName==="INPUT"&&n.type==="checkbox"?t=n.checked:t=n.value:e.nativeEvent&&e.target&&(t=e.target.value)}return t}function Uf(e){let t=[];return{target:Ni(e,({fullKeyPath:r})=>{t=r}),getPath:()=>t}}function Ws(e,t,n){return o=>{let s=Vf(o);e(c=>{const{isAtom:a,draftRoot:i}=Tt.current(),l={draft:c,draftRoot:i,path:t,isAtom:a,UNDEFINED:Pa},f=n==null?void 0:n(s,l);gr(i,t,f!==void 0?f:s)},{from:j.SYNC})}}function cr(e,t){const{sharedKey:n,innerSetState:r}=t;let o=$(e,n),s=Xs.get(o);return s||(s=Ws(r,e),Xs.set(o,s)),s}var Xs=new Map;function zs(e){const{forAtom:t,rawState:n}=e;return t?yr(n.val)?Xe(n.val,{get:(r,o)=>cr(["val",o],e)}):cr(["val"],e):Xe(n,{get:(r,o)=>cr([o],e)})}var Js=new Map;function Zs(e){const{forAtom:t,sharedKey:n,innerSetState:r,rawState:o}=e,s=Uf(o);return(c,a)=>{let i=[];if(Array.isArray(c))i=t?["val",...c]:c;else{const{target:u,getPath:d}=s;c(t?u.val:u),i=d()}let l=$(i,n);a&&(l+=`${a.toString()}`);let f=Js.get(l);return f||(f=Ws(r,i,a),Js.set(l,f)),f}}function Bf(e,t,n){const{deep:r,forAtom:o,sharedKey:s}=n,c=qu(n),a=Gt(r),i=(E={})=>{const S={internal:m,setFactoryOpts:E},{finishMutate:T,draftRoot:K,draftNode:F}=a?Wu(S):Nf(S);return{finish:(b,R={})=>{const D=m.snap;if(b===D)return D;const h=Ui(o,b,F);return T(h,R),m.snap},draftRoot:K,draftNode:F}},l=(E={})=>i(E),f=(E,S={})=>i().finish(E,S),u=(E,S)=>{const[T,K,F]=S;return Un(e,Qe.current(s)),i({handleCbReturn:T,enableDep:K}).finish(E,zu(F))},m=go(n,{sharedRoot:e,sharedState:t,setState:(E,S)=>u(E,[!0,!0,S]),setDraft:(E,S)=>u(E,[!1,!0,S]),insSetState:(E,S)=>u(E,[!0,!1,S]),insSetDraft:(E,S)=>u(E,[!1,!1,S]),setStateFactory:l,innerSetState:f,ruleConf:c,isDeep:a});return m.sync=Zs(m),m.syncer=zs(m),li(e,m),m}function Yf(e,t){const n=Zu(e,t),{sharedRoot:r,sharedState:o}=Wi(n),s=Bf(r,o,n);mi(r,n),Oi(),qn({target:r,dict:n.mutateFnDict});const{draft:c,draftRoot:a}=Bn(s,{isTop:!0});return s.reactive=c,s.reactiveRoot=a,fi(n.moduleName,s.loc),Cu(s.usefulName),ri(s),{sharedRoot:r,sharedState:o,internal:s,parsedOptions:n}}var{USER_STATE:qs}=ee,{MUTATE:Hf,ACTION:Qs}=j;function ar(e,t){qs===(t||qs)&&!Nn()&&(Xi(e,le),bu(e,le))}function ec(e,t){const{createFn:n,ldAction:r,actionDict:o,actionCreator:s,internal:c,apiCtx:a,forTp:i=!1}=e;st(n,{internal:c,from:Qs,apiCtx:a});const l={},f={};return Object.keys(o).forEach(u=>{const d=o[u],p=i?d.__task:d,y=s(!1)(p,u,t);y.__fnName=u,f[u]=y;const g=(...m)=>{const E=y(...m);return of(p)?Promise.resolve(E).then(S=>S.result):E.result};g.__fnName=u,l[u]=g}),{actions:l,eActions:f,getLoading:()=>r.getLoading(l),useLoading:()=>r.useLoading(l)[0],useLoadingInfo:()=>r.useLoading(l)}}function tc(e,t,n){const{state:r,stateRoot:o,isAtom:s}=e,c=yn(n);return k(t)?t({state:r,stateRoot:o,isAtom:s,extraBound:c}):t}function nc(e){const{common:t,ldMutate:n,mutateFnDict:r,extra:o}=e,s=tc(t,r,o),c=tr(t.stateRoot,o)(s);return{witnessDict:c,getLoading:()=>n.getLoading(c),useLoading:()=>n.useLoading(c)[0],useLoadingInfo:()=>n.useLoading(c)}}function Gf(e){const{common:t,ldMutate:n,inital:r,mutateFnDict:o}=e,{stateRoot:s,useState:c,state:a,isAtom:i}=oc(t.apiCtx,r),l=G(C({},t),{stateRoot:s,state:a,isAtom:i,internal:Y(s)}),f=nc({common:l,ldMutate:n,mutateFnDict:o,extra:t.stateRoot});return C({derivedState:s,useDerivedState:c},f)}function jf(e){const{common:t,deriveFnDict:n,throwErr:r}=e,o=tc(t,n),{apiCtx:s,stateRoot:c}=t,a={},i={};return Object.keys(o).forEach(f=>{const u=Ts(o[f],c);a[f]=u,i[f]={runDerive:d=>Bu(u,d!=null?d:r),runDeriveTask:d=>Yu(u,d!=null?d:r),useDerived:d=>rr(s,u,d)[0],useDerivedInfo:d=>rr(s,u,d)}}),{result:new Proxy(a,{get:(f,u)=>a[u].val}),helper:i}}function $f(e,t){if(t.enableMutate=e,e){const{mutateFnDict:n}=t,r={};Object.keys(n).forEach(o=>{const s=n[o];s.enabled||(s.enabled=!0,r[o]=s)}),tr(t.sharedState)(r)}}function Wf(e){const{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:i}=e;return{moduleName:t,deep:n,recordLoading:r,stopDepth:o,stopArrDep:s,alertDeadCycleErr:c,checkDeadCycle:a,enableMutate:i}}function le(e,t){const{stateType:n,apiCtx:r}=e;ar(r,n);const{sharedRoot:o,sharedState:s,internal:c}=Yf(e,t),{syncer:a,sync:i,forAtom:l,setState:f,setDraft:u,sharedKey:d,sharedKeyStr:p,rootValKey:y,reactive:g,reactiveRoot:m}=c,E=_s(o),S=E(),T={internal:c,from:Hf,apiCtx:r},K=le,F=ts(K,G(C({},T),{from:Qs})),b=ts(K,T),R={createFn:K,internal:c,apiCtx:r,state:s,stateRoot:o,isAtom:l},D=G(C({},R),{ldAction:F,actionCreator:E});return{state:s,stateVal:s,stateRoot:o,setState:f,setDraft:u,setEnableMutate:h=>$f(h,c),getOptions:()=>Wf(c),setOnReadHook:h=>c.onRead=h,defineActions:h=>v=>ec(G(C({},D),{actionDict:v}),h),defineTpActions:h=>v=>ec(G(C({},D),{actionDict:v,forTp:!0}),h),defineMutateDerive:h=>v=>Gf({common:R,ldMutate:b,inital:h,mutateFnDict:v}),defineMutateSelf:()=>h=>nc({common:R,ldMutate:b,mutateFnDict:h}),defineFullDerive:h=>v=>jf({common:R,deriveFnDict:v,throwErr:h}),mutate:Fs(o),runMutate:h=>ws(o,h),runMutateTask:h=>Is(o,h),action:E,call:(h,v,A,_)=>S(h,A,_)(v),useState:h=>Cs(r,o,h),useStateX:h=>Os(r,o,h),useForceUpdate:h=>Ls(r,o,h),useLocalState:h=>Ys(r,h),useLocalForceUpdate:()=>Bs(r),getMutateLoading:b.getLoading,useMutateLoading:b.useLoading,getActionLoading:F.getLoading,useActionLoading:F.useLoading,getSnap:h=>mo(o,h),sync:i,syncer:a,sharedKey:d,sharedKeyStr:p,rootValKey:y,reactive:g,reactiveRoot:m,reactiveDesc:h=>Bo(o,h),useReactive:h=>sr(r,o,h),useReactiveX:h=>Hs(r,o,h),flush:h=>Un(o,h),isAtom:l}}function rc(e,t,n){const r=le({apiCtx:e,rawState:t},n);return[r.stateRoot,r.setState,r]}function oc(e,t,n){return le({apiCtx:e,rawState:t},n)}function Xf(e,t,n){const r=le({apiCtx:e,rawState:t,forAtom:!0},n);return[r.stateRoot,r.setState,r]}function zf(e,t,n){return le({apiCtx:e,rawState:t,forAtom:!0},n)}function sc(e,t){const{label:n,isSyncer:r}=t,o=De(e,{label:n});return(r?zs:Zs)(o)}function Jf(e){return sc(e,{label:"sync"})}function Zf(e){return sc(e,{label:"syncer",isSyncer:!0})}var qf=100,Qf=5e3;function el(e,t){return{key:e,results:[],depKeys:[],enableStatus:t,collected:!1,mounted:!1,renderAtomOnce:!1,time:0,status:{loading:!1,err:null,ok:!0}}}function tl(e,t=!1){const n=te();e&&(n.initCount+=1);const r=Si(),o=el(r,t);return Lo(e).set(r,o),o}function nl(e){const t=te();e.mounted=!0,e.time=Date.now(),t.mountedCount+=1}function rl(e,t){const n=te(),r=Lo(t);if(r.delete(e),t&&r.size===qf&&n.initCount-n.mountedCount>2){n.initCount=0,n.mountedCount=0;const o=Date.now();r.forEach((s,c)=>{!s.mounted&&o-s.time>Qf&&r.delete(c)})}}function ol(e,t){const n=te();n.runningKey=e.key,n.isDynamic=t}function sl(e){const t=te();t.runningKey="",t.isDynamic=!1,e.collected=!0}function cl(e,t,n){xf(e,n,{manualDepKeys:t.depKeys})}function cc(e,t,n){let r={loading:!1,err:null,ok:!0};return cl(e,t,n),t.results.forEach(o=>{const s=nr(e,{result:o,forAtom:ve(o),showLoading:t.enableStatus});s.status.ok||(r=s.status)}),r}function ac(e,t,n){e.react.useEffect(()=>(t.mounted||nl(t),()=>{rl(t.key,n)}),[t])}var al=()=>!0,ir=e=>e;function il(e){const t=[];for(let n=1;n<=e.length;n++)t.push(e.slice(0,n));return t}function ur(e,t,n,r,o){const s=t;return s.displayName=n,r?e.react.memo(s,o):s}function ic(e,t){const{sharedState:n,depKey:r,keyPath:o,compare:s,sharedKey:c,format:a=ir}=t;return ur(e,function(){const l=Hn(e,n,{arrDep:!0});l.isFirstRender&&(o.length>=2?il(o).forEach(d=>{l.recordDep({sharedKey:c,depKey:$(d,c),keyPath:d,parentKeyPath:d.slice(0,d.length-1)},At)}):l.recordDep({sharedKey:c,depKey:r,keyPath:o}));const f=he(l.internal.rawState,o);return a(f)},"HeluxSignal",!0,s)}function fr(e,t){return ur(e,function(){const{result:r,format:o=ir}=t,s=nr(e,{result:r,forAtom:!0});return o(s.proxyResult.val)},"HeluxDerivedAtomSignal",!0,t.compare)}function ul(e,t){return ur(e,function(){const{result:r,keyPath:o,format:s=ir}=t;return nr(e,{result:r,forAtom:!1}),s(he(r,o))},"HeluxDerivedSignal",!0,t.compare)}function uc(e,t){const{isDynamic:n,cb:r,props:o,ref:s}=t,{collected:c,status:a}=e;c||ol(e,n);const l=r(o,{props:o,status:a,read:Kc,ref:s})||"";return c||sl(e),l}function fc(e,t,n){const r=ve(n);if(t.renderAtomOnce&&!r)throw new Error("block cb once returned derived atom but not keep to return it in new render period!");if(r){t.renderAtomOnce=!0;const o=fr(e,{result:n});return e.react.createElement(o,{status:{loading:!1,err:null,ok:!0}})}return eo(n)}function lc(e,t,n,r){const{memo:o=!0,compare:s}=r||{},{key:c}=t,{react:a}=e,i=a.forwardRef||P,l=n();let f=i(l);pe()&&(l.displayName="HeluxKeyedBlockForHMR",f=i((d,p)=>(p&&wc(p,"current")&&(t.ref=p),a.createElement(l,G(C({},d),{key:c})))));const u=o?a.memo(f,s):f;return u.displayName="HeluxBlock",u[fn]=!0,u}function fl(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,{useForceUpdate:c}=o.hookImpl,a=r?ac:P;return lc(o,s,()=>(i,l)=>{const f=s.ref||l,u=uc(s,{isDynamic:r,cb:n,props:i,ref:f}),d=c();return cc(o,s,d),a(o,s,r),fc(o,s,u)},t)}function ll(e,t){const{cb:n,isDynamic:r,apiCtx:o,blockCtx:s}=e,c=r?ac:P,{useForceUpdate:a}=o.hookImpl,{useEffect:i}=o.react;return lc(o,s,()=>(l,f)=>{const u=s.ref||f,d=uc(s,{isDynamic:r,cb:n,props:l,ref:u}),p=a(),y=cc(o,s,p);c(o,s,r);const g=s.status.loading,m=y.loading;return i(()=>{g!==m&&p()},[g,m]),s.status=y,fc(o,s,d)},t)}function dc(e,t){const n=ef(t),{enableStatus:r}=n,o=G(C({},e),{blockCtx:tl(e.isDynamic,r)});return r?ll(o,n):fl(o,n)}function dl(e,t,n){return dc({apiCtx:e,isDynamic:!1,cb:t},n)}function pc(e,t,n){return dc({apiCtx:e,isDynamic:!0,cb:t},n)}function yc(e,t,n){const{react:r}=e;if(t&&t[fn])return r.createElement(t);const o=al;if(k(t)){const d=pc(e,t,{compare:o});return r.createElement(d)}if(ve(t)){const d=fr(e,{result:t,compare:o,format:n});return r.createElement(d)}if(ke(t)){const d=ue(t),p=Ht("val",d),g=ic(e,{sharedKey:d,sharedState:t,depKey:p,keyPath:["val"],compare:o,format:n});return r.createElement(g)}const s=$i(),{sharedKey:c,val:a,stateOrResult:i,depKey:l,keyPath:f,isDerivedResult:u}=s;if(t===a&&i){if(s.isDerivedAtom){const p=fr(e,{result:i,compare:o,format:n});return r.createElement(p)}if(u){const p=ul(e,{result:i,keyPath:f,compare:o,format:n});return r.createElement(p)}const d=ic(e,{sharedKey:c,sharedState:i,depKey:l,keyPath:f,compare:o,format:n});return r.createElement(d)}return t}var{shallowCompare:pl,isDiff:yl,isDraft:hl}=Ur,ml=rc,gl=yc,El={EVENT_NAME:an,RECORD_LOADING:un,VER:jr,LIMU_VER:Ia};function hc(e,t,n){return t(e,n)}function vl(e,t){return hc(e,t)}function Sl(e,t){return{build:n=>hc(e,t,n)}}var Al=["atom","atomx","share","sharex","getMutateLoading","getActionLoading","$","signal","block","blockStatus","dynamicBlock","dynamicBlockStatus"];function _l(e){return e.startsWith("use")||Al.includes(e)}function Dl(e){return Object.assign({useSyncExternalStore:P},e)}function Kl(e,t){const n=Nc(e),r=C({},n),o={react:Dl(e),hookImpl:n,act:t};t&&(n.useForceUpdate=()=>{const[,a]=e.useState({});return()=>t(()=>a({}))});const s=Gr;return Object.keys(s).forEach(a=>{const i=s[a];_l(a)?r[a]=i.bind(null,o):r[a]=i}),Object.assign({model:a=>vl(r,a),modelFactory:a=>Sl(r,a)},r)}function Rl(e){const{inited:t,API:n}=za();if(t)return n;const{heluxCtxKey:r,standalone:o,transfer:s,reactLib:c,act:a}=e,i=Q[r],l=(f,u)=>{const d=u||no(),p=Kl(c,a);return co({ROOT:d,inited:!0,api:p}),Q[f]=d,p};if(!i)return l(r);if(o)return l(`${String(r)}_${Date.now()}`);if(s){const f=no();co({ROOT:f,inited:!0}),s(i,f)}return l(r,i)}var Tl=N(70079),Ml=N.t(Tl,2),mc=Rl({heluxCtxKey:"__HELUX__",reactLib:Ml}),bl=mc.share,{atom:wl,atomx:Il,share:Fl,sharex:Cl,derive:Ol,deriveDict:Pl,defineDeriveTask:xl,defineDeriveFnItem:kl,runDerive:Ll,runDeriveTask:Nl,watch:Vl,watchEffect:Ul,useAtom:Bl,useAtomX:Yl,useReactive:Hl,useReactiveX:Gl,useDerived:jl,useWatch:$l,useWatchEffect:Wl,useGlobalId:Xl,useService:zl,useOnEvent:Jl,useMutable:Zl,useMutateLoading:ql,useActionLoading:Ql,useEffect:ed,useLayoutEffect:td,useStable:nd,useObject:rd,useLocalForceUpdate:od,useGlobalForceUpdate:sd,action:cd,signal:ad,block:id,dynamicBlock:ud,$:fd,mutate:ld,mutateDict:dd,runMutate:pd,runMutateTask:yd,defineMutateFnItem:hd,sync:md,syncer:gd,model:Ed,modelFactory:vd,emit:Sd,on:Ad,init:_d,reactiveDesc:Dd,flush:Kd,isAtom:Rd,isSharedState:Td,isDerivedAtom:Md,isDerivedResult:bd,isDraft:wd,storeSrv:Id,shallowCompare:Fd,markRaw:Cd,isDiff:Od,produce:Pd,getMutateLoading:xd,getActionLoading:kd,getDeriveLoading:Ld,getRawState:Nd,getSnap:Vd,getAtom:Ud,addMiddleware:Bd,addPlugin:Yd,cst:Hd}=mc}}]);
}());